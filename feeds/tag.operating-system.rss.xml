<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Just for noting</title><link>https://blog.m157q.tw/</link><description></description><lastBuildDate>Mon, 26 Oct 2015 15:30:00 +0800</lastBuildDate><item><title>OS Ch8 - Memory Management</title><link>https://blog.m157q.tw/posts/2013/11/26/os-ch8-memory-management/</link><description>&lt;h2&gt;NCTUCS 2013-Fall Introduction to Operating System by Hank Wu&lt;/h2&gt;
&lt;h2&gt;Ch8 - Memory Management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;To provide a detailed description of various ways of organizing memory hardware  &lt;/li&gt;
&lt;li&gt;To discuss various memory-management techniques, including paging and segmentation  &lt;/li&gt;
&lt;li&gt;To provide a detailed description of the Intel Pentium, which supports both pure segmentation and segmentation with paging  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Program must be brought (from disk) into memory and placed within a process for it to be run  &lt;/li&gt;
&lt;li&gt;Main memory and registers are only storage CPU can access directly  &lt;/li&gt;
&lt;li&gt;Register access in one CPU clock (or less)  &lt;/li&gt;
&lt;li&gt;Main memory can take many cycles  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cache&lt;/strong&gt; sits between main memory and CPU registers  &lt;/li&gt;
&lt;li&gt;Protection of memory required to ensure correct operation  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Base and Limit Registers&lt;/h3&gt;
&lt;p&gt;A pair of &lt;strong&gt;base&lt;/strong&gt; and &lt;strong&gt;limit&lt;/strong&gt; registers define the logical address space&lt;br /&gt;
&lt;img alt="Screenshot 1" src="/files/os-ch8-memory-management/screenshot1.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;￼Binding of Instructions and Data to Memory&lt;/h3&gt;
&lt;p&gt;Address binding of instructions and data to memory addresses can happen at three different stages&lt;br /&gt;
+ Compile time&lt;br /&gt;
    + If memory location known a priori, absolute code can be generated&lt;br /&gt;
    + must recompile code if starting location changes&lt;br /&gt;
+ Load time&lt;br /&gt;
    + Must generate relocatable code if memory location is not known at compile time&lt;br /&gt;
+ Execution time&lt;br /&gt;
    + Binding delayed until run time if the process can be moved during its execution from one memory segment to another.&lt;br /&gt;
    + Need hardware support for address maps (e.g., base and limit registers)  &lt;/p&gt;
&lt;h3&gt;Multistep Processing of a User Program&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Screenshot 2" src="/files/os-ch8-memory-management/screenshot2.jpg" /&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在這中間的每個步驟都可以作 Address binding&lt;br /&gt;
windows 底下的 .dll 檔, IE Explorer 的 ActiveX 都是動態連結的例子  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;￼Logical vs. Physical Address Space&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Logical address – generated by the CPU; also referred to as virtual address  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Physical address – address seen by the memory unit  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The concept of a logical address space that is bound to a separate physical address space is central to proper memory management  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Logical and physical addresses are the same in &lt;strong&gt;compile-time&lt;/strong&gt; and &lt;strong&gt;load-time&lt;/strong&gt; address-binding schemes  &lt;/li&gt;
&lt;li&gt;Logical (virtual) and physical addresses differ in &lt;strong&gt;execution-time&lt;/strong&gt; address-binding scheme  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Memory-Management Unit (MMU)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hardware device that maps virtual to physical address  &lt;/li&gt;
&lt;li&gt;In MMU scheme, the value in the relocation register is added to every address generated by a user process at the time it is sent to memory  &lt;/li&gt;
&lt;li&gt;The user program deals with logical addresses; it never sees the real physical addresses  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;￼Dynamic relocation using a relocation register&lt;/h4&gt;
&lt;h2&gt;&lt;img alt="Screenshot 3" src="/files/os-ch8-memory-management/screenshot3.jpg" /&gt;&lt;/h2&gt;
&lt;h2&gt;Swapping&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2&gt;Contiguous Memory Allocation&lt;/h2&gt;
&lt;h3&gt;Fragmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;total memory space exists to satisfy a request, but it is not contiguous  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;allocated memory may be slightly larger than requested memory  &lt;/li&gt;
&lt;li&gt;this size difference is memory internal to a partition, but not being used  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reduce external fragmentation by &lt;strong&gt;compaction&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;Shuffle memory contents to place all free memory together in one large block  &lt;/li&gt;
&lt;li&gt;Compaction is possible only if relocation is dynamic, and is done at execution time  &lt;/li&gt;
&lt;li&gt;I/O problem  &lt;ul&gt;
&lt;li&gt;Latch job in memory while it is involved in I/O  &lt;/li&gt;
&lt;li&gt;Do I/O only into OS buffers  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Paging&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;目前最常見的是以 4k 為單位的 page&lt;br /&gt;
表格的內容是由 software 在維護的，硬體藉由查詢表格的內容得知記憶體的位置。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Logical address space of a process can be &lt;strong&gt;noncontiguous&lt;/strong&gt;; process is allocated physical memory whenever the latter is available  &lt;/li&gt;
&lt;li&gt;Divide physical memory into fixed-sized blocks called frames (size is power of 2, between 512 bytes and 8,192 bytes)  &lt;/li&gt;
&lt;li&gt;Divide logical memory into blocks of same size called pages  &lt;/li&gt;
&lt;li&gt;Keep track of all free frames  &lt;/li&gt;
&lt;li&gt;To run a program of size n pages, need to find n free frames and load program  &lt;/li&gt;
&lt;li&gt;Set up a page table to translate logical to physical addresses  &lt;/li&gt;
&lt;li&gt;Internal fragmentation  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;￼Paging Model of Logical and Physical Memory&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Physical Memory 可以不用是連續的&lt;br /&gt;
可透過 page table 對應到連續的 Logical Memeory&lt;br /&gt;
達到彈性化的 Memory Management  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Free Frames&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Page Table 是由 OS 在 Maintain 的  &lt;/li&gt;
&lt;li&gt;Free Frame 也是由 OS 在 Maintain 的，要 Allocate 新的記憶體空間必須透過 Free Frame 尋找 Available 的記憶體空間  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Implementation of Page Table&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Page-table base register (PTBR) points to the page table&lt;br /&gt;
  Page-table length register (PRLR) indicates size of the page table  &lt;/p&gt;
&lt;p&gt;X86 內的 CR3 就是 X86 的 PTBR&lt;br /&gt;
  X86 的 Page Table 長度是固定的，所以不需要 PRLR  &lt;/p&gt;
&lt;p&gt;Q:剛才提到 Page Table 是由 OS 在 Maintain，但這裡卻說 X86 的 Page Table 長度是固定的。那 Page Table 到底是由 OS 還是 CPU 架構決定？&lt;br /&gt;
  A: OS 的設計還是必須被侷限在 CPU 的架構底下。  &lt;/p&gt;
&lt;p&gt;Page Table 把資料存在 Physical Memory 裡面。  &lt;/p&gt;
&lt;p&gt;從這樣的機制看來，每次的記憶體讀寫都要花兩倍的時間&lt;br /&gt;
1. Logical Memory 和 Page Table 之間&lt;br /&gt;
2. Page Table 和 Physical Memory 之間&lt;br /&gt;
這樣看來 Performance 會非常差&lt;br /&gt;
但實際上有 Cache 的存在，所以會解決這個問題  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a special fast-lookup hardware cache called associative memory or &lt;strong&gt;translation look-aside buffers (TLBs)&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Some TLBs store &lt;strong&gt;address-space identifiers (ASIDs)&lt;/strong&gt; in each TLB entry – &lt;strong&gt;uniquely identifies each process to provide address-space protection for that process&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Effective Access Time&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;EAT = 2 + \varepsilon + \alpha  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Memory Protection&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Valid-invalid bit&lt;/strong&gt; attached to each entry in the page table&lt;br /&gt;
+ Valid&lt;br /&gt;
    + in the process’ logical address space&lt;br /&gt;
    + legal page&lt;br /&gt;
+ Invalid&lt;br /&gt;
    + not in the process’ logical address space&lt;br /&gt;
    + illegal page  &lt;/p&gt;
&lt;h3&gt;Shared Pages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Shared code  &lt;/li&gt;
&lt;li&gt;Private code and data  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Structure of the Page Table&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Hierarchical Paging  &lt;/li&gt;
&lt;li&gt;Hashed Page Tables  &lt;/li&gt;
&lt;li&gt;Inverted Page Tables  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Hierarchical Page Tables&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Break up the logical address space into multiple page tables  &lt;/li&gt;
&lt;li&gt;A simple technique is a two-level page table  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Two-Level Page-Table Scheme&lt;/h4&gt;
&lt;p&gt;見 p.39 的圖&lt;br /&gt;
&lt;img alt="Screenshot 4" src="/files/os-ch8-memory-management/screenshot4.jpg" /&gt;  &lt;/p&gt;
&lt;h4&gt;Address-Translation Scheme&lt;/h4&gt;
&lt;p&gt;見 p.41 的圖&lt;br /&gt;
&lt;img alt="Screenshot 5" src="/files/os-ch8-memory-management/screenshot5.jpg" /&gt;  &lt;/p&gt;
&lt;h4&gt;Three-level Paging Scheme&lt;/h4&gt;
&lt;p&gt;見 p.42 的圖&lt;br /&gt;
&lt;img alt="Screenshot 6" src="/files/os-ch8-memory-management/screenshot6.jpg" /&gt;&lt;br /&gt;
outer page, inner page, offset  &lt;/p&gt;
&lt;h3&gt;Hashed Page Table&lt;/h3&gt;
&lt;p&gt;見 p.44 的圖&lt;br /&gt;
&lt;img alt="Screenshot 7" src="/files/os-ch8-memory-management/screenshot7.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 Collision 的問題得解決:利用資料結構學到的方法解決  &lt;/li&gt;
&lt;li&gt;時間複雜度不見得會是 O(1), depend on chain 的長度  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Inverted Page Table&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;優點  &lt;ul&gt;
&lt;li&gt;針對 External Fragmentation 做解決（也是為什麼要有 Page Table 的主要原因）  &lt;/li&gt;
&lt;li&gt;以 Memory Frame 為本位設計  &lt;/li&gt;
&lt;li&gt;每個 Frame 都有一個對應的 Page Table  &lt;/li&gt;
&lt;li&gt;不需要實作 Hash Function  &lt;/li&gt;
&lt;li&gt;直接到一維陣列裡面做線性的搜尋，比較簡單  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺點  &lt;ul&gt;
&lt;li&gt;搜尋很花時間  &lt;/li&gt;
&lt;li&gt;不能作多對一的 Mapping  &lt;/li&gt;
&lt;li&gt;無法實作 Shared Memory Page  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Segmentation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;透過前面的 Paging 可以得到一個很大的記憶體空間&lt;br /&gt;
Segmentation 就是在規劃這些 Address Space 分成不同的 Segment&lt;br /&gt;
每個 Segment 負責不同性質的工作&lt;br /&gt;
以提升記憶體管理的效率。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;程式碼區段是唯讀的，可以確保不會被更改，以及比較不容易被惡意攻擊者利用  &lt;/li&gt;
&lt;li&gt;讓 Stack 有專屬的暫存器  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Logical View of Segmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;和 Page Table 類似，但還是有不同處  &lt;ul&gt;
&lt;li&gt;相同處：Mapping 的方法相同  &lt;/li&gt;
&lt;li&gt;不同處：每個 Segment 的長度是可以變的  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 X86 上面，是先有 Segment 後才有 Page Table 的。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Segmentation Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Segment table: maps two-dimensional physical addresses  &lt;ul&gt;
&lt;li&gt;base: contains the starting physical address where the segments reside in memory  &lt;/li&gt;
&lt;li&gt;limit: specifies the length of the segment  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Segment-table base register (STBR): points to the segment table’s location in memory  &lt;/li&gt;
&lt;li&gt;Segment-table length register (STLR): indicates number of segments used by a program;  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;if Validation bit = zero, then this segment is illegal.&lt;br /&gt;
超過非法的 Segment 取用範圍 =&amp;gt; Segmentatioin Fault (segment number &amp;gt;= STLR)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Segmentation Hardware&lt;/h3&gt;
&lt;p&gt;見 p.52 的圖&lt;br /&gt;
&lt;img alt="Screenshot 8" src="/files/os-ch8-memory-management/screenshot8.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;Example of Segmentation&lt;/h3&gt;
&lt;p&gt;見 p.53 的圖&lt;br /&gt;
&lt;img alt="Screenshot 9" src="/files/os-ch8-memory-management/screenshot9.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Example: The Intel Pentium&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Supports both segmentation and segmentation with paging  &lt;/li&gt;
&lt;li&gt;CPU generates logical address  &lt;ul&gt;
&lt;li&gt;Given to segmentation unit  &lt;/li&gt;
&lt;li&gt;Linear address given to paging unit  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Pentium Paging Architecture&lt;/h3&gt;
&lt;p&gt;見 p.57 的圖&lt;br /&gt;
&lt;img alt="Screenshot 10" src="/files/os-ch8-memory-management/screenshot10.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;越接近 Outer Table，則尺度是越大的  &lt;/li&gt;
&lt;li&gt;4KB page =&amp;gt; 2 layer  &lt;/li&gt;
&lt;li&gt;4MB page =&amp;gt; 直接由 page directory 產生，不需要是 2 layer  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Linear Address in Linux&lt;/h3&gt;
&lt;p&gt;global directory, middle directory, page table, offset  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用到 kernel code 才能用的 segment 的話，也會出現 Segmentation Fault  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Three-level Paging in Linux&lt;/h3&gt;
&lt;p&gt;見 p.59 的圖&lt;br /&gt;
&lt;img alt="Screenshot 11" src="/files/os-ch8-memory-management/screenshot11.jpg" /&gt;  &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">m157q</dc:creator><pubDate>Tue, 26 Nov 2013 03:25:00 +0800</pubDate><guid isPermaLink="false">tag:blog.m157q.tw,2013-11-26:posts/2013/11/26/os-ch8-memory-management/</guid><category>Operating System</category><category>Memory Management</category></item><item><title>OS Ch7 - Deadlocks</title><link>https://blog.m157q.tw/posts/2013/11/19/os-ch7-deadlocks/</link><description>&lt;h1&gt;OS == Operating System&lt;/h1&gt;
&lt;h1&gt;Ch7 - Deadlocks&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Prevent sets of concurrent processes from completing their tasks.  &lt;/li&gt;
&lt;li&gt;To present a number of different methods for preventing or avoiding deadlocks in a computer system.  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;The Deadlock Problem&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A set of blocked processes each holding a resource and waiting to acquire a resource held by another process in the set.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Bridge Crossing Example&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Most OSes do not prevent or deal with deadlocks  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;System Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Resource types R1, R2, . . ., Rm&lt;br /&gt;
    CPU cycles, memory space, I/O devices  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each resource type Ri has Wi instances.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each process utilizes a resource as follows:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;request  &lt;/li&gt;
&lt;li&gt;use  &lt;/li&gt;
&lt;li&gt;release  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Deadlock Characterization&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Deadlock Characterization" src="/files/os-ch7-deadlocks/deadlock-characterization.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;Resource-Allocation Graph&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Resource-Allocation Graph 1" src="/files/os-ch7-deadlocks/resource-allocation-graph-1.jpg" /&gt;&lt;br /&gt;
&lt;img alt="Resource-Allocation Graph 2" src="/files/os-ch7-deadlocks/resource-allocation-graph-2.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resource Allocation Graph With A Deadlock&lt;br /&gt;
&lt;img alt="Resource Allocation Graph With A Deadlock" src="/files/os-ch7-deadlocks/resource-allocation-graph-with-a-deadlock.jpg" /&gt;  &lt;/li&gt;
&lt;li&gt;Resource Allocation Graph With A Cycle But No Deadlock&lt;br /&gt;
&lt;img alt="Resource Allocation Graph With A Cycle But No Deadlock" src="/files/os-ch7-deadlocks/resource-allocation-graph-with-a-cycle-but-no-deadlock.jpg" /&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Basic Facts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If graph contains no cycles =&amp;gt; no deadlock  &lt;/li&gt;
&lt;li&gt;If graph contains a cycle =&amp;gt;  &lt;ul&gt;
&lt;li&gt;if only one instance per resource type, then deadlock  &lt;/li&gt;
&lt;li&gt;if several instances per resource type, possibility of deadlock  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Methods for Handling Deadlocks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ensure that the system will never enter a deadlock state  &lt;/li&gt;
&lt;li&gt;Allow the system to enter a deadlock state and then recover  &lt;/li&gt;
&lt;li&gt;Ignore the problem and pretend that deadlocks never occur in the system; used by most operating systems, including UNIX  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Deadlock Prevention&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt; - not required for sharable resources; must hold for nonsharable resources  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt; - must guarantee that whenever a process requests a resource, it does not hold any other resources  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Require process to request and be allocated all its resources before it begins execution&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Allow process to request resources only when the process has none  &lt;/li&gt;
&lt;li&gt;Low resource utilization  &lt;/li&gt;
&lt;li&gt;Starvation possible  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;No Preemption&lt;/strong&gt; (preemption - 先發制人)  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某個 process 用完 resources 後，一定要該 process 自願釋出 resources ，不能強制奪取其 resources.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If a process that is holding some resources requests another resource that cannot be immediately allocated to it, then all resources currently being held are released&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Preempted resources are added to the list of resources for which the process is waiting  &lt;/li&gt;
&lt;li&gt;Process will be restarted only when it can regain its old resources, as well as the new ones that it is requesting  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Circular Wait&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;impose a total ordering of all resource types =&amp;gt; 可能非常非常的多  &lt;/li&gt;
&lt;li&gt;require that each process requests resources in an &lt;strong&gt;increasing order of enumeration&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Deadlock prevention by resource ordering&lt;/strong&gt; - Linux kernel 3.6.7 use this method.&lt;br /&gt;
&lt;img alt="double_rq_lock" src="/files/os-ch7-deadlocks/double-rq-lock.png" /&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;當你可能需要把某個 process 從一個 core 移到另一個 core (作 Load balance) 的時候，兩邊的 core 都要使用 lock 。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;All resources will be requested in order. =&amp;gt; &lt;strong&gt;total ordering&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;No two resources unrelated by order will ever be used by a single unit of work at the same time.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Deadlock Avoidance&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Simplest and most useful model requires that each process declare the maximum number of resources of each type that it may need  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The deadlock-avoidance algorithm dynamically examines the resource-allocation state to ensure that there can never be a circular-wait condition  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resource-allocation state is defined by the number of available and allocated resources, and the maximum demands of the processes  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Safe State&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;When a process requests an available resource, &lt;strong&gt;system must decide if immediate allocation leaves the system in a safe state&lt;/strong&gt;.  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\begin{align}  

&amp;amp; \text{ System is in safe state if there exists a sequence } \langle P_{1}, P_{2}, \cdots, P_{n} \rangle \\  
&amp;amp; \text{ of ALL the processes in the systems such that for each } P_{i} \\  
&amp;amp; \text{ , the resources that } P_{i} \text{ can still request can be satisfied } \\  
&amp;amp; \text{ by currently available resources + resources held by all the } P_{j}, \text{ with } j &amp;lt; i \\  

\end{align}  
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\begin{align}  
&amp;amp; \text { If } P_{i} \text{ resource needs are not immediately available, } \\  
&amp;amp; \text{ then } P_{i} \text{ can wait until all } P_{j} \text{ have finished. } \\  
&amp;amp; \text{     When } P_{j} \text{ is finished, } \\  
&amp;amp; P_{i} \text{ can obtain needed resources, execute, return allocated resources, and terminate. } \\  
&amp;amp; \text{     When } P_{i} \text{ terminates, } P_{i+1} \text{ can obtain its needed resources, and so on } \\  
\end{align}  
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Basic Facts&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;If a system is in safe state =&amp;gt; no deadlocks  &lt;/li&gt;
&lt;li&gt;If a system is in unsafe state =&amp;gt; possibility of deadlock  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Avoidance =&amp;gt; ensure that a system will never enter an unsafe state.&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Avoidance algorithms&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single&lt;/strong&gt; instance of a resource type =&amp;gt; Use a &lt;strong&gt;resource-allocation graph&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiple&lt;/strong&gt; instances of a resource type =&amp;gt; Use &lt;strong&gt;the banker’s algorithm&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Resource-Allocation Graph Scheme&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\begin {align}  
&amp;amp; \text{ Claim edge } P_{i} \rightarrow R_{j} \text{ indicated that process } P_{j} \text{ may request resource } R_{j} \text{ ; }\\  
&amp;amp; \text{ represented by a dashed line. }  
\end {align}  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Claim edge converts to request edge when a process requests a resource  &lt;/li&gt;
&lt;li&gt;Request edge converted to an assignment edge when the resource is allocated to the process  &lt;/li&gt;
&lt;li&gt;When a resource is released by a process, assignment edge reconverts to a claim edge  &lt;/li&gt;
&lt;li&gt;Resources must be claimed a &lt;strong&gt;priori&lt;/strong&gt; in the system  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Resource Allocation Graph&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Resouce Allocation Graph 3" src="/files/os-ch7-deadlocks/resource-allocation-graph-3.png" /&gt;  &lt;/p&gt;
&lt;h4&gt;Unsafe State Resource Allocation Graph&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Unsafe State Resource Allocation Graph" src="/files/os-ch7-deadlocks/unsafe-state-resource-allocation-graph.png" /&gt;  &lt;/p&gt;
&lt;h3&gt;Resource-Allocation Graph Algorithm&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The request can be granted only if converting the request edge to an assignment edge does not result in the formation of a cycle in the resource allocation graph  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Banker’s Algorithm&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;檢查之後有沒有可能進到 Unsafe State  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Multiple instances  &lt;/li&gt;
&lt;li&gt;Each process must a priori claim maximum use  &lt;/li&gt;
&lt;li&gt;When a process requests a resource it may have to wait  &lt;/li&gt;
&lt;li&gt;When a process gets all its resources it must return them in a finite amount of time  &lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Data Structures for the Banker’s Algorithm&lt;/h5&gt;
&lt;p&gt;&lt;img alt="Data Structures for the Banker’s Algorithm" src="/files/os-ch7-deadlocks/bankers-algorithm.png" /&gt;  &lt;/p&gt;
&lt;h4&gt;Safety Algorithm&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Safety Algorithm" src="/files/os-ch7-deadlocks/safety-algorithm.png" /&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;process 有可能還需要 resource, 可以由 work 提供  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;￼Resource-Request Algorithm for Process Pi&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Request = request vector for process P[i]  &lt;/span&gt;
&lt;span class="c1"&gt;# If Request[i][j] = k then,  &lt;/span&gt;
&lt;span class="c1"&gt;# process P[i] wants k instances of resource type R[j]  &lt;/span&gt;

&lt;span class="c1"&gt;# 1.  &lt;/span&gt;
&lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;Need&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;step2&lt;/span&gt;  
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;  
&lt;span class="c1"&gt;# since process has exceeded its maximum claim  &lt;/span&gt;

&lt;span class="c1"&gt;# 2.  &lt;/span&gt;
&lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;Available&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;step3&lt;/span&gt;  
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;wait&lt;/span&gt;  
&lt;span class="c1"&gt;# since resources are not available  &lt;/span&gt;

&lt;span class="c1"&gt;# 3.  &lt;/span&gt;
&lt;span class="c1"&gt;# Pretend to allocate requested resources to Pi  &lt;/span&gt;
&lt;span class="c1"&gt;# by modifying the state as follows:  &lt;/span&gt;

&lt;span class="n"&gt;Available&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Available&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;Allocation&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Allocation&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;Need&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Need&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;If safe =&amp;gt; the resources are allocated to Pi  &lt;/li&gt;
&lt;li&gt;If unsafe =&amp;gt; Pi must wait, and the old resource-allocation state is restored  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Available == 當下系統可用的 Resource 的量&lt;br /&gt;
Resource-Request Algorithm 很少在用，主要的原因是因為 Avaliable 不好估算，如果 Avaliable 無法得知的話，這個 Algorithm 基本上沒什麼用，這邊只是表達一下觀念。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Deadlock Detection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Allow system to enter deadlock state  &lt;/li&gt;
&lt;li&gt;Detection algorithm  &lt;/li&gt;
&lt;li&gt;Recovery scheme  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Single Instance of Each Resource Type&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Single Instance of Each Resource Type" src="/files/os-ch7-deadlocks/single-instance-of-each-resource-type.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;Resource-Allocation Graph and Wait-for Graph&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Resource-Allocation Graph and Wait-for Graph" src="/files/os-ch7-deadlocks/resource-allocation-graph-and-wait-for-graph.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;Several Instances of a Resource Type&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Several Instances of a Resource Type" src="/files/os-ch7-deadlocks/several-instances-of-a-resource-type.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;Detection Algorithm&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Detection Algorithm 1" src="/files/os-ch7-deadlocks/detection-algorithm-1.jpg" /&gt;&lt;br /&gt;
&lt;img alt="Detection Algorithm 2" src="/files/os-ch7-deadlocks/detection-algorithm-2.jpg" /&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Algorithm requires an order of O(m * n^2) operations to detect whether the system is in deadlocked state  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Example of Detection Algorithm&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Example of Detection Algorithm 1" src="/files/os-ch7-deadlocks/example-of-detection-algorithm-1.jpg" /&gt;&lt;br /&gt;
&lt;img alt="Example of Detection Algorithm 2" src="/files/os-ch7-deadlocks/example-of-detection-algorithm-2.jpg" /&gt;  &lt;/p&gt;
&lt;h4&gt;Detection-Algorithm Usage&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;When, and how often, to invoke depends on:  &lt;ul&gt;
&lt;li&gt;How often a deadlock is likely to occur?  &lt;/li&gt;
&lt;li&gt;How many processes will need to be rolled back?  &lt;ul&gt;
&lt;li&gt;one for each disjoint cycle  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If detection algorithm is invoked arbitrarily, there may be many cycles in the resource graph and so we would not be able to tell which of the many deadlocked processes “caused” the deadlock  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Recovery from Deadlock&lt;/h2&gt;
&lt;h3&gt;Process Termination&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Abort all deadlocked processes  &lt;/li&gt;
&lt;li&gt;Abort one process at a time until the deadlock cycle is eliminated  &lt;/li&gt;
&lt;li&gt;In which order should we choose to abort?  &lt;ul&gt;
&lt;li&gt;Priority of the process  &lt;/li&gt;
&lt;li&gt;How long process has computed, and how much longer to completion  &lt;/li&gt;
&lt;li&gt;Resources the process has used  &lt;/li&gt;
&lt;li&gt;Resources process needs to complete  &lt;/li&gt;
&lt;li&gt;How many processes will need to be terminated  &lt;/li&gt;
&lt;li&gt;Is process interactive or batch?  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Resource Preemption&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Selecting a victim =&amp;gt; minimize cost  &lt;/li&gt;
&lt;li&gt;Rollback =&amp;gt; return to some safe state, restart process for that state  &lt;/li&gt;
&lt;li&gt;Starvation =&amp;gt; same process may always be picked as victim, include number of rollback in cost factor  &lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">m157q</dc:creator><pubDate>Tue, 19 Nov 2013 02:40:00 +0800</pubDate><guid isPermaLink="false">tag:blog.m157q.tw,2013-11-19:posts/2013/11/19/os-ch7-deadlocks/</guid><category>Operating System</category><category>Deadlock</category></item><item><title>OS Ch6 - Synchronization</title><link>https://blog.m157q.tw/posts/2013/11/05/os-ch6-synchronization/</link><description>&lt;h1&gt;Monitors&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Invented by &lt;strong&gt;Tony Hoare&lt;/strong&gt; in 1974  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Like a C++ class  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consists of vars and procedures  &lt;ol&gt;
&lt;li&gt;Only one thread in a monitor at a time (automatic mutual exclusion)  &lt;/li&gt;
&lt;li&gt;Specifal type of variable, called &lt;strong&gt;condition variable&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;wait  &lt;/li&gt;
&lt;li&gt;signal  &lt;/li&gt;
&lt;li&gt;broadcast  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No public variables allowed (must call procedures to access variables)  &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A high-level abstraction that provides a convenient and effective mechanism for process synchronization  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Only one process may be active within the monitor at a time  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Condition Variables  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Automatic unlock and lock for mutual exclusion  &lt;/li&gt;
&lt;li&gt;cond.wait () - Thread is put on queue for “cond”, goes to sleep.  &lt;/li&gt;
&lt;li&gt;cond.signal () - If queue for “cond” not empty, wake up on thread  &lt;/li&gt;
&lt;li&gt;cond.broadcast() - Wake up all threads waiting on queue for “cond”  &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Semantics of Signal  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Signal and Wait (Hoare-style)  &lt;ul&gt;
&lt;li&gt;Signaler passes lock, CPU to waiter; waiter runs immediately  &lt;/li&gt;
&lt;li&gt;Waiter gives lock, CPU back to signaler when  &lt;ol&gt;
&lt;li&gt;It exits critical section  &lt;/li&gt;
&lt;li&gt;Or, it waits again  &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Signal and Continue (Mesa-style)  &lt;ul&gt;
&lt;li&gt;invented by Xerox company  &lt;/li&gt;
&lt;li&gt;signaler continues executing  &lt;/li&gt;
&lt;li&gt;waiter put on ready queue  &lt;/li&gt;
&lt;li&gt;when waiter actually gets to run  &lt;ol&gt;
&lt;li&gt;May have to wait for lock again  &lt;/li&gt;
&lt;li&gt;State may have changed! Use “while”, not “if”  &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Used in Java, Pthread  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.mtu.edu/~shene/NSF-3/e-Book/MONITOR/monitor-types.html"&gt;Monitor types&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bounded Buffer by Monitor&lt;br /&gt;
    In Bounded Buffer,  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Enqueue&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MAX_SIZE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  

        &lt;span class="n"&gt;BUFFER&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;tail&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MAX_SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Deque&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MAX_SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MAX_SIZE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;BUFFER&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Hoare Style  &lt;ul&gt;
&lt;li&gt;Monitor Implementation (using semaphores)  &lt;ul&gt;
&lt;li&gt;Need mutual exclusion semaphore &lt;strong&gt;mutex (init to 1)&lt;/strong&gt; so that only one process is    active within monitor  &lt;/li&gt;
&lt;li&gt;Need a semaphore &lt;strong&gt;next (next to exit)&lt;/strong&gt; for the signaling process to suspend itself  &lt;ul&gt;
&lt;li&gt;initialized to zero  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;next_count&lt;/strong&gt; is number of processes blocked on &lt;strong&gt;next&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Before exiting a procedure, process must either:  &lt;ol&gt;
&lt;li&gt;Signal other waiting processes in monitor next before exiting  &lt;/li&gt;
&lt;li&gt;Signal mutex and exit  &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Monitor Implementation  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nv"&gt;Procedure&lt;/span&gt; &lt;span class="nv"&gt;F:&lt;/span&gt;  
                &lt;span class="nv"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;  &lt;/span&gt;
                &lt;span class="o"&gt;...&lt;/span&gt;  
                &lt;span class="nv"&gt;body&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;F&lt;/span&gt;  
                &lt;span class="o"&gt;...&lt;/span&gt;  
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;next_count&lt;/span&gt; &lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;  &lt;/span&gt;
                &lt;span class="nv"&gt;else&lt;/span&gt; &lt;span class="nb"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;  &lt;/span&gt;
    &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="c1"&gt;;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;+ Condition Variable Implementation
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">m157q</dc:creator><pubDate>Tue, 05 Nov 2013 03:07:00 +0800</pubDate><guid isPermaLink="false">tag:blog.m157q.tw,2013-11-05:posts/2013/11/05/os-ch6-synchronization/</guid><category>Operating System</category></item><item><title>OS Ch1 - Introduction to Operating System</title><link>https://blog.m157q.tw/posts/2013/11/04/os-ch1-introduction-to-operating-system/</link><description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;What is an Operating System?  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A program that acts as an intermediary between an application and the computer hardware  &lt;/li&gt;
&lt;li&gt;A program that provides a convenient interface to the user  &lt;/li&gt;
&lt;li&gt;Controls and coordinates use of hardware among various applications and users  &lt;/li&gt;
&lt;li&gt;Provides a multi-user environment  &lt;ul&gt;
&lt;li&gt;time-sharing  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Distributed computing  &lt;/li&gt;
&lt;li&gt;Cloud computing  &lt;/li&gt;
&lt;li&gt;a piece of program (or pieces of programs)  &lt;/li&gt;
&lt;li&gt;a resource allocator  &lt;/li&gt;
&lt;li&gt;a control program  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Computer system can be divided into four components  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware  &lt;/li&gt;
&lt;li&gt;Operating system  &lt;/li&gt;
&lt;li&gt;Application programs  &lt;/li&gt;
&lt;li&gt;Users  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;“The one program running at all times on the computer” is the kernel."&lt;br /&gt;
"Everything else is either a system program (ships with the operating system) or an application program."  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Computer-System operation  &lt;ul&gt;
&lt;li&gt;One or more CPUs, device controllers connect through common bus providing access to&lt;br /&gt;
  shared memory  &lt;/li&gt;
&lt;li&gt;Concurrent execution of CPUs and devices competing for memory cycles  &lt;/li&gt;
&lt;li&gt;I/O devices and the CPU can execute concurrently  &lt;/li&gt;
&lt;li&gt;Each device controller is in charge of a particular device type  &lt;/li&gt;
&lt;li&gt;Each device controller has a local buffer  &lt;/li&gt;
&lt;li&gt;CPU moves data from/to main memory to/from local buffers  &lt;/li&gt;
&lt;li&gt;I/O is from the device to local buffer of controller  &lt;/li&gt;
&lt;li&gt;Device controller informs CPU that it has finished its operation by causing an interrupt  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;￼Common Functions of Interrupts  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interrupt transfers control to the interrupt service routine generally, through the &lt;strong&gt;interrupt vector, which contains the addresses of all the service routines&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Interrupt architecture must save the address of the interrupted instruction  &lt;/li&gt;
&lt;li&gt;Incoming interrupts are disabled while another interrupt is being processed to prevent       a lost interrupt  &lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;trap is a software-generated interrupt caused either by an error or a user request&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;An operating system is &lt;strong&gt;interrupt driven&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Interrupts&lt;br /&gt;
&lt;img alt="Interrupt Vectors in Liunx" src="/files/os-ch1/interrupt-vectors-in-linux.png" /&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O structure  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;After I/O starts, control returns to user program only upon I/O completion  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wait instruction idles the CPU until the next interrupt  &lt;/li&gt;
&lt;li&gt;At most one I/O request is outstanding at a time, no simultaneous I/O processing  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;I/O muliplexing&lt;/strong&gt; After I/O starts, control returns to user program without waiting f              or I/O completion  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;System call&lt;/strong&gt; – request to the operating system to allow user to wait for I/O&lt;br /&gt;
    completion  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Device-status table&lt;/strong&gt; contains entry for each I/O device indicating its type,&lt;br /&gt;
    address, and state  &lt;/li&gt;
&lt;li&gt;Operating system indexes into I/O device table to determine device status and to&lt;br /&gt;
    modify table entry to include interrupt  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Direct Memory Access Structure (DMA)  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Device controller transfers blocks of data from buffer storage directly to main&lt;br /&gt;
  memory without CPU intervention  &lt;/li&gt;
&lt;li&gt;Only one interrupt is generated per block, rather than the one interrupt per byte  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Storage Structure  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Main memory  &lt;/li&gt;
&lt;li&gt;Secondary storage - extension of main memory that provides nonvolatile&lt;br /&gt;
     capacity  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Magnetic disks  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disk surface is logically divided into tracks, which are subdivided into sectors  &lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;disk controller&lt;/strong&gt; determines the logical interaction between the device&lt;br /&gt;
     and the computer  &lt;/li&gt;
&lt;li&gt;NCQ vs no NCQ  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Storage Hierarchy  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Speed  &lt;/li&gt;
&lt;li&gt;Cost  &lt;/li&gt;
&lt;li&gt;Volatility  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Caching  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;copying information into faster storage system; main memory&lt;br /&gt;
  can be viewed as a last cache for secondary storage  &lt;/li&gt;
&lt;li&gt;Information in use copied from slower to faster storage temporarily  &lt;/li&gt;
&lt;li&gt;Faster storage (cache) checked first to determine if information is there  &lt;/li&gt;
&lt;li&gt;Cache smaller than storage being cached  &lt;ul&gt;
&lt;li&gt;Cache management important design problem  &lt;/li&gt;
&lt;li&gt;Cache size and replacement policy  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Computer-System Architecture  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;single general-purpose processor (PDAs through mainframes)  &lt;/li&gt;
&lt;li&gt;special-purpose processors  &lt;/li&gt;
&lt;li&gt;Multiprocessors systems == parallel systems == tightly-coupled systems  &lt;ul&gt;
&lt;li&gt;Increased throughput  &lt;/li&gt;
&lt;li&gt;Economy of scale  &lt;/li&gt;
&lt;li&gt;Increased reliability – graceful degradation or fault tolerance  &lt;/li&gt;
&lt;li&gt;Two types  &lt;ul&gt;
&lt;li&gt;Asymmetric Multiprocessing  &lt;/li&gt;
&lt;li&gt;Symmetric Multiprocessing  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clustered Systems  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multiple systems working together  &lt;/li&gt;
&lt;li&gt;Usually sharing storage via a storage-area network (SAN)  &lt;/li&gt;
&lt;li&gt;Provides a high-availability service which survives failures  &lt;ul&gt;
&lt;li&gt;Asymmetric clustering has one machine in hot-standby mode  &lt;/li&gt;
&lt;li&gt;Symmetric clustering has multiple nodes running applications, monitoring&lt;br /&gt;
  each other  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Some clusters are for high-performance computing (HPC). Applications must be written to        use parallelization  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Computer Startup  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bootstrap program is loaded at power-up or reboot  &lt;ul&gt;
&lt;li&gt;Typically stored in ROM or EPROM, generally known as firmware  &lt;/li&gt;
&lt;li&gt;Initializes all aspects of system  &lt;/li&gt;
&lt;li&gt;Loads operating system kernel and starts execution  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Operating system probes and initializes hardware  &lt;/li&gt;
&lt;li&gt;Hardware provides the driving power  &lt;/li&gt;
&lt;li&gt;Operating system administers the power to system services and applications (jobs)  &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Operating System Structure  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiprogramming  &lt;ul&gt;
&lt;li&gt;Needed for efficiency  &lt;/li&gt;
&lt;li&gt;Single user cannot keep CPU and I/O devices busy at all times  &lt;/li&gt;
&lt;li&gt;Organizes jobs (code and data) so CPU always has one to execute  &lt;/li&gt;
&lt;li&gt;A subset of total jobs in system is kept in memory  &lt;/li&gt;
&lt;li&gt;One job selected and run via &lt;strong&gt;job scheduling&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;When it has to wait (for I/O for example), OS &lt;strong&gt;switches to another job&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Timesharing (multitasking)  &lt;ul&gt;
&lt;li&gt;logical extension in which CPU switches jobs so frequently that users can interact&lt;br /&gt;
    with each job while it is running, creating &lt;strong&gt;interactive&lt;/strong&gt; computing  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response time&lt;/strong&gt; should be &amp;lt; 1 second  &lt;/li&gt;
&lt;li&gt;Each user has at least one &lt;strong&gt;program executing in memory =&amp;gt; process&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;If several jobs ready to run at the same time =&amp;gt; &lt;strong&gt;CPU scheduling&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;If processes don’t fit in memory, &lt;strong&gt;swapping&lt;/strong&gt; moves them in and out to run  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual memory&lt;/strong&gt; allows execution of processes not completely in memory  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Operating-System Operations  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Interrupt&lt;/strong&gt; driven by hardware  &lt;/li&gt;
&lt;li&gt;Software error or request creates &lt;strong&gt;exception&lt;/strong&gt; or &lt;strong&gt;trap&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;Division by zero, request for operating system service  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dual-mode&lt;/strong&gt; operation allows OS to protect itself and other system components  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;User mode&lt;/strong&gt; and &lt;strong&gt;kernel mode&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mode bit&lt;/strong&gt; provided by hardware  &lt;ul&gt;
&lt;li&gt;Provides ability to distinguish when system is running user code or kernel code  &lt;/li&gt;
&lt;li&gt;Some instructions designated as &lt;strong&gt;privileged&lt;/strong&gt;, only executable in kernel mode  &lt;/li&gt;
&lt;li&gt;System call changes mode to kernel, return from call resets it to user  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transition from User to Kernel Mode  &lt;ul&gt;
&lt;li&gt;Timer to prevent infinite loop / process hogging resources  &lt;ul&gt;
&lt;li&gt;Set interrupt after specific period  &lt;/li&gt;
&lt;li&gt;Operating system decrements counter  &lt;/li&gt;
&lt;li&gt;When counter zero generate an interrupt  &lt;/li&gt;
&lt;li&gt;Set up before scheduling process to regain control or terminate program&lt;br /&gt;
  that exceeds allotted time  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process Management  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single-threaded process has one &lt;strong&gt;program counter&lt;/strong&gt; specifying location of&lt;br /&gt;
  next instruction to execute  &lt;ul&gt;
&lt;li&gt;Process executes instructions sequentially, one at a time, until completion  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multi-threaded process has one program counter per thread&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Concurrency by multiplexing the CPUs among the processes / threads  &lt;/li&gt;
&lt;li&gt;Process termination requires reclaim of any reusable resources  &lt;/li&gt;
&lt;li&gt;Activities  &lt;ul&gt;
&lt;li&gt;Creating and deleting both user and system processes  &lt;/li&gt;
&lt;li&gt;Suspending and resuming processes  &lt;/li&gt;
&lt;li&gt;Process synchronization  &lt;/li&gt;
&lt;li&gt;Process communication  &lt;/li&gt;
&lt;li&gt;Deadlock handling  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory Management  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Determines what is in memory when optimizing CPU utilization and computer response to&lt;br /&gt;
    users  &lt;/li&gt;
&lt;li&gt;Activities  &lt;ul&gt;
&lt;li&gt;Keeping track of which parts of memory are currently being used and by whom  &lt;/li&gt;
&lt;li&gt;Deciding which processes (or parts thereof) and data to move into and out of memory  &lt;/li&gt;
&lt;li&gt;Allocating and deallocating memory space as needed  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Storage Management  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS provides uniform, logical view of information storage  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;file&lt;/strong&gt; - Abstracts physical properties to logical storage unit  &lt;/li&gt;
&lt;li&gt;Each medium is controlled by device  &lt;ul&gt;
&lt;li&gt;access speed  &lt;/li&gt;
&lt;li&gt;capacity  &lt;/li&gt;
&lt;li&gt;data-transfer rate  &lt;/li&gt;
&lt;li&gt;access method (sequential or random)  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;File-System management  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Access control on most systems to determine who can access what  &lt;/li&gt;
&lt;li&gt;OS Activities  &lt;ul&gt;
&lt;li&gt;Creating and deleting files and directories  &lt;/li&gt;
&lt;li&gt;Primitives to manipulate files and dirs  &lt;/li&gt;
&lt;li&gt;Mapping files onto secondary storage  &lt;/li&gt;
&lt;li&gt;Backup files onto stable (non-volatile) storage media  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mass-Storage Management  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disks used to store data that does not fit in main memory or data that must be kept for&lt;br /&gt;
    a “long” period of time  &lt;/li&gt;
&lt;li&gt;WORM (write-once, read-many-times) and RW (read-write)  &lt;/li&gt;
&lt;li&gt;OS activities  &lt;ul&gt;
&lt;li&gt;Free-space management  &lt;/li&gt;
&lt;li&gt;Storage allocation  &lt;/li&gt;
&lt;li&gt;Disk scheduling  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Performance of Various Levels of Storage&lt;br /&gt;
&lt;img alt="Performance of Various Levels of Storage" src="/files/os-ch1/performance-of-various-levels-of-storage.png" /&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Multitasking environments must be careful to use most recent value, no matter where it is stored in the storage hierarchy  &lt;/p&gt;
&lt;p&gt;Multiprocessor environment must provide cache coherency in hardware such that all CPUs have the most recent value in their cache  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O Subsystem  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory management of I/O  &lt;ul&gt;
&lt;li&gt;buffering (storing data temporarily while it is being transferred)  &lt;/li&gt;
&lt;li&gt;caching (storing parts of data in faster storage for performance)  &lt;/li&gt;
&lt;li&gt;spooling (the overlapping of output of one job with input of other jobs)  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;General device-driver interface  &lt;/li&gt;
&lt;li&gt;Drivers for specific hardware devices  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Protection and Security  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Protection&lt;/strong&gt; – any mechanism for controlling access of processes or users to resources defined by the OS  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt; – defense of the system against internal and external attacks  &lt;ul&gt;
&lt;li&gt;denial-of-service, worms, viruses, identity theft, theft of service  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Some properties to check  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;uid, sid&lt;/strong&gt; - User identities (user IDs, security IDs), User ID then associated with all files, processes of that user to determine access control  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gid&lt;/strong&gt; - Group identifier (group ID) allows set of users to be defined and controls managed, then also associated with each process, file  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;euid, egid&lt;/strong&gt; - &lt;strong&gt;Privilege escalation&lt;/strong&gt; allows user to change to effective ID with more rights  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Computing Environments  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compute-server&lt;/strong&gt; provides an interface to client to request services (i.e. database)  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File-server&lt;/strong&gt; provides interface for clients to store and retrieve files  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Peer-to-Peer Computing  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Another model of distributed system  &lt;/li&gt;
&lt;li&gt;P2P does not distinguish clients and servers  &lt;/li&gt;
&lt;li&gt;Node must join P2P network  &lt;/li&gt;
&lt;li&gt;Broadcast request for service and respond to requests for service via discovery protocol  &lt;/li&gt;
&lt;li&gt;Examples include Napster and Gnutella  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web-Based Computing  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cloud Computing  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open-Source Operating Systems  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operating systems made available in source-code format rather than just binary closed-source  &lt;/li&gt;
&lt;li&gt;Counter to the copy protection and Digital Rights Management (DRM) movement  &lt;/li&gt;
&lt;li&gt;Started by Free Software Foundation (FSF), which has “copyleft” GNU Public License (GPL)  &lt;/li&gt;
&lt;li&gt;Examples include &lt;strong&gt;GNU/Linux&lt;/strong&gt;, &lt;strong&gt;BSD UNIX&lt;/strong&gt; (including &lt;strong&gt;core of Mac OS X&lt;/strong&gt;), and &lt;strong&gt;Sun Solaris&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">m157q</dc:creator><pubDate>Mon, 26 Oct 2015 15:30:00 +0800</pubDate><guid isPermaLink="false">tag:blog.m157q.tw,2013-11-04:posts/2013/11/04/os-ch1-introduction-to-operating-system/</guid><category>Operating System</category></item></channel></rss>