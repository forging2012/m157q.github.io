<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Just for noting</title><link href="https://blog.m157q.tw/" rel="alternate"></link><link href="https://blog.m157q.tw/feeds/tag.course.atom.xml" rel="self"></link><id>https://blog.m157q.tw/</id><updated>2017-10-05T20:56:39+08:00</updated><entry><title>Compiler Design Week 7</title><link href="https://blog.m157q.tw/posts/2015/04/07/compiler-design-week-7/" rel="alternate"></link><published>2015-04-07T15:40:11+08:00</published><updated>2015-04-07T15:40:11+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-04-07:posts/2015/04/07/compiler-design-week-7/</id><summary type="html">&lt;h3&gt;LL(1) - Top-Down parsing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;No ambiguous or left recursive grammar can be LL(1).&lt;ul&gt;
&lt;li&gt;ambiguous grammar 要先轉成 unambiguous grammar 才有辦法轉 LL(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Recursive decent parsing (Top-Down)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Left-most derivation for an input string&lt;ul&gt;
&lt;li&gt;LL&lt;/li&gt;
&lt;li&gt;LR&lt;ul&gt;
&lt;li&gt;現成的工具比較多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1&gt;Grammar substitution to revise non-LL(1) into LL(1) grammar&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Useless and un-reachable grammar handlings&lt;/li&gt;
&lt;li&gt;Eliminating Ambiguity&lt;/li&gt;
&lt;li&gt;Eliminating left-recursion&lt;/li&gt;
&lt;li&gt;Corner substitution&lt;/li&gt;
&lt;li&gt;Singleton substitution&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Useless and un-reachable grammar handlings&lt;/h2&gt;
&lt;h3&gt;Un-reachable&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;從 grammar rule 就可得知某個 id 不會被用到，也就是不會被用到&lt;/li&gt;
&lt;li&gt;Method&lt;ul&gt;
&lt;li&gt;Step 1: Start from root&lt;/li&gt;
&lt;li&gt;Step 2: Add reachable Rules&lt;/li&gt;
&lt;li&gt;Step 3: Until no more&lt;blockquote&gt;
&lt;p&gt;師：有點類似 java 裡面的 garbage collection。(mark-N-sweep)&lt;br /&gt;
謎：java 有 GC ?!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Useless&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;S -&amp;gt; a | b B
B -&amp;gt; b B
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;會被使用到，但是不會出現新東西，不會出現 leaf node，會一直 recursive 下去。&lt;blockquote&gt;
&lt;p&gt;師：看起來好像很有用，但其實是 useless  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Applying sequence&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Remove Un-reachable =&amp;gt; Remove useless =&amp;gt; Remove un-reachable =&amp;gt; OK&lt;/li&gt;
&lt;li&gt;Remove Useless =&amp;gt; Remove un-reachable =&amp;gt; OK&lt;blockquote&gt;
&lt;p&gt;師：如果忘記順序，不管順序，多做幾次，做到不會再變了，就是最佳化了。&lt;br /&gt;
問：why?  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Eliminating Ambiguity: Ambiguous Grammar&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E -&amp;gt; E + E
  -&amp;gt; E * E
  -&amp;gt; ID
  -&amp;gt; number
  -&amp;gt; (E)
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;師： 考試時看到 ambiguous grammar 就絕對不是 LL(1)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Un-Ambiguos Grammar&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E -&amp;gt; E + term
  -&amp;gt; term
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Left Associativity&lt;/h3&gt;
&lt;hr /&gt;
&lt;h2&gt;Eliminating left-recursion&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;師：top-down parsing 不喜歡 left recursion，一定要去除掉。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Left-Recursion Conversion&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;師：會造成 infinite loop  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;S -&amp;gt; Sα|β
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;S  -&amp;gt; βS&amp;#39;
S&amp;#39; -&amp;gt; αS&amp;#39;|ε
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;師：兩個的 selection set 會一樣&lt;br /&gt;
//selection set??&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;More General Cases&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;S -&amp;gt; Sα_{1} | Sα_{2} | ... | Sα_{n} | β_{1} | β_{2} | ... | β_{n}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;S  -&amp;gt; β_{1}S&amp;#39; | β_{2}S&amp;#39; | ... | β_{n}S&amp;#39;
S&amp;#39; -&amp;gt; α_{1}S&amp;#39; | α_{2}S&amp;#39; | ... | α_{n}S&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Left-Recursion Conversion&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;list -&amp;gt; operand | list operator operand
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;list&amp;#39; -&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;//待補  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Left-Recursion Grammar to Right-Recursion Grammar&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E -&amp;gt; E + T | T
T -&amp;gt; T * F | F
F -&amp;gt; id | (E)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E  -&amp;gt; TE&amp;#39;
E&amp;#39; -&amp;gt; +TE&amp;#39; | ε
T  -&amp;gt; FT&amp;#39;
T&amp;#39; -&amp;gt; *FT&amp;#39; | ε
F  -&amp;gt; id | (E)
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Course"></category><category term="Compiler"></category></entry><entry><title>Compiler Design Week 5</title><link href="https://blog.m157q.tw/posts/2015/03/24/compiler-design-week-5/" rel="alternate"></link><published>2015-03-24T16:29:38+08:00</published><updated>2015-03-24T16:29:38+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-03-24:posts/2015/03/24/compiler-design-week-5/</id><summary type="html">&lt;h1&gt;2015/03/24&lt;/h1&gt;
&lt;h2&gt;NFA (with ε closure) 轉 DFA&lt;/h2&gt;
&lt;h2&gt;Minimizing the number of states of a DFA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;預設至少兩個 state (至少一個 Final State 和 至少一個 non Final State)&lt;ul&gt;
&lt;li&gt;除非證明行為真的不同，只好分更多個 state 出來。&lt;/li&gt;
&lt;li&gt;Final state 和 non Final state 一定是不同的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Equivalence Classes&lt;/h2&gt;
&lt;h2&gt;Relations and Partitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Partition&lt;ul&gt;
&lt;li&gt;A partition of a set is a collection of mutually disjoint subsets whose union is the original set.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If A is a set with a partition and R is the relation induced by the partition, then R is an equivalence relation.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Course"></category><category term="Compiler"></category></entry><entry><title>Compiler Design Week 4</title><link href="https://blog.m157q.tw/posts/2015/03/19/compiler-design-week-4/" rel="alternate"></link><published>2015-03-19T15:45:20+08:00</published><updated>2015-03-19T15:45:20+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-03-19:posts/2015/03/19/compiler-design-week-4/</id><summary type="html">&lt;h1&gt;2015/03/17&lt;/h1&gt;
&lt;p&gt;HW1 Released.&lt;br /&gt;
see &lt;a href="https://github.com/M157q/Compiler_NTHU_hw1"&gt;https://github.com/M157q/Compiler_NTHU_hw1&lt;/a&gt;&lt;br /&gt;
清大的作業真的比交大簡單很多&lt;br /&gt;
scanner 竟然只要滿足一個測資...  &lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;2015/03/19&lt;/h1&gt;
&lt;p&gt;繼續講 DFA, NFA  &lt;/p&gt;
&lt;h2&gt;NFA&lt;/h2&gt;
&lt;p&gt;ε =&amp;gt; empty string  &lt;/p&gt;
&lt;h2&gt;Regex 轉 NFA&lt;/h2&gt;
&lt;h2&gt;NFA (without empty string move) 轉 DFA&lt;/h2&gt;</summary><category term="Course"></category><category term="Compiler"></category></entry><entry><title>FOSSAPC 2015 Spring Week #2</title><link href="https://blog.m157q.tw/posts/2015/03/09/fossapc-2015-spring-week-2/" rel="alternate"></link><published>2015-03-09T23:40:43+08:00</published><updated>2015-03-09T23:40:43+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-03-09:posts/2015/03/09/fossapc-2015-spring-week-2/</id><summary type="html">&lt;p&gt;因為配合課程的需求&lt;br /&gt;
就直接看 Hackpad 吧  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://fossapc.hackpad.com/2015-FOSS-Week-2-Note#2015-FOSS-Week-2-Note"&gt;2015 FOSS Week #2 Note - fossapc.hackpad.com&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;之後應該就不另外再寫 markdown 記錄了&lt;br /&gt;
雖然還是不太喜歡直接用 hackpad&lt;br /&gt;
太多人的時候還是會噴 502&lt;br /&gt;
以及同時多人中文輸入還是會有打架的問題&lt;br /&gt;
也許可以考慮之後都用英文來記錄&lt;br /&gt;
好像也是個不錯的選擇  &lt;/p&gt;</summary><category term="Course"></category><category term="FOSS"></category></entry><entry><title>Compiler Design week 2</title><link href="https://blog.m157q.tw/posts/2015/03/03/compiler-design-week-2/" rel="alternate"></link><published>2015-03-05T15:38:00+08:00</published><updated>2015-03-05T15:38:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-03-03:posts/2015/03/03/compiler-design-week-2/</id><summary type="html">&lt;h2&gt;2015/03/03&lt;/h2&gt;
&lt;h3&gt;Evolution of Programming Languages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/List_of_programming_languages_by_type"&gt;List of programming languages by type - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Categorize by feature&lt;ul&gt;
&lt;li&gt;Imperative&lt;/li&gt;
&lt;li&gt;Delcarative&lt;/li&gt;
&lt;li&gt;Von Neumann&lt;/li&gt;
&lt;li&gt;Object-Oriented&lt;/li&gt;
&lt;li&gt;Functional&lt;/li&gt;
&lt;li&gt;Assignment-Oriented&lt;/li&gt;
&lt;li&gt;Scripting&lt;ul&gt;
&lt;li&gt;Python, JavaScript, AWK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Categorize by Generation&lt;ul&gt;
&lt;li&gt;1st Gen - Machine&lt;/li&gt;
&lt;li&gt;2nd Gen - Assembly&lt;/li&gt;
&lt;li&gt;3rd Gen - Structural Programming (C, Pascal)&lt;/li&gt;
&lt;li&gt;4th Gen - SQL&lt;/li&gt;
&lt;li&gt;5th Gen - Prolog (logic inference)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Memory Hierarchies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Memory Hierarchies&lt;ul&gt;
&lt;li&gt;Registers&lt;/li&gt;
&lt;li&gt;Scratch Memory&lt;/li&gt;
&lt;li&gt;Local Memory&lt;/li&gt;
&lt;li&gt;Cache&lt;/li&gt;
&lt;li&gt;Remote Memory&lt;/li&gt;
&lt;li&gt;Disk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;對商用 Compiler 來說，記憶體的架構很重要，會對 Performance 造成頗重大的影響。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Out-of-core_algorithm"&gt;Out-of-core Algorithm&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Designed to process data that is too large to fit into a computer's main memory at one time.&lt;/li&gt;
&lt;li&gt;Must be optimized to efficiently fetch and access data stored in slow bulk memory such as hard drives or tape drives.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Binary Translation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作位置較接近 Machine code, 而不是 Assembly code&lt;/li&gt;
&lt;li&gt;Input: Machine Code, Output: Another Machine Code or Assembly Code&lt;ul&gt;
&lt;li&gt;ARM Machine Code =&amp;gt; (Binary Translation) =&amp;gt; X86 / MIPS / Andes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Scope&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分類&lt;ul&gt;
&lt;li&gt;Static Binding (Lexical Binding)&lt;ul&gt;
&lt;li&gt;Scheme, C++, C, Java&lt;/li&gt;
&lt;li&gt;直接看 program 的 scope，以最接近的那個上層為主。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dynamic Binding&lt;ul&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;從 runtime 的順序反推回去找&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fluid Binding (Dynamic Assignments)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var := expr during stmt-body&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;當成可以指定特殊條件的 Static Binding&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指如何處理 free variable，對於 bound variable 沒有啥問題，無需處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Parameter Passing Schemes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;call by value / call by in&lt;/li&gt;
&lt;li&gt;call by result / call by out&lt;/li&gt;
&lt;li&gt;call by value result / call by in Out&lt;/li&gt;
&lt;li&gt;call by address (本質上為 call by value or call by value of pointer)&lt;/li&gt;
&lt;li&gt;call by reference&lt;ul&gt;
&lt;li&gt;沒有產生額外的 storage&lt;/li&gt;
&lt;li&gt;任何修改都會直接反應到 argument&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;call by reference 的變形。三者都使用 Late Binding&lt;ul&gt;
&lt;li&gt;call by name&lt;ul&gt;
&lt;li&gt;binding per use&lt;/li&gt;
&lt;li&gt;caller environment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;call by text&lt;ul&gt;
&lt;li&gt;binding per use&lt;/li&gt;
&lt;li&gt;callee environment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;call by need (lazy evaluation)&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Lazy_evaluation"&gt;Lazy evaluation - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;binding at first time use&lt;/li&gt;
&lt;li&gt;caller environment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Chapter 2&lt;/h2&gt;
&lt;h3&gt;Chomsky Hierarchy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Non-R.E.&lt;/li&gt;
&lt;li&gt;R.E.（RecursivelyEnumerable）&lt;/li&gt;
&lt;li&gt;Context-Sensitive Grammar&lt;/li&gt;
&lt;li&gt;Context-Free Grammar (CFG)&lt;/li&gt;
&lt;li&gt;Regular Expression (regex) &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Halting Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Halting_problem"&gt;Halting problem - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Context-Free Grammar&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form"&gt;Backus–Naur Form - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BNF (Backus-Naur Form / Backus Normal Form)&lt;ul&gt;
&lt;li&gt;one of the two main notation techniques for context-free grammars.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G = (V, T, P, S)&lt;ul&gt;
&lt;li&gt;V - A set of non-terminals&lt;/li&gt;
&lt;li&gt;T - A set of Terminals&lt;/li&gt;
&lt;li&gt;P - A set of Production Rules&lt;/li&gt;
&lt;li&gt;S - Starting Symbol&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;2015/03/05&lt;/h2&gt;
&lt;h3&gt;Terminology&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Alphabet&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Language&lt;ul&gt;
&lt;li&gt;L, L(G)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Grammar&lt;ul&gt;
&lt;li&gt;G&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Derivation Tree&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Parse_tree"&gt;Parse tree - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Not to be confused with Abstract syntax tree.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分類&lt;ul&gt;
&lt;li&gt;直&lt;/li&gt;
&lt;li&gt;橫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;write grammar for balanced expression with '{' and '}'&lt;ul&gt;
&lt;li&gt;balanced: 左右括號數目要相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;write grammr for Palindrome (迴文) &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ambiguous Grammar&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Ambiguous_grammar"&gt;Ambiguous grammar - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Un-Ambiguous Grammar&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;add &lt;strong&gt;Precedence&lt;/strong&gt; into Ambiguous Grammar&lt;ul&gt;
&lt;li&gt;Precedence 低的在外部&lt;/li&gt;
&lt;li&gt;Precedence 高的在內部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Course"></category><category term="Compiler"></category></entry><entry><title>FOSSAPC 2015 Spring Week #1</title><link href="https://blog.m157q.tw/posts/2015/03/02/fossapc-2015-spring-week-1/" rel="alternate"></link><published>2017-10-05T20:56:39+08:00</published><updated>2017-10-05T20:56:39+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-03-02:posts/2015/03/02/fossapc-2015-spring-week-1/</id><summary type="html">&lt;p&gt;配合課程使用 Hackpad&lt;br /&gt;
後續更新請看 &lt;a href="https://fossapc.hackpad.com/2015-FOSS-Week-1-Note-JHXVNsJzbeX"&gt;2015 FOSS Week #1 Note - fossapc.hackpad.com&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Android Bionic  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/android/platform_bionic"&gt;https://github.com/android/platform_bionic&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Bionic_(software)"&gt;http://en.wikipedia.org/wiki/Bionic_(software)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;How A Compiler Works&lt;/h3&gt;
&lt;h4&gt;課程連結：&lt;a href="https://sites.google.com/site/fossapc/list-of-lectures/fromsourcetobinarygnutoolchainshiruheyunzuo"&gt;20150302 - From Source to Binary: GNU Toolchain 是如何運作？ - 自由開源軟體與專案協作&lt;/a&gt;&lt;/h4&gt;
&lt;h4&gt;投影片連結：&lt;a href="http://www.slideshare.net/jserv/how-a-compiler-works-gnu-toolchain"&gt;How A Compiler Works: GNU Toolchain&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1985 - Richard Stallman - GNU FSF (GNU Free Software Foundation)  &lt;/li&gt;
&lt;li&gt;屠龍書 - Syntax Directed Translator (SDT)  &lt;/li&gt;
&lt;li&gt;Embedded System - Toolchain 太新或太舊都不行  &lt;blockquote&gt;
&lt;p&gt;在嵌入式系統中，Toolchain 的版本匹配度影響到個別軟體元件的正確性，如 kernel, libc, graphics framework 等等，而且通常開發者會從個別套件的原始碼一路編譯並建立 system/firmware image，就會遇到各式編譯錯誤、來自個別工具產生的潛在錯誤，或者需要 workaround 的狀況。於是，開發過程就會限定某個版本的 toolchain  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第一版 gcc 是 RMS 寫的，之後的版本漸漸偏離 RMS 的初衷  &lt;/li&gt;
&lt;li&gt;Dead Code Elimination  &lt;/li&gt;
&lt;li&gt;Code Motion, Loop invariant, Pointer Aliasing  &lt;ul&gt;
&lt;li&gt;Pointer Aliasing 是 Compiler 最佳化瓶頸之一，如果不同的 Pointer 指向同個 address，會造成某些generic 的最佳化出錯  &lt;/li&gt;
&lt;li&gt;C99, Restrict Pointer Aliasing  &lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Pointer_aliasing"&gt;Pointer aliasing - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;In C99, the restrict keyword was added, which specifies that a pointer argument does not alias any other pointer argument.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Static Single Assignment (SSA)  &lt;/li&gt;
&lt;li&gt;cc1: 真正的 GNU C Compiler  &lt;ul&gt;
&lt;li&gt;Source Code  &lt;/li&gt;
&lt;li&gt;Simplified AST  &lt;/li&gt;
&lt;li&gt;Gimple IR  &lt;/li&gt;
&lt;li&gt;Tree SSA Form  &lt;/li&gt;
&lt;li&gt;RTL IR (LISP Style)  &lt;/li&gt;
&lt;li&gt;Final SAM  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pipeline Scheduling  &lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline"&gt;http://en.wikipedia.org/wiki/Classic_RISC_pipeline&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;Instruction Fetch, Decode, Execute, Memory Access, Write Back  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard_%28computer_architecture%29"&gt;Hazard (computer architecture) - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LLVM  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIUC Vikram Adve, Chris Lattner in 2000  &lt;/li&gt;
&lt;li&gt;高度模組化  &lt;/li&gt;
&lt;li&gt;LLVM bitcode (IR)  &lt;/li&gt;
&lt;li&gt;LLVM 一開始是用 GCC 的 Front-end (GPLv2) 結合自己的 Back-end 成為 llvm-gcc，但 RMS 對 LLVM 這種行為感到非常不滿，並在 gcc43 時將授權改為 GPLv3 來反對 LLVM 這種偷幹 Front-end 的方式，導致後來 Apple 發展自己的 Front-end Clang  &lt;blockquote&gt;
&lt;p&gt;LLVM 的授權是 BSD License，沒有一定要 GPL 形式的強制釋出原始碼條款，但 llvm-gcc 實際上是一種「掏空」GPL 授權的 gcc 的方式，也就是讓 BSD 授權的部份在整個編譯器系統中越來越多，這是 Richard Stallman 不滿之處，他認為 GPL 在這樣的狀況下，不再保證 GPL 的效力。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Clang 採模組化設計 (Clang C API)  &lt;ul&gt;
&lt;li&gt;可 export AST  &lt;/li&gt;
&lt;li&gt;改善錯誤訊息  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LLVM Bitcode 用來當傳遞格式還有很多問題  &lt;ul&gt;
&lt;li&gt;Binary Compatibility  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目前效能已經逼近 GCC 但還差一點  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Objective-C  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1988  &lt;/li&gt;
&lt;li&gt;Steve Jobs  &lt;/li&gt;
&lt;li&gt;NeXT  &lt;/li&gt;
&lt;li&gt;GCC 2.7  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Open Source 圈中，誠信是很重要的，千萬別幹抄襲這種事。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Revolution OS&lt;/h3&gt;
&lt;h4&gt;課程連結：&lt;a href="https://sites.google.com/site/fossapc/list-of-lectures/revolutionosyingpianbeijingzhishibuchong"&gt;20150302 - 《Revolution OS》影片背景知識補充 - 自由開源軟體與專案協作&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://fossapc.hackpad.com/-Revolution-OS--RrJpYEByzmr"&gt;從 Revolution OS 看作業系統生態變化 - fossapc.hackpad.com&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Revolution_OS"&gt;Revolution OS - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=jw8K460vx1c"&gt;Revolution OS - YouTube&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影片裡同時出現了 RMS 和 Linus，可能以後都不會再看到他們同時出現在同個地方了。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RMS 是非常純的自由教義派，可以為了 Open Source BIOS 去用&lt;a href="http://zh.wikipedia.org/zh-tw/%E9%BE%99%E8%8A%AF"&gt;龍芯&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;Linus 則是實用主義派，可以為了實用而向沒有 Open Source 妥協，這是 RMS 完全沒辦法接受的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GNU 早期最知名的軟體就是 Emacs  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;MicroSoft NBC 在 Linux 被大量採用的年代很多頭條都是跟 Linux 有關的，形成一股趣味的對比。ex: VA Linux  &lt;ul&gt;
&lt;li&gt;當年 UNIX 紅到幾乎只要沾上邊就能賺錢，連賣大同電鍋的大同公司當年都搞了一套叫做 MITUX 的 UNIX 系統。  &lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ithome.com.tw/node/5632"&gt;SCO、IBM與Intel將合作開發IA-64架構的UNIX作業系統 | iThome&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://bob.gddfpaper.com/COMPUTER/OS/UNIX/A18.htm"&gt;MITUX - MITUX系統漫談 # csj@pc2.hinet.net&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;microkernel 的 CMU Mach 影響了 MacOS X 10.0 (Darwin) 和 Windows NT，雖然因為 microkernel 效能太差而沒有採用，但還是取其 flexible 的優點併入 monolithic kernel 形成了結合兩者優點的 hybrid kernel  &lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Mach_(kernel)"&gt;Mach (kernel) - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Microkernel"&gt;Microkernel - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Hybrid_kernel"&gt;Hybrid kernel - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Monolithic_kernel"&gt;Monolithic kernel - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Darwin_%28operating_system%29#Kernel"&gt;Darwin (operating system) - Wikipedia, the free encyclopedia&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;Darwin is built around XNU, a hybrid kernel that combines the Mach 3 microkernel, ...  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;關於 microkernel 的發展及介紹可以參考 jserv 的 slides &lt;a href="http://www.slideshare.net/jserv/microkernel-evolution"&gt;Microkernel Evolution&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Misc.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://programmers.stackexchange.com/questions/226573/why-is-the-unix-linker-called-ld"&gt;history - Why is the Unix linker called "ld" - Programmers Stack Exchange&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;Linkers in Linux were originally called loaders.  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Linking the Object code File&lt;br /&gt;
...Linux comes with its own linker, called ld. (The name is actually short for "load", and "loader" was what linkers were originally called, in the First Age of Unix, back in the 1970s.)  &lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="Course"></category><category term="FOSS"></category><category term="Open Source"></category><category term="Free Software"></category></entry><entry><title>Compiler Design Week 1</title><link href="https://blog.m157q.tw/posts/2015/02/24/compiler-design-week-1/" rel="alternate"></link><published>2015-02-26T16:40:00+08:00</published><updated>2015-02-26T16:40:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2015-02-24:posts/2015/02/24/compiler-design-week-1/</id><summary type="html">&lt;h3&gt;2015/02/24&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Andes Assembly&lt;/li&gt;
&lt;li&gt;Fabless IC Design House in Taiwn&lt;ul&gt;
&lt;li&gt;MediaTek - 聯發科&lt;/li&gt;
&lt;li&gt;Novatek - 聯詠&lt;/li&gt;
&lt;li&gt;Realtek - 瑞昱&lt;/li&gt;
&lt;li&gt;HiMax - 奇景&lt;/li&gt;
&lt;li&gt;立錡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code Sourcery&lt;/li&gt;
&lt;li&gt;Gate Keeper, Code Reviewer&lt;/li&gt;
&lt;li&gt;DSP Compilers&lt;ul&gt;
&lt;li&gt;Embedded Computing&lt;/li&gt;
&lt;li&gt;Base Band (3G / 4G / LTE / 5G)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Andes (晶心)&lt;ul&gt;
&lt;li&gt;Chung-Ju Wu&lt;/li&gt;
&lt;li&gt;IOT&lt;ul&gt;
&lt;li&gt;ARM 較耗電&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Language in Android&lt;ul&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;V8&lt;/li&gt;
&lt;li&gt;pixelflinger&lt;/li&gt;
&lt;li&gt;RenderScript&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HSA&lt;ul&gt;
&lt;li&gt;GPU, GPGPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Augmented Reality Functionality&lt;/li&gt;
&lt;li&gt;Compiler 現在也會參與到省電機制的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;2015/02/26&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Compiler 就是把 source language 轉換成 target language 的一個程式。     &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Cadence_Design_Systems,_Inc._v._Avanti_Corp"&gt;Avanti vs Cadence&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;Variable-length encoding / decoding     &lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikibooks.org/wiki/C_Programming/Variables#Data_type_modifiers"&gt;C Programming/Variables - Wikibooks, open books for an open world&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Some examples about IR&lt;ul&gt;
&lt;li&gt;LLVM IR = bitcode   &lt;/li&gt;
&lt;li&gt;Java =&amp;gt; bytecode&lt;/li&gt;
&lt;li&gt;C#, VB, VC++, =&amp;gt; MSIL (MiscroSoft Intermediate Language) =&amp;gt; .Net&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Course"></category><category term="Compiler"></category></entry></feed>