<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Just for noting</title><link>https://blog.m157q.tw/</link><description></description><lastBuildDate>Tue, 26 Dec 2017 12:29:40 +0800</lastBuildDate><item><title>加密和雜湊有什麼不一樣？</title><link>https://blog.m157q.tw/posts/2017/12/25/differences-between-encryption-and-hashing/</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;其實雜湊（Hash）的部份，本來是打算放在 &lt;a href="/posts/2017/12/23/differences-between-encryption-compression-and-encoding/"&gt;如何區分加密、壓縮、編碼&lt;/a&gt; 這篇一起講。但在撰寫的過程中發覺雜湊跟其他三者相比起來的差異性較大，一起講其實蠻突兀的，不太好比較。而且我自己目前看到的狀況是，雜湊比較容易跟加密搞混，所以才獨立出這篇來講一下雜湊與加密的關係。  &lt;/p&gt;
&lt;p&gt;你可能或多或少都有看過或聽過「MD5 加密」、「MD5 解密」、「SHA-1 加密」、「SHA-1 解密」、「雜湊加密演算法」。但 MD5 和 SHA-1 實際上並不是加密演算法，而是雜湊演算法。究竟加密跟雜湊到底有什麼不一樣，又該如何區分，這篇會簡單講解一下。  &lt;/p&gt;
&lt;p&gt;因為加密的部份已經在 &lt;a href="/posts/2017/12/23/differences-between-encryption-compression-and-encoding/"&gt;如何區分加密、壓縮、編碼&lt;/a&gt; 這篇提過了，所以就不重述，還不清楚的人歡迎點擊上述文章連結前去察看。以下會先講雜湊的特性，再講雜湊跟加密的區別。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;雜湊（Hash）&lt;/h3&gt;
&lt;p&gt;其實雜湊在一些壓縮演算法或者排序演算法也都有用到，&lt;br /&gt;
但這邊只就資訊安全相關的部份進行討論。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;無論原文的內容長短，透過雜湊演算法運算完的輸出都會是固定的長度，即輸出的長度不受原文長度影響。  &lt;/li&gt;
&lt;li&gt;雜湊演算法的輸出又被稱做「雜湊值」（hash value）。  &lt;/li&gt;
&lt;li&gt;不同雜湊演算法的輸出長度不同。  &lt;/li&gt;
&lt;li&gt;兩個原文的內容即便只差一個字，雜湊演算法產生的兩個輸出內容卻會差非常多。  &lt;/li&gt;
&lt;li&gt;相同的內容作為相同雜湊演算法的輸入，得到的輸出必定一樣。  &lt;/li&gt;
&lt;li&gt;不同的內容作為相同雜湊演算法的輸入，得到的相同輸出的機率極低。  &lt;/li&gt;
&lt;li&gt;無法將雜湊演算法的輸出解回原本的輸入，雜湊是單向的。  &lt;ul&gt;
&lt;li&gt;但因為相同輸入會得到相同輸出，所以最常見的破解方法就是透過 brute-force 的方式，用程式把各種可能的輸入都餵給雜湊演算法，得到輸出後，把輸入跟輸出以及所使用的雜湊演算法記起來，成為一張對應表（被稱做 rainbow table，彩虹表）。  &lt;/li&gt;
&lt;li&gt;然後拿雜湊值去其使用之雜湊演算法的 rainbow table 找尋輸入值，因為 rainbow table 是可以一直累積的，所以理論上來說，只要 rainbow table 夠大的話，就能夠找到原始的輸入值。  &lt;/li&gt;
&lt;li&gt;所以資安實務上會再為原始資料加入 salt 之後，才會丟給雜湊演算法運算，獲得加了 salt 以後的雜湊值。  &lt;ul&gt;
&lt;li&gt;salt 基本上就是額外加入的字串，可以用固定的規則改變原本的輸入值。  &lt;/li&gt;
&lt;li&gt;這樣的好處是，就算被破解了，破解的人拿到的字串仍然不會是密碼，拿去登入是不會成功的。  &lt;/li&gt;
&lt;li&gt;但在比對使用者輸入的密碼時，一樣可以加了 salt 之後再進行雜湊去比對，仍然可以驗證密碼是否正確，而安全性會增加。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用途  &lt;ul&gt;
&lt;li&gt;檔案校驗碼（Checksum）  &lt;ul&gt;
&lt;li&gt;用來快速判斷檔案是否和原本相同。  &lt;/li&gt;
&lt;li&gt;有在論壇下載過檔案的人應該都很常見到一長串 MD5 或 SHA-1 驗證碼，就是用來讓你快速檢查你下載的檔案裡頭的內容，是不是跟上傳者上傳的檔案一樣。  &lt;/li&gt;
&lt;li&gt;不一樣的話可能就是你載錯檔案、檔案有毀損或檔案被人加料了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不需要被還原的資料  &lt;ul&gt;
&lt;li&gt;例如：避免明文儲存使用者密碼  &lt;ul&gt;
&lt;li&gt;避免直接儲存使用者的明文密碼，除了避免資料庫外洩時，攻擊者無需進一步運算就可以直接得到明文密碼外，一方面也是尊重使用者，因為正常情況下只有使用者知道自己的密碼。  &lt;/li&gt;
&lt;li&gt;要簡單判斷網站有沒有明文儲存你的密碼最簡單的兩個方法：  &lt;ul&gt;
&lt;li&gt;寄信給你的時候有沒有直接把密碼寫在內文。  &lt;/li&gt;
&lt;li&gt;忘記密碼的時候不是要求你或幫你重新設定密碼，而是直接告訴你你的密碼。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但因為相同原文透過相同的雜湊演算法會得到相同的輸出，所以可以在不明文儲存使用者密碼的情況下，確認使用者輸入的密碼是否正確。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;SHA 系列：  &lt;ul&gt;
&lt;li&gt;SHA-0  &lt;/li&gt;
&lt;li&gt;SHA-1  &lt;ul&gt;
&lt;li&gt;SHA-1 已經被證明不夠安全。（在可接受的時間範圍內，可以找到內容不相同輸入卻得到相同輸出。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SHA-2  &lt;ul&gt;
&lt;li&gt;SHA-256  &lt;/li&gt;
&lt;li&gt;SHA-512  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SHA-3  &lt;ul&gt;
&lt;li&gt;SHA3-256  &lt;/li&gt;
&lt;li&gt;SHA3-512  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MD5  &lt;ul&gt;
&lt;li&gt;MD5 也已經被證明不夠安全。（在可接受的時間範圍內，可以找到內容不相同輸入卻得到相同輸出。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BLAKE2  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;就是一串拿來做檢查的字串，但根據使用需求可以有不同的用途。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;所以，為什麼雜湊不是加密？&lt;/h2&gt;
&lt;p&gt;我個人認為，雜湊和加密很容易被人搞混的原因，主要是因為，雜湊和加密通常是一起使用的，常常被拿在一起講，所以久而久之就搞混了。  &lt;/p&gt;
&lt;p&gt;但其實可以透過以下幾點來區分：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密需要密鑰，且可以透過解密得到原文。（加密可逆）  &lt;/li&gt;
&lt;li&gt;雜湊不需密鑰，無法逆向解出原始輸入。（雜湊不可逆）  &lt;ul&gt;
&lt;li&gt;雖然可以透過額外儲存的 rainbow table 來找尋原始輸入，但彩虹表是預先計算並儲存下來的，而不是雜湊演算法本身的設計。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;舉例  &lt;ul&gt;
&lt;li&gt;今天如果我拿到一串密文，我是有辦法透過解密，得到原始的明文的，而且如果使用非對稱式加密的話，我甚至還可以驗證傳送方是不是本人（是否有被進行中間人攻擊）。  &lt;ul&gt;
&lt;li&gt;雜湊演算法在這裡也會被使用，通常會被拿來檢驗傳送的訊息是否有被更改過。  &lt;/li&gt;
&lt;li&gt;傳送方附上原始訊息經過某個雜湊演算法得出的雜湊值，接收方在解開這個訊息之後，會透過相同的雜湊演算法來驗證。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但如果是拿到一串雜湊值的話，理論上是無法逆向得到原始的明文的，根本無法拿來做資料的傳遞。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以別再說出「MD5 加密」、「MD5 解密」、「SHA-1 加密」、「SHA-1 解密」之類的話啦~  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;小測驗&lt;/h2&gt;
&lt;p&gt;如果這兩篇有看懂的話，應該就可以理解&lt;a href="https://mobile.twitter.com/orsonwang/status/944400953591021568"&gt;這個 tweet&lt;/a&gt; 在講什麼：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pkcs7 簽章使用 RSA 加密演算法對資料的 SHA256 雜湊值簽章，台灣的金融機構習慣對這簽章做 base64 編碼來避免古早用 Cobol 的系統以 ASCII 字碼接收而產生所有資料第 8 bit 都是 0 而引起的驗證錯誤。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dotblogs.com.tw/regionbbs/2017/09/21/hashing_is_not_encryption"&gt;[Security] 雜湊不是加密，雜湊不是加密，雜湊不是加密。 | 小朱® 的技術隨手寫 - 點部落&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.securityinnovationeurope.com/blog/page/whats-the-difference-between-hashing-and-encrypting"&gt;What is The Difference Between Hashing and Encrypting&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)"&gt;鹽 (密碼學) - 維基百科，自由的百科全書&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">m157q</dc:creator><pubDate>Tue, 26 Dec 2017 12:29:40 +0800</pubDate><guid isPermaLink="false">tag:blog.m157q.tw,2017-12-25:posts/2017/12/25/differences-between-encryption-and-hashing/</guid><category>Encryption</category><category>Hashing</category><category>2018 iT 邦幫忙鐵人賽</category></item><item><title>如何區分加密、壓縮、編碼</title><link>https://blog.m157q.tw/posts/2017/12/23/differences-between-encryption-compression-and-encoding/</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;base64 加密？base64 壓縮？base64 編碼？傻傻分不清？&lt;br /&gt;
究竟：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密（Encrypt）  &lt;/li&gt;
&lt;li&gt;壓縮（Compress）  &lt;/li&gt;
&lt;li&gt;編碼（Encode）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到底有什麼差別？  &lt;/p&gt;
&lt;p&gt;明明不管是中文還是英文，&lt;br /&gt;
這 3 個詞長得一點都不像，&lt;br /&gt;
那到底為什麼很多人會把這 3 種東西都當成加密呢？  &lt;/p&gt;
&lt;p&gt;主要是因為透過這 3 種方式處理過後的資料，&lt;br /&gt;
都會長的跟原本不一樣，&lt;br /&gt;
一般人無法直接辨別，&lt;br /&gt;
就覺得是被加密處理過的密文天書。  &lt;/p&gt;
&lt;p&gt;然而，&lt;br /&gt;
並不是變成人看不懂的東西就叫作「加密」。&lt;br /&gt;
如果誤用的話，&lt;br /&gt;
很有可能你自以為加密了的東西，&lt;br /&gt;
實際上並沒有經過加密處理，&lt;br /&gt;
隨隨便便就可以被懂其中差異的人拿到你寶貴的原始文字（最有可能的就是你的密碼啦）。&lt;br /&gt;
以下就來簡單說明這 3 種東西各自的特性，&lt;br /&gt;
會特別拿 base64 來說，&lt;br /&gt;
希望能夠端正一下視聽。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;加密（Encryption）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;首先得產生一個新的字串作為密鑰，也就是一把鑰匙。  &lt;/li&gt;
&lt;li&gt;原文與密鑰作為加密演算法的輸入，得到的輸出即為加密過後的密文。  &lt;/li&gt;
&lt;li&gt;可以想像成，加密演算法幫你打造出你給它的這把密鑰才可以開啟的寶箱，幫你把原文放入寶箱後，用這把密鑰上鎖，上鎖後的寶盒就是密文，看不到裡面的東西是什麼。  &lt;/li&gt;
&lt;li&gt;這種只有一把鑰匙的加密演算法被稱為對稱式加密（Symmetric Encryption）。  &lt;/li&gt;
&lt;li&gt;問題也很明顯，要是你沒有保管好你的鑰匙，或者你的鑰匙構造太簡單被人打造出一模一樣的鑰匙，別人就可以打開寶箱，拿到內容物。  &lt;ul&gt;
&lt;li&gt;比如說你的密鑰是一個叫作 "5566" 的字串，因為太好猜了，所以很容易被解密回來。  &lt;/li&gt;
&lt;li&gt;這也是為什麼通常在生成密鑰的時候會建議長度愈長愈好，尤其現在電腦的運算能力愈來愈強，以往透過程式一個一個暴力猜測密鑰的方式，在相同單位時間內可以猜的數量變多了，密鑰長度太短的話，很容易就被猜到。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因為對稱式加密的安全性以及在實際應用上不夠理想，於是乎，出現了安全性更高，應用範圍更廣的非對稱式加密（Asymmetric Encryption）。  &lt;/li&gt;
&lt;li&gt;非對稱式加密演算法會有兩把鑰匙，一把稱做公鑰（可以公開），另一把稱做私鑰（自己要藏好）。  &lt;/li&gt;
&lt;li&gt;非對稱式加密除了可以做到加密以外，還可以生成數位簽章，確認密文的傳送方身份真的是本人，這篇不會細談。  &lt;/li&gt;
&lt;li&gt;但這並不代表對稱式加密就沒有人用，兩者各有各的優缺點，所以實際應用上通常都是視情況而定，常常會有兩者一起使用的情形。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;對稱式：DES, 3DES, AES  &lt;/li&gt;
&lt;li&gt;非對稱式：RSA, DSA, ECC  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;沒有這把鑰匙（無論是拿到或猜到）就無法得知真正的訊息。  &lt;/li&gt;
&lt;li&gt;使用 base64 的時候不需要密鑰，而且任何人編碼的 base64 訊息，任何人都可以經過 base64 解碼回來，所以 base64 不是加密。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;壓縮（Compression）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;輸入（通常是檔案）經過壓縮演算法後得到的輸出，大小比輸入來得小。  &lt;/li&gt;
&lt;li&gt;根據有無失真又區分為非破壞性（無損）壓縮與破壞性（有損）壓縮：  &lt;ul&gt;
&lt;li&gt;無損壓縮：無失真、壓縮率沒辦法到太高，通常用在文件檔案這種不能缺少原始資料的東西。  &lt;/li&gt;
&lt;li&gt;有損壓縮：失真、壓縮率可以比較高，通常用在圖片、視訊、音訊，因為可以去掉人眼或人耳無法辨認出差異的部份，降低檔案大小可以有效提升傳輸時的效率。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;zip, gzip, rar, 7zip, jpg, mp3, mp4, Huffman coding  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;沒有讓輸出比輸入小的演算法就不是壓縮。  &lt;/li&gt;
&lt;li&gt;經過 base64 編碼後得到的結果，實際上會比原檔案多三分之一左右，所以 base64 不是壓縮。  &lt;ul&gt;
&lt;li&gt;base64 使用 64 個可顯示的 ASCII 字元來表示二進位資料。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;2^6 = 64&lt;/code&gt;，也就是一個 base64 單元表示 6 位元，即用 1 個 ASCII 字元（8 bits），表示 6 bits 資料，比例為 &lt;code&gt;4:3&lt;/code&gt;，也就大概多了 &lt;code&gt;1/3&lt;/code&gt; 出來。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;那為什麼很多地方會提到在網頁上用 base64 表示圖片可以加速？  &lt;ul&gt;
&lt;li&gt;主要是因為把圖片直接以 base64 字串的形式呈現在網頁上的話，就不需要額外再發 request 去要圖片。  &lt;/li&gt;
&lt;li&gt;但因為 base64 會把檔案變大不少，所以很多人會先把圖片經過 gzip 壓縮後，再編碼成 base64 字串。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;編碼（Encoding）&lt;/h3&gt;
&lt;p&gt;編碼牽涉的範圍非常廣，&lt;br /&gt;
包含了：字元編碼（Character Encoding）、音訊編碼（Audio Encoding）、視訊編碼（Video Encoding）、…… 等等，&lt;br /&gt;
所以在這篇文章不會仔細講。&lt;br /&gt;
其實廣義上來說，&lt;br /&gt;
上述提到的加密與壓縮都算是編碼的其中一種，&lt;br /&gt;
但這裡就把上述兩個排除。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;將原文轉換成另外一種表達方式。  &lt;/li&gt;
&lt;li&gt;不需要密鑰，只要知道你用哪個編碼演算法，任何人都可以解碼。  &lt;ul&gt;
&lt;li&gt;這也是單純編碼被拿來誤用成加密演算法最危險的地方，因為完全不需要花時間猜密鑰。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同的編碼演算法有不同的特性  &lt;ul&gt;
&lt;li&gt;錯誤偵測（Error Detection）  &lt;ul&gt;
&lt;li&gt;檢查訊息在經過傳送後是否已經改變。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;錯誤校正（Error Correction）  &lt;ul&gt;
&lt;li&gt;自動修正在經過傳送後錯誤的內容。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方便資料進行傳輸  &lt;ul&gt;
&lt;li&gt;以不同的形式表示相同的資料。  &lt;/li&gt;
&lt;li&gt;例如: base64 就把二進位的資料用 ASCII 來表示。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;base64, urlencode, hamming code,  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有密鑰：加密  &lt;/li&gt;
&lt;li&gt;輸出比輸入小：壓縮  &lt;/li&gt;
&lt;li&gt;其他：編碼  &lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">m157q</dc:creator><pubDate>Mon, 25 Dec 2017 17:49:55 +0800</pubDate><guid isPermaLink="false">tag:blog.m157q.tw,2017-12-23:posts/2017/12/23/differences-between-encryption-compression-and-encoding/</guid><category>Encryption</category><category>Compression</category><category>Encoding</category><category>2018 iT 邦幫忙鐵人賽</category></item></channel></rss>