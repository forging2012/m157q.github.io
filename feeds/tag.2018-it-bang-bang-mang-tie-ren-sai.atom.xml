<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Just for noting</title><link href="https://blog.m157q.tw/" rel="alternate"></link><link href="https://blog.m157q.tw/feeds/tag.2018-it-bang-bang-mang-tie-ren-sai.atom.xml" rel="self"></link><id>https://blog.m157q.tw/</id><updated>2018-02-01T00:38:24+08:00</updated><entry><title>2018 iT 邦幫忙鐵人賽參賽心得</title><link href="https://blog.m157q.tw/posts/2018/01/19/2018-ithelp-ironman/" rel="alternate"></link><published>2018-01-22T14:55:49+08:00</published><updated>2018-01-22T14:55:49+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-19:posts/2018/01/19/2018-ithelp-ironman/</id><summary type="html">&lt;h2&gt;2018 iT 邦幫忙鐵人賽參賽心得&lt;/h2&gt;
&lt;p&gt;&lt;img alt="完賽通知" src="/files/2018-ithelp-ironman/finish-notification.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;之前就有看過一些朋友參賽，這次是自己第一次參賽，主要是因為剛好近期離職了，而且想要一併把自己在工作期間暫時紀錄下來的一些草稿都清掉，否則等到下一份工作的話這些草稿應該就會變萬年草稿了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;2017/12/18 報名，但一直到最後一天 2017/12/20 才下定決心參賽，到昨天 2018/01/18 成功達成連續 30 天每天發文的成就。我認真覺得要不是現在在待業，根本沒辦法完賽，真的很佩服那些有在工作還能完賽的參賽者，甚至也有之前參賽的人跟我說過「我當時參賽是事前就寫好 30 篇文章了」。&lt;br /&gt;
&lt;img alt="鐵人獎牌" src="/files/2018-ithelp-ironman/medal.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我覺得開頭倒沒有那麼難，可能是因為我有好幾篇草稿可以寫的關係，對我來說最困難的反而是快要完賽的前一週，一來是因為我囤積的草稿已經清完，參賽的目的達成了，二來是因為中間有幾天的文章其實還沒補完，直到完賽前 5 天，我其實還有 10 篇文章未完成。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;快完賽的前幾天一度想放棄，當時才深刻體會到什麼叫作「行百里者半九十」。一直拖到最後兩天，還剩下 7 篇文章沒完成。在最後才狠下心來，2018/01/17 晚上沒睡覺，一直撐到 2018/01/18 最後一天的晚上十一點多，總算把 7 篇文章都補完。&lt;br /&gt;
&lt;img alt="行百里者半九十" src="/files/2018-ithelp-ironman/last-day-notification.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最後順利在 2018/01/19 的午夜十二點多拿到了本次鐵人賽個人挑戰組的獎牌，要躺上床去睡覺時，才意識到自己已經保持清醒狀態 37.5 小時了，腎上腺素的威力真的有點驚人，硬是讓我在最後一天補了 5 篇文章，而且思緒異常清晰還不太容易飢餓。&lt;br /&gt;
&lt;img alt="KanbanFlow 時數" src="/files/2018-ithelp-ironman/kanbanflow.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;就像本次參賽時寫下的，即便平常就有在寫落格文章的習慣，要連續發 30 天的文章真的是件很有挑戰性的事，從總完賽率 &lt;code&gt;143/359 == 0.3983286908077994&lt;/code&gt; 不到四成可見一般。（不知道是不是還在審查中，如果是的話，確認完賽的人數可能還會再降低。）&lt;br /&gt;
&lt;img alt="參賽敘述" src="/files/2018-ithelp-ironman/intro.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;撇除掉複製貼上別人的文章（這次真的有人這樣做被發現），如果是撰寫入門系列的文章可能難度會比較低一些，畢竟都是自己所熟知的東西了。非入門系列的話，我覺得如果沒有 15~20 篇以上的草稿或者至少 10 篇以上早就準備好的文章的話，真的是很難完賽，如果是神人等級的當然另當別論，像這次我看到最強的應該就是&lt;a href="https://ithelp.ithome.com.tw/users/20107159/ironman/1325"&gt;爬蟲始終來自於墮性&lt;/a&gt;這個系列了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;也有看到有人參加了好幾次都中途棄賽的，只能說連續 30 天發文看似簡單，但實際去做了以後才發現真的沒那麼簡單。接下來幾個禮拜應該都不太想寫文章了，應該會專心看還沒看完的書、刷題寫程式還有更新履歷準備之後面試的事。不知道之後還會不會參賽，也許會，也許不會，未來的事誰都說不準啊。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最後附上這次參賽的系列網址：&lt;a href="https://ithelp.ithome.com.tw/users/20107813/ironman/1535"&gt;https://ithelp.ithome.com.tw/users/20107813/ironman/1535&lt;/a&gt;，有興趣的人可以去看。  &lt;/p&gt;
&lt;p&gt;也可以在我的部落格找 &lt;a href="/tag/2018-it-bang-bang-mang-tie-ren-sai/"&gt;"2018 iT 邦幫忙鐵人賽" 這個 tag 的文章&lt;/a&gt;，有任何意見或問題都歡迎回覆。  &lt;/p&gt;
&lt;p&gt;以下也直接按照參賽發文時間順序列出這 30 篇文章的標題與在我落格上的連結：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/20/4g-mobile-network-tw/"&gt;關於 4G 行動網路的一些筆記&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/21/how-to-answer-questions-in-a-helpful-way-zh-tw/"&gt;《回答的智慧》&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/22/write-a-python-script-to-retrieve-twitter-direct-messsages/"&gt;用 Python 寫個程式抓出我在 Twitter 上存了哪些 tweet&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/23/differences-between-encryption-compression-and-encoding/"&gt;如何區分加密、壓縮、編碼&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/24/i-love-open-source-because-someone-will-write-testings-for-me/"&gt;我愛開源，因為會遇到路人幫我寫測試。&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/25/differences-between-encryption-and-hashing/"&gt;加密和雜湊有什麼不一樣？&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/26/i-left-my-first-full-time-job/"&gt;我的新鮮人離職紀錄&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/27/fetch-my-github-commits-in-one-organization-with-python-script/"&gt;用 Python 抓出我在前公司貢獻了多少 GitHub commits&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/28/about-django-f-expression-q-object-and-aggregation/"&gt;關於 Django 的 F() expressions, Q object, Aggregation 的一些筆記&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/29/ngrok-https-proxy-to-write-chatbot-in-localhost/"&gt;利用 ngrok 直接在本機開發 chatbot&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/30/git-cross-repo-cherry-pick/"&gt;使用 Git 時如何做出跨 repo 的 cherry-pick&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2017/12/31/mount-iphone-on-linux/"&gt;Linux 上如何拿到 iPhone 裡的資料&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/01/change-keymap-on-linux/"&gt;Linux 上如何透過指令更改鍵盤鍵位&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/02/tips-about-facebook-url/"&gt;Facebook 網址的一些黑魔法&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/03/try-to-do-gofmt-in-python/"&gt;嘗試在 Python 中做到 Golang fmt 的效果&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/04/solution-for-gcin-2-8-5-2-cannot-run-in-application-using-qt-after-5-9-x-on-arch-linux/"&gt;解決 Arch Linux 上 gcin 2.8.5-2 無法在 Qt 5.9.x 以後的應用程式中執行的問題&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/05/set-default-application-in-desktop-environment-on-linux/"&gt;Linux 設定桌面環境預設開啟程式&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/06/use-cookie-with-urllib-in-python/"&gt;Python 中讓 urllib 使用 cookie 的方法&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/07/django-rest-framework-note/"&gt;關於 Django REST framework 的一些筆記&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/08/miracast-on-linux/"&gt;如何在 Linux 上使用 Miracast&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/09/tools-i-use/"&gt;我平常在電腦上用了哪些程式&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/10/docker-travis-ci-kubernetes-gke/"&gt;Docker + Travis CI + Kubernetes + GKE&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/11/dealing-with-china-network/"&gt;中國網路相關筆記&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/12/articles-related-to-interview/"&gt;整理一些跟面試相關的文章&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/13/zyxel-wah7706/"&gt;ZyXEL WAH7706 問題紀錄&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/14/soft-skiils-the-software-developers-life-manual/"&gt;《軟技能：代碼之外的生存指南》&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/15/the-pragmatic-programmer-from-journeyman-to-master/"&gt;《程序员修炼之道:从小工到专家》&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/16/change-docker-storage-driver-from-devicemapper-to-overlay2-to-free-your-disk-space-on-arch-linux/"&gt;在 Arch Linux 上將 Docker 的 Storage Driver 從 devicemapper 改為 overlay2 以釋放硬碟空間&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/17/virtual-currency-vs-digital-currency-vs-cryptocurrency/"&gt;虛擬貨幣 vs 數位貨幣 vs 加密貨幣&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="/posts/2018/01/18/zdict-intro/"&gt;zdict 介紹&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="iThome"></category><category term="iThelp"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>zdict 介紹</title><link href="https://blog.m157q.tw/posts/2018/01/18/zdict-intro/" rel="alternate"></link><published>2018-02-01T00:38:24+08:00</published><updated>2018-02-01T00:38:24+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-18:posts/2018/01/18/zdict-intro/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/zdict/zdict"&gt;GitHub - zdict/zdict: The last online dictionary framework you need. (?)&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://blog.m157q.tw/posts/2018/01/09/tools-i-use/"&gt;我平常在電腦上用了哪些程式 | Just for noting&lt;/a&gt;這篇，有提到會為 &lt;code&gt;zdict&lt;/code&gt; 這套我和幾個朋友一起開發的線上字典查詢指令做個詳細一點的介紹，也算是幫 &lt;code&gt;zdict&lt;/code&gt; 加個繁體中文的文章吧。  &lt;/p&gt;
&lt;p&gt;因為 repo 上面都是用英文，幾個禮拜前遇到有台灣人想幫忙貢獻，對自己的英文不夠有自信，結果最後寄了 email 用中文問我，想說讓這個工具的文件多一點繁體中文的親切感（？  &lt;/p&gt;
&lt;p&gt;有空會再寫一篇文章講這位貢獻者來信詢問的問題以及我回覆的內容，主要是跟 GitHub 新手如何參與開源專案有關，想說第一次有人因為 &lt;code&gt;zdict&lt;/code&gt; 寄信給我，機會難得，順便用這個機會拿 &lt;code&gt;zdict&lt;/code&gt; 來當活教材。有徵得對方同意了，但文章一直還沒寫 XD。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;簡介&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/zdict/zdict"&gt;https://github.com/zdict/zdict&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;有以下幾個特性：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 3 撰寫  &lt;ul&gt;
&lt;li&gt;2020 年就要拋棄 Python 2 啦，因為是 side project，所以懶得支援 Python 2 了，請大家直接用 Python 3 吧。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要用途就是用來查線上字典  &lt;ul&gt;
&lt;li&gt;要連網才能使用  &lt;/li&gt;
&lt;li&gt;沒有離線模式  &lt;ul&gt;
&lt;li&gt;不使用字典檔  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;預設會使用資料庫中的快取（可選擇關閉）  &lt;ul&gt;
&lt;li&gt;每次的查詢預設都會先檢查有沒有存在使用者的電腦上的 zdict 資料庫，有的話就會直接拿來用。  &lt;/li&gt;
&lt;li&gt;所以如果是查詢自己查過的單字的話，是可以在不用連網的情況下使用的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字典預設是使用 Yahoo! 奇摩字典的英翻中或中翻英查詢  &lt;ul&gt;
&lt;li&gt;有其他線上字典可供選擇：  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;moe&lt;/code&gt;: 萌典  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;moe-taiwanese&lt;/code&gt;: 萌典台語  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;spanish&lt;/code&gt;: 西班牙語  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;jisho&lt;/code&gt;: 日語  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;yahoo&lt;/code&gt;: 中英查詢  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;urban&lt;/code&gt;: Urban Dictionary，用來查英文流行用語，看美劇滿常用的。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;yandex&lt;/code&gt;: 俄語  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;預設會有語法上色（可選擇關閉）  &lt;/li&gt;
&lt;li&gt;原生支援 macOS, Linux, FreeBSD。可透過 Docker 在 Windows 上執行。  &lt;/li&gt;
&lt;li&gt;有一般模式也有互動模式  &lt;ul&gt;
&lt;li&gt;互動模式很適合開啟來掛著，遇到有要查單字的時候就可以直接查，不需要再額外打 &lt;code&gt;zdict xxx&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;緣起&lt;/h2&gt;
&lt;p&gt;這個 side project 大概是從 2015 年 4 月開始的，一開始只是因為那陣子很常看美劇，所以有查單字的需求，覺得要開網頁動滑鼠很麻煩，所以就找有沒有可以在終端機裏面直接查字典的服務。  &lt;/p&gt;
&lt;p&gt;當時是找到 &lt;a href="https://github.com/chenpc/ydict"&gt;GitHub - chenpc/ydict&lt;/a&gt;，使用一陣子之後遇到 Yahoo! 字典網頁改版，所以有東西壞掉，發了個 PR 回去，結果作者很久沒處理，看起來在忙其他事了。  &lt;/p&gt;
&lt;p&gt;原本想說自己的 fork 改一改能用就好，但和 iblis 那天可能嗑了太多 Python，不知道發什麼神經覺得乾脆來弄一個可以整合查詢多個線上字典的框架好了。  &lt;/p&gt;
&lt;p&gt;因為 ydict 基本上就是個 Python 2 的 script 而已，當時就想說要弄一個 Pure Python 3 然後還要符合基本開源專案架構的 side project，所以 zdict 就這樣誕生了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;使用說明&lt;/h2&gt;
&lt;p&gt;這個就直接看 &lt;a href="https://github.com/zdict/zdict/blob/master/README.rst"&gt;zdict/README.rst&lt;/a&gt; 吧，裡頭的英文敘述沒有很難，就算看不懂其實也可以直接看截圖和 example 使用應該沒啥問題，我就不在這贅述了。這篇文章會比較像是開發心得的紀錄，留個念想（？）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;雜談&lt;/h2&gt;
&lt;p&gt;其實我還蠻享受這個和幾個朋友單純因為需求而開的 side project，從開始弄這個專案以來基本上沒啥壓力，然後想試一些跟 Python 有關的新東西都可以在這個 side project 嘗試，因為有了基本的開源專案的框架，要測一些東西也很方便，不需要自己再重頭刻一些有的沒的。  &lt;/p&gt;
&lt;p&gt;例如：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透過 Travis CI 自動發佈新版本到 PyPI  &lt;/li&gt;
&lt;li&gt;透過 Docker Cloud 綁定 GitHub 的權限，在有新的 tag 的時候自動 build image，放到 Docker Hub，完成 Docker Image 的 CI。  &lt;ul&gt;
&lt;li&gt;這部份的功能原本是用 Docker Hub 做，但用到一半發現 Docker Hub 在這部份很難用，又剛好看到 Docker Cloud，試了一下發現做的比較好，所以就改用 Docker Cloud 了。  &lt;/li&gt;
&lt;li&gt;唯一一個被雷到的部份是，如果原先使用 Docker Hub，改用 Docker Cloud 的話，得把原本的 Docker Hub Repo 砍掉，用 Docker Cloud 來建一個新的 Automated build 的 Repo，這部份可能會多花一點時間。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支援 Docker Image  &lt;/li&gt;
&lt;li&gt;pytest, coverage 相關的參數設定  &lt;/li&gt;
&lt;li&gt;使用 Pipfile  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上這些都是我初次經驗就拿這個專案來試，我覺得滿開心的。雖然快 3 年過去了，好像仍舊沒有成為當初說的框架，要新增新的字典進來我覺得也還不夠簡單，但就順其自然吧。  &lt;/p&gt;
&lt;p&gt;然後大家也是有啥需求就自己開 issue，然後自己開發。大多數都是「自己的 issue 自己解的狀況」：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有人因為想在 Vim 裏面用，所以直接寫了個 Vim plugin: &lt;a href="https://github.com/zdict/zdict.vim"&gt;GitHub - zdict/zdict.vim: A vim plugin integrate with zdict - the last online dictionary framework you need.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;有人因為懶得打指令想要補完，所以弄了個 completion script: &lt;a href="https://github.com/zdict/zdict.sh"&gt;GitHub - zdict/zdict.sh: A collection of shell completion scripts for zdict&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;有人因為想用滑鼠選起來就能直接查，所以寫了這個：&lt;a href="https://github.com/zdict/zdict.qt"&gt;GitHub - zdict/zdict.qt: zdict with Qt5 widget&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;反正就是很自由啦，連 organizaiton 都是拿 One Taiwan 的圖片產生器來改的：&lt;a href="https://github.com/zdict"&gt;zdict · GitHub&lt;/a&gt;，就知道有多北七。XD  &lt;/p&gt;
&lt;p&gt;我覺得大家應該都要至少要找到一個屬於自己的這種 side project，可以讓你跟一些人 cowork，但又不會有壓力，同時又符合你日常生活的需求。  &lt;/p&gt;
&lt;p&gt;而且因為彼此想要的功能不一樣，而且又是開放原始碼的專案，所以可以學到自己不會的東西。唯一的小缺憾大概就是，這只是個小確幸的專案，不是什麼大專案，但又何妨？  &lt;/p&gt;
&lt;p&gt;要練習寫程式的話真的從自身的需求出發就夠了，不需要做一個什麼多偉大多困難的專案，可以等夠熟練的時候再說，希望大家都能找到一個屬於自己的 side project 當作核爆場（誒  &lt;/p&gt;</summary><category term="zdict"></category><category term="online dictionary"></category><category term="cli"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>虛擬貨幣 vs 數位貨幣 vs 加密貨幣</title><link href="https://blog.m157q.tw/posts/2018/01/17/virtual-currency-vs-digital-currency-vs-cryptocurrency/" rel="alternate"></link><published>2018-01-17T05:30:34+08:00</published><updated>2018-01-17T05:30:34+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-17:posts/2018/01/17/virtual-currency-vs-digital-currency-vs-cryptocurrency/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;兩派說法  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虛擬貨幣 == 數位貨幣 &amp;gt; 加密貨幣  &lt;/li&gt;
&lt;li&gt;虛擬貨幣 &amp;gt; 數位貨幣 &amp;gt; 加密貨幣  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;因為看到&lt;a href="https://twitter.com/tzangms/status/953252211957485571"&gt;推特上有人問&lt;/a&gt;，&lt;br /&gt;
自己其實也有被這問題困擾著，於是就花了點時間查了一下。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;紀錄&lt;/h2&gt;
&lt;p&gt;查了一些文章以後發現大致上分為兩派：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「虛擬貨幣 == 數位貨幣 &amp;gt; 加密貨幣」派  &lt;ul&gt;
&lt;li&gt;目前以這派說法好像比較常見，英文維基百科上的描述偏向這類說法。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;「虛擬貨幣 &amp;gt; 數位貨幣 &amp;gt; 加密貨幣」派  &lt;ul&gt;
&lt;li&gt;中文維基百科偏向這類說法。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;我自己歸納如下，我個人是比較傾向「虛擬貨幣 &amp;gt; 數位貨幣 &amp;gt; 加密貨幣」派  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虛擬貨幣 == 非實體貨幣  &lt;/li&gt;
&lt;li&gt;數位貨幣 == 可用於購買現實物品的虛擬貨幣  &lt;/li&gt;
&lt;li&gt;加密貨幣 == 基於密碼學原理的數位貨幣  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/%E6%95%B8%E4%BD%8D%E8%B2%A8%E5%B9%A3"&gt;數位貨幣 - 維基百科，自由的百科全書&lt;/a&gt;有列出非加密貨幣的數位貨幣，例如: e-gold, Digital Monetary Trust, Ripple, Ven。  &lt;/p&gt;
&lt;p&gt;我自己覺得是有點像 Artifical Intelligence vs Machine Learning vs Deep Learning 的關係啦。&lt;br /&gt;
雖然一般人可能覺得能溝通就好，但我覺得身為一個處在這個專業領域的人士，應該要有自己的堅持。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.quora.com/What-is-the-difference-between-a-cryptocurrency-a-digital-currency-and-a-virtual-currency"&gt;What is the difference between a cryptocurrency, a digital currency, and a virtual currency?&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Virtual_currency"&gt;Virtual currency - Wikipedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Digital_currency"&gt;Digital currency - Wikipedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Cryptocurrency"&gt;Cryptocurrency - Wikipedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/%E8%99%9A%E6%8B%9F%E8%B4%A7%E5%B8%81"&gt;虛擬貨幣 - 維基百科，自由的百科全書&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/%E6%95%B8%E4%BD%8D%E8%B2%A8%E5%B9%A3"&gt;數位貨幣 - 維基百科，自由的百科全書&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/%E5%AF%86%E7%A2%BC%E8%B2%A8%E5%B9%A3"&gt;密碼貨幣 - 維基百科，自由的百科全書&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="virtual currency"></category><category term="digital currency"></category><category term="cryptocurrency"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>在 Arch Linux 上將 Docker 的 Storage Driver 從 devicemapper 改為 overlay2 以釋放硬碟空間</title><link href="https://blog.m157q.tw/posts/2018/01/16/change-docker-storage-driver-from-devicemapper-to-overlay2-to-free-your-disk-space-on-arch-linux/" rel="alternate"></link><published>2018-01-17T05:05:02+08:00</published><updated>2018-01-17T05:05:02+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-16:posts/2018/01/16/change-docker-storage-driver-from-devicemapper-to-overlay2-to-free-your-disk-space-on-arch-linux/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://wiki.archlinux.org/index.php/Docker#Storage_driver"&gt;https://wiki.archlinux.org/index.php/Docker#Storage_driver&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;因為硬碟空間只剩 1.8 GB，在清硬碟空間的時候發現 &lt;code&gt;/var/lib/docker/devicemapper&lt;/code&gt; 佔了 35 GB，以前同事在 Mac 上遇過，但一直找不到啥好解法，這次自己遇到了，於是就花了點時間查了一下。  &lt;/p&gt;
&lt;p&gt;先是用了 &lt;code&gt;docker system prune -a&lt;/code&gt; 把所有東西都清掉，結果發現 &lt;code&gt;/var/lib/docker/devicemappe&lt;/code&gt; 的大小只有減少 1 GB，但明明用 &lt;code&gt;docker info&lt;/code&gt; 檢查， Data used 就只剩 KB 而已，於是跑去找 Arch Wiki。  &lt;/p&gt;
&lt;p&gt;得到 Storage Driver 最好不要用 &lt;code&gt;devicemapper&lt;/code&gt; 的答案，新安裝的預設應該都會是 &lt;code&gt;overlay2&lt;/code&gt; 了，發現自己的 docker 仍舊是使用 &lt;code&gt;devicemapper&lt;/code&gt;，所以乾脆動手修改一下。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;步驟&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;systemctl stop docker&lt;/code&gt; 把 dockerd 關了  &lt;/li&gt;
&lt;li&gt;因為我已經用 &lt;code&gt;docker system prune -a&lt;/code&gt; 把東西全砍了，所以就沒備份必要，直接 &lt;code&gt;sudo rm -rf /var/lib/docker&lt;/code&gt; 了  &lt;ul&gt;
&lt;li&gt;這個時候硬碟就多出了 35 GB 啦！  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;systemctl edit docker&lt;/code&gt; 編輯設定檔  &lt;ul&gt;
&lt;li&gt;如果 root 使用的 editor 非平常慣用的話，可以先 &lt;code&gt;export EDITOR=vim&lt;/code&gt; 再使用 &lt;code&gt;sudo -E bash -c "systemctl edit docker"&lt;/code&gt; 來編輯  &lt;/li&gt;
&lt;li&gt;應該會開啟 &lt;code&gt;/etc/systemd/system/docker.service.d/override.conf&lt;/code&gt; 或其暫存檔  &lt;/li&gt;
&lt;li&gt;新增以下內容，將 Storage Driver 指定成 &lt;code&gt;overlay2&lt;/code&gt; 後存檔離開：  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[Service]  
ExecStart=  
ExecStart=/usr/bin/dockerd -H fd:// -s overlay2  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;systemctl start docker&lt;/code&gt; 重新開啟 dockerd  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker info | head&lt;/code&gt; 裡頭應該要有一行 "Storage Driver: overlay2" 這樣就成功了  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;補充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/engine/userguide/storagedriver/selectadriver/"&gt;Select a storage driver | Docker Documentation&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇官方文件講述有哪些 Storage Driver 可供選擇以及各 Storage Driver 支援的 File System 格式  &lt;/li&gt;
&lt;li&gt;包含：&lt;code&gt;aufs&lt;/code&gt;, &lt;code&gt;devicemapper&lt;/code&gt;, &lt;code&gt;overlay&lt;/code&gt;, &lt;code&gt;overlay2&lt;/code&gt;, &lt;code&gt;btrfs&lt;/code&gt;, &lt;code&gt;zfs&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;我自己是沒有詳細研究所有 Storage Driver 的優劣就是  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/engine/userguide/storagedriver/overlayfs-driver/"&gt;Use the OverlayFS storage driver | Docker Documentation&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇官方文件則講述怎麼把 Storage Driver 設定成 &lt;code&gt;overlay&lt;/code&gt; 和 &lt;code&gt;overlay2&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;建議是能用 &lt;code&gt;overlay2&lt;/code&gt; 就別用 &lt;code&gt;overlay&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;也講了 &lt;code&gt;overlay&lt;/code&gt; 和 &lt;code&gt;overlay2&lt;/code&gt; 的運作原理，還有效能和限制方面的部份  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Docker#Storage_driver"&gt;Docker - ArchWiki&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/engine/userguide/storagedriver/overlayfs-driver/"&gt;Use the OverlayFS storage driver | Docker Documentation&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/engine/userguide/storagedriver/selectadriver/"&gt;Select a storage driver | Docker Documentation&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Docker"></category><category term="devicemapper"></category><category term="overlayFS"></category><category term="Arch Linux"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>《程序员修炼之道:从小工到专家》</title><link href="https://blog.m157q.tw/posts/2018/01/15/the-pragmatic-programmer-from-journeyman-to-master/" rel="alternate"></link><published>2018-01-18T23:46:05+08:00</published><updated>2018-01-18T23:46:05+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-15:posts/2018/01/15/the-pragmatic-programmer-from-journeyman-to-master/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這本也是很多人推薦的書，在 goodreads 有 4.31 的高分：&lt;a href="https://www.goodreads.com/book/show/4099.The_Pragmatic_Programmer"&gt;The Pragmatic Programmer: From Journeyman to Master by Andy Hunt&lt;/a&gt;，大學的時候就聽到身邊很多人讀完這本了，但我一直到最近才看完這本書，至少「看好書永遠不嫌晚」？以下就留個紀錄和想法吧。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;簡介&lt;/h2&gt;
&lt;p&gt;關於作者簡介與目錄的部份，可以參考天瓏書局的頁面：&lt;a href="https://www.tenlong.com.tw/products/9787121123368"&gt;天瓏網路書店-程序員修煉之道 ：從小工到專家 (The Pragmatic Programmer: From Journeyman to Master)&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;紀錄 &amp;amp;&amp;amp; 想法&lt;/h2&gt;
&lt;p&gt;看這本書的時候一直想到《人月神話》，主要是因為章節名稱的風格吧，都是比喻的方式，有點像是寓言故事風格的標題，所以讓人滿好記憶的。  &lt;/p&gt;
&lt;p&gt;這本書主要就是在教你如何寫出品質夠好的程式碼，包含了函式撰寫、演算法、效能、註解、測試、重構、基本工具、例外處理、如何根據需求寫出夠有彈性的程式碼...等等，透過比喻、 分類、圖例、實際程式碼來做說明。  &lt;/p&gt;
&lt;p&gt;第一次瀏覽的話我個人的建議是，在掃目錄裡面出現的大標題的時候，裏面都會有些小標題，大概掃過去就可以知道在講什麼。  &lt;/p&gt;
&lt;p&gt;大概有個概念以後可以再做比較詳細的瀏覽，如果有已經知道的部份就可以跳過啦，只看自己比較不知道的部份。大概就是 BFS 的閱讀方式，會有種由淺入深的感覺。  &lt;/p&gt;
&lt;p&gt;真的有在寫這種技術文就會發現，真的要足夠的實力才有辦法把這種實際上寫程式會遇到的問題抽象化成書中的比喻，甚至還對其做分類。也算是之後自己寫技術文的目標之一吧，能夠把實際上遇到的問題抽象化並歸納整理再清楚的描述出來，真的需要不少心力。  &lt;/p&gt;
&lt;p&gt;第八章算是把前面七章提到的東西整合起來，如果對整本書在講的東西沒有什麼概念，想用 top down approach 的方式閱讀的話，我建議可以先看第八章。因為這本書都會在內容附上跟哪個章節有關並告訴你頁碼，所以很好做 cross reference 方式的閱讀，看到不懂的再翻到前面看個詳細。  &lt;/p&gt;
&lt;p&gt;想要快速複習的人，可以翻到最後面的 Quick Refernce Guide，列出了 70 個書中的提示重點，也都有標頁碼。可以用來訓練自己看看能不能大概講出這個提示重點在講什麼，如果講不出來的話就可以快速翻到該重點那頁再重新看一遍。  &lt;/p&gt;
&lt;p&gt;工作以後看這本書，對於某些章節真的是頗有感觸的，這幾天應該會再多瀏覽這本書幾遍吧。這種夠有系統的分析寫程式這件事情，並列出需要注意的點讓程式碼的品質更好，才真的說得上是軟體工程啊，工程是需要有系統的。  &lt;/p&gt;</summary><category term="Programmer"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>《軟技能：代碼之外的生存指南》</title><link href="https://blog.m157q.tw/posts/2018/01/14/soft-skiils-the-software-developers-life-manual/" rel="alternate"></link><published>2018-01-18T21:10:34+08:00</published><updated>2018-01-18T21:10:34+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-14:posts/2018/01/14/soft-skiils-the-software-developers-life-manual/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這本書沒記錯的話應該是 2017 年的 PyCon TW 在天瓏書局的攤位買的，當下快速翻完的第一個想法是：  &lt;/p&gt;
&lt;p&gt;「這本書基本上把程式設計師所有可以注意的事都講完了，除了程式碼以外。」  &lt;/p&gt;
&lt;p&gt;中文翻譯的其實挺貼近書中內容的，反而英文書名看不太出來跟程式碼無關。  &lt;/p&gt;
&lt;p&gt;這本書在 goodreads 上的評價有點兩極就是：&lt;a href="https://www.goodreads.com/book/show/23232941-soft-skills"&gt;Soft Skills: The Software Developer's Life Manual by John Z. Sonmez&lt;/a&gt;，我猜有部份可能是跟內容沒有程式碼有關？但後來看到一半就大概瞭解另一部份的原因主要跟人的個性有關：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你是只想單純寫程式只求精進自己技術能力，其他什麼都不太想管的人的話，那我不推薦讀這本書，因為這本書基本上沒有講任何跟程式碼有關的內容，一行程式碼都沒有。  &lt;/li&gt;
&lt;li&gt;但如果你對職涯發展、自我行銷、更有效的學習、提升生產力、理財、健身、心態培養，這 7 項其中之一有興趣的話，我還滿推薦翻翻這本書的。  &lt;/li&gt;
&lt;li&gt;這 7 項就是這本書各篇的篇名，心態培養那篇其中一章的內容是講愛情，嗯，你沒看錯，教程式設計師談戀愛。如果你對這 7 項都有興趣的話，或許可以考慮買來看。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後這本書有點半自傳形式，所以不愛看自傳或是看這種書會覺得作者是在吹捧自己而心生厭惡的人，也不推薦看這本書。但我自己是覺得不一定要喜歡這本書全部的內容啦，像譯者在投資的部份就有兩三次吐嘈這本書的作者，沒把一些成本考量進去等等。XD  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;簡介&lt;/h2&gt;
&lt;p&gt;作者 John Z. Sonnmez 是 &lt;a href="https://simpleprogrammer.com/"&gt;Simple Programmer&lt;/a&gt; 這個網站的創始人，以前搜尋的時候偶爾會搜尋到這網站的東西，不只講程式碼，只要跟程式設計師有關的都會提。  &lt;/p&gt;
&lt;p&gt;詳細可以參考這本書在天瓏書局的網頁：&lt;a href="https://www.tenlong.com.tw/products/9787115429476"&gt;天瓏網路書店-軟技能代碼之外的生存指南 (Soft Skills : The software developer's life manual)&lt;/a&gt; ，這邊就不詳細列出了，直接進紀錄和心得。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;紀錄 &amp;amp;&amp;amp; 心得&lt;/h2&gt;
&lt;p&gt;這本書總共有 71 章，聽起來好像很多很恐怖，但整本書其實不到 400 頁，平均起來每章也不過 5~6 頁，所以閱讀起來其實滿輕鬆的，而且時間很好安排。作者有在書中提到會這樣分是因為方便自己寫作，如果一個章節的篇幅太長的話，他自己就會拖延不想寫。  &lt;/p&gt;
&lt;p&gt;身為一個拖延症患者，我目前真的覺得把事情切分的夠細這招真的滿好用的，不會讓人有起頭難的感覺，也因為事情切得夠細，所以完成不會花太多時間，也會有成就感，如果剛好進入 flow 的話，常常不知不覺就完成了。拖延症有個很常見的狀況就是「覺得事情太麻煩，所以一直抗拒開始。」但往往開始後才發覺其實沒自己想的那麼難，把事情切分的夠細對這狀況還滿有用的。而且會有種事情按照自己安排在走的感覺，很有成就感。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;工作&lt;/h3&gt;
&lt;p&gt;這本書的涵蓋範圍真的很廣，不知道是不是因為剛好待業中比較少碰程式碼，所以我覺得沒有程式碼對我來說沒啥差，再加上裡頭有提到面試相關的東西，剛好之後會用得上。第一章就是在講職業生涯的部份，也算是待業這陣子有在思考的部份，而且真的講的滿詳細的，滿多部份是我之前有想過但沒有想的這麼深的，少數則是我沒想過的觀點：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我以前其實沒有很在乎人際關係，但出社會工作以後真的意識到一個好的人際關係有時候可以讓事情變得簡單很多。  &lt;/li&gt;
&lt;li&gt;也有提到是要當員工、接案或創業的考量點。  &lt;/li&gt;
&lt;li&gt;區分自己是哪一類的程式設計師。  &lt;/li&gt;
&lt;li&gt;大、中、小型公司可能的狀況以及怎樣的人適合哪種規模的公司  &lt;/li&gt;
&lt;li&gt;當然也有提到履歷的部份  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;自我行銷&lt;/h3&gt;
&lt;p&gt;自我行銷的部份也講了很多，除了一般一定會提到的要有自己的部落格以外，還有提到滿多的：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;像是作者自己是如何透過 90% 作品免費然後靠剩下的 10% 來加減賺一些錢。  &lt;ul&gt;
&lt;li&gt;有點像是現在很多 Youtuber 在 PressPlay 或 Patreon 用的訂閱制模式。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透過演講、報告、培訓來訓練自己表達的能力也很重要  &lt;/li&gt;
&lt;li&gt;再來則是寫書建立自己的知名度  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;學習&lt;/h3&gt;
&lt;p&gt;學習的部份則是作者提了一個自己學習新東西的方式，我覺得比較受用的部份是學新東西的時候要確定自己得學會多少，否則很容易花了過多的時間卻沒什麼效果，這點算是我自己之前比較沒有意識到的部份，常常一股腦的就花了一堆時間，但往往查資料愈查越發散。  &lt;/p&gt;
&lt;p&gt;也有提到要找個適合的 mentor 以及當別人的 mentor，透過教學相長來讓自己的實力進步。最後則是提到要意識到自己知識上的弱點，意識到的話要花時間去理解它，而不是重複做相同的事。  &lt;/p&gt;
&lt;p&gt;比如常常看到某個特定的名詞就忘記是什麼意思，每次都一直去查，這時候可能就要花點時間來好好讓自己完整理解一下整個名詞的意思與脈絡，會比每次遇到都在查詢是什麼意思還來的省時間。  &lt;/p&gt;
&lt;p&gt;時常檢查自己的生活中是不是有些一再重複的行為，有的話可以花點時間想一下能不能解決它。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;生產力&lt;/h3&gt;
&lt;p&gt;生產力的部份我自己是覺得和《最有生產力的一年》及 Get Things Done 講得差不多。番茄鐘、定額工作法（每天固定做一點，積少成多，養成習慣）。  &lt;/p&gt;
&lt;p&gt;比較特別的是介紹了 KanbanFlow 這套工具，基本上是內建番茄鐘或計時器的 Trello，我自己是比較慣用計時器就是，因為我用番茄鐘常常都會第一個番茄鐘就進入狀況，結果進入第一次休息以後，我就被打斷，很難再開啟第二個番茄鐘了。  &lt;/p&gt;
&lt;p&gt;然後有講到習慣，我覺得跟《為什麼我們這樣生活，那樣工作？》講的也滿像的。  &lt;/p&gt;
&lt;p&gt;在善用時間的部份，有提到一心二用一定要是一個需要動腦加上一個不需要動腦的動作。例如：邊健身邊聽 podcast、邊開車邊聽有聲書、邊聽音樂邊寫文章。如果兩個動作都要動腦的話，就會兩個都做不好，例如：邊讀書邊聽 podcast、邊寫文章邊聽有聲書。  &lt;/p&gt;
&lt;p&gt;比較特別的是作者有提到職業倦怠的部份，也就是所謂的撞牆期。作者是講說遇到撞牆期的時候大多數人都會放棄（三分鐘熱度），但如果你能夠繼續撐下去，撐過這個撞牆期的話，興趣與熱情又會自然回來。  &lt;/p&gt;
&lt;p&gt;一開始不太能理解，覺得是在唬爛，就已經沒興趣了是要怎麼繼續撐下去，但想了一下其實學滿多東西都是這樣的，讓自己習慣不同的撞牆期的話，倦怠感就不會那麼嚴重了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;理財&lt;/h3&gt;
&lt;p&gt;其實待業這陣子也有在想要怎麼做到財富自由，畢竟為了工作而寫程式跟財富自由後自己想寫什麼程式就寫什麼程式還是有滿大的差別的。  &lt;/p&gt;
&lt;p&gt;以前都覺得自己不需要理財，真的出社會之後才意識到這件事有多重要，好的理財觀念可以讓自己之後的生活過的輕鬆些，也才有更多時間做自己想做的事，而不是為了錢而一直在工作。  &lt;/p&gt;
&lt;p&gt;作者有提到怎麼樣支配自己的薪水，以及對於負債的觀念要嚴格一些，否則很容易不小心錢就不夠用，遇到賺愈多花愈多還可能愈存愈少的狀況。  &lt;/p&gt;
&lt;p&gt;也有談到該怎麼談 offer，作者是說「先出價者輸」，但如果真的被問的話也要選擇不回答，然後試著反問對方大概會開多少，如果真的得回答的話，就給一個比較大的範圍。被問到上一份工作的薪水最好是巧妙的避開。收到 offer 的話，也有可能還有一次談價的空間。當然重點是要清楚自己大概值多少價錢，還有態度不可過於傲慢。  &lt;/p&gt;
&lt;p&gt;也有講到股票、期權、房地產的投資，然後講到了退休計劃，最後作者舉例講說自己怎麼做到 33 歲就退休達到財務自由的，過程其實也滿顛簸的，  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;健身&lt;/h3&gt;
&lt;p&gt;這部份基本上就大家耳熟能詳的東西：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;維持身體健康才能夠更有效率的做各種事情。  &lt;/li&gt;
&lt;li&gt;要計算自己每天攝取與消耗的熱量。  &lt;/li&gt;
&lt;li&gt;站著用電腦工作，比久坐健康。  &lt;/li&gt;
&lt;li&gt;用計步器  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比較特別的是想要有腹肌的話，重點不是做仰臥起坐，而是要想辦法降低體脂肪，很多人其實有六塊肌，只是因為體脂肪太多，所以看不到。  &lt;/p&gt;
&lt;p&gt;身體真的要健康才有本錢做更多事啊，再加上身材變好的話人也會比較有自信是真的。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;精神&lt;/h3&gt;
&lt;p&gt;最後在心態培養方面就比較心靈雞湯一點，主要就是要對自己保持自信與正面積極的態度，會在無形中對生活產生頗大的影響。  &lt;/p&gt;
&lt;p&gt;愛情方面的態度我覺得敘述得滿好的：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「你越是要追的話，人家就愈會遠離你。就像操場上追著別人要求一起玩的小孩一樣。」  &lt;/li&gt;
&lt;li&gt;「要用一種充滿自信且隨和的態度與人交往。」  &lt;/li&gt;
&lt;li&gt;「我自己覺得很好，我的生活不一定得有你，但我覺得你很有趣，所以我想更瞭解你。」  &lt;ul&gt;
&lt;li&gt;當然不會真的這樣說出口  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三秒鐘原則：如果你現在就想接近一個吸引你的人，不要遲疑，不要拖延，立刻行動。嘗試一下沒有什麼損失，頂多就是被拒絕而已。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者提供了一些自己覺得不錯的書推薦讀者閱讀，有空的話我可能會找來看。  &lt;/p&gt;
&lt;p&gt;最後一章「積極面對失敗」我覺得滿重要的，尤其台灣傳統的教育最忌諱小孩失敗，結果出社會一遇到失敗挫折的抵抗力非常低，很容易一蹶不振。最好是要不怕失敗，然後從每次失敗中反省自己並改進。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;一個不小心就寫的有點多，這本書過一陣子應該會再拿出來看看吧，我覺得讀完以後有讓我覺得人生好像比較有希望的感覺。  &lt;/p&gt;</summary><category term="soft skills"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>ZyXEL WAH7706 問題紀錄</title><link href="https://blog.m157q.tw/posts/2018/01/13/zyxel-wah7706/" rel="alternate"></link><published>2018-01-13T21:52:00+08:00</published><updated>2018-01-13T21:52:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-13:posts/2018/01/13/zyxel-wah7706/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在這篇 &lt;a href="/posts/2017/12/20/4g-mobile-network-tw/"&gt;關於 4G 行動網路的一些筆記 | Just for noting&lt;/a&gt; 有提到我買了一個攜帶型 4G 網路分享器，我買的就是 ZyXEL 的 WAH7706。  &lt;/p&gt;
&lt;p&gt;其實當時是在 NetGear AirCard 790S, ZyXEL WAH7706, D-Link DWR-933 這三台都有 2CA 的在比較：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雖然 AirCard 790S 便宜很多，也支援 2CA，但因為當時急著用，如果要用露天買的話要等上幾天，再加上 NetGear 在台灣的代理商沒有代理這個產品，所以都是有人改水貨來賣，然後簡訊又不一定有中文支援，所以就沒考慮，畢竟有時候還是得靠簡訊來知道電信商那邊的通知訊息。  &lt;/li&gt;
&lt;li&gt;D-Link DWR-933 和 WAH7706 我在 PChome 上看的價錢都是 4000 左右。  &lt;ul&gt;
&lt;li&gt;DWR-933 號稱續航 12 小時，比 WAH7706 號稱續航 10 小時多了 2 小時  &lt;/li&gt;
&lt;li&gt;在頻段支援的部份比 WAH7706 少了 Band 38 和  Band 40  的部份  &lt;/li&gt;
&lt;li&gt;能支援最多 16 個裝置連線，WAH7706 則是 32 個。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以最後選了 ZyXEL WAH7706。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;p&gt;使用後遇到了一些問題，查了一下竟然是用台灣大哥大的 SIM 卡才會遇到，打電話去合勤詢問後，客服要我寄封電子郵件描述狀況，工程師魂發作了一下，所以寄了一封描述算詳盡的的電子郵件過去，：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="report-1" src="/files/zyxel-wah7706/report-1.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="report-2" src="/files/zyxel-wah7706/report-2.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;最後就是換貨處理。  &lt;/p&gt;
&lt;p&gt;想說就用這篇文章紀錄下來，給自己留個紀錄，也給之後有遇到這個問題的人可以在網路上查到，因為我自己查的時候只有找到幾個人有提到這問題。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;完整紀錄&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;這邊先附上您要的「電信業者 SIM 卡接入 WAH7706 無法收到訊號的網頁介面及 OLED 介面圖示」&lt;br /&gt;
網頁介面圖示【附 1】、OLED 介面圖示【附 2】&lt;br /&gt;
&lt;img alt="attach-1" src="/files/zyxel-wah7706/attach-1.jpg" /&gt;&lt;br /&gt;
&lt;img alt="attach-2" src="/files/zyxel-wah7706/attach-2.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;另外補充一下，我在電話中講錯了，我掛完電話後再次確認才發現，我出問題的韌體版本是 V1.00 (ABBC.6) C0。但不影響本次的回報，因為我後來有把韌體升級到最新的 V1.00 (ABBC.8) C0，依然沒有解決這問題【附 3】。&lt;br /&gt;
&lt;img alt="attach-3" src="/files/zyxel-wah7706/attach-3.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;以下我試著完整描述使用情況，以儘可能協助釐清產品問題。  &lt;/p&gt;
&lt;p&gt;我在 2017/12/14 於 PCHome 網購貴公司的 WAH7706【附 4】，並於 2017/12/15 開始搭配台灣大哥大的 4G SIM 卡使用，購買之前就有確認 WAH7706 支援台灣大哥大的 4G 頻段 B3, B28，使用狀況一切良好。&lt;br /&gt;
&lt;img alt="attach-4" src="/files/zyxel-wah7706/attach-4.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;直到 2017/12/18 晚上，發現 WAH7706 接收不到台灣大哥大的訊號，OLED 介面顯示 No Service【附 2】。截至此時，總使用流量約為 41 GB。無論 Reboot 或是 Reset WAH7706 都無法解決此問題。&lt;br /&gt;
&lt;img alt="attach-2" src="/files/zyxel-wah7706/attach-2.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;為了確認台灣大哥大的 4G SIM 卡是沒有被鎖卡的，我把台灣大哥大的 4G SIM 卡裝入 iPhone SE，確認是可以收到 4G 訊號且可以正常上網的。（今天透過電話回報完後也有再次確認，請見【附 5】)&lt;br /&gt;
&lt;img alt="attach-5" src="/files/zyxel-wah7706/attach-5.png" /&gt;  &lt;/p&gt;
&lt;p&gt;之後又為了確認 WAH7706 仍然可以正常收發 4G 訊號並連接網路，我把中華電信的 4G SIM 卡裝入 WAH7706，也確實可以正常運作。（今天透過電話回報完後也有再次確認，請見【附 6】)&lt;br /&gt;
&lt;img alt="attach-6" src="/files/zyxel-wah7706/attach-6.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;其後我又將台灣大哥大的 4G SIM 卡裝回 WAH7706 ，透過網頁後台做了一些嘗試，但都無效（截圖都是今天早上電話回報完後使用新版韌體的結果）。  &lt;/p&gt;
&lt;p&gt;一、把「蜂巢式網路模式」調成「自動」，有兩種狀況：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;依然接受不到 4G 訊號且大多數時間不會自動向下相容使用 3G 訊號。【附 7】&lt;br /&gt;
&lt;img alt="attach-7" src="/files/zyxel-wah7706/attach-7.jpg" /&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;少數時間會自動改成使用 3G 網路，雖然顯示是接收得到 3G 訊號的，但卻無法連線至網路。(左上角第 3 個連接網路圖示是斷開的。）【附 8】&lt;br /&gt;
&lt;img alt="attach-8" src="/files/zyxel-wah7706/attach-8.jpg" /&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、將「蜂巢式網路模式」調成「3G  模式」，則有較高機會連上網路【附 9】，但有時候還是會有接收得到 3G 訊號卻無法連線的狀況。【附 10】&lt;br /&gt;
&lt;img alt="attach-9" src="/files/zyxel-wah7706/attach-9.jpg" /&gt;&lt;br /&gt;
&lt;img alt="attach-10" src="/files/zyxel-wah7706/attach-10.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;便於今天早上透過電話回報此問題，其後我也有打電話向台灣大哥大確認我使用的 4G SIM 卡是沒有被鎖卡的。且有進一步詢問是否可能同一張 SIM 卡但針對不同裝置進行限制，得到的答案是「沒有，沒有這樣的機制，只會直接鎖卡。」  &lt;/p&gt;
&lt;p&gt;另外在網路上也有找到其他使用貴公司 WAH7706 搭配台灣大哥大 4G SIM 卡的使用者遇到一樣的問題，附上連結供參考。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.ptt.cc/bbs/MobileComm/M.1469287236.A.E7C.html"&gt;[問題] WAH7706 使用上的疑問&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ptt.cc/bbs/MobileComm/M.1476361987.A.072.html"&gt;Re: [問題] WAH7706 使用上的疑問&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dcard.tw/f/3c/p/225104974"&gt;#求救 #ZYXEL WAH7706 陣亡&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再麻煩貴公司相關人員協助處理了，感謝。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;結果&lt;/h2&gt;
&lt;p&gt;在 2017/12/28 下午到 ZyXEL 代理商展碁國際在台北的據點換貨之後，一回去馬上先把韌體升級到最新版才開始使用，目前使用到今天大概兩個多禮拜都還正常，如果之後又遇到問題的話會再更新在這篇文章，畢竟有遇到有人是用了超過一個月才出問題的。  &lt;/p&gt;</summary><category term="ZyXEL"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>整理一些跟面試相關的文章</title><link href="https://blog.m157q.tw/posts/2018/01/12/articles-related-to-interview/" rel="alternate"></link><published>2018-01-12T22:50:58+08:00</published><updated>2018-01-12T22:50:58+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-12:posts/2018/01/12/articles-related-to-interview/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;2015 年底開始找正職工作的時候，就覺得自己對面試這件事實在不拿手，也沒有什麼信心。畢竟學校也沒教，然後自己之前在學校裏面做些跟寫程式相關的工作也都不算有太嚴格的面試，大多都是認識的人問我有沒有興趣就做了。  &lt;/p&gt;
&lt;p&gt;當時唯二兩個有面試的工作裡頭，其中一個是要處理網路設備相關的工作，問了我 C/C++ 的問題，我當時啥都沒準備，答得超爛，就不了了之。另外一個則是系上計算機中心的助教，但這嚴格說起來不算是很難的面試，因為考試內容基本上就是上學期學的計算機系統管理，以及下學期學的計算機網路管理。我在這兩門課都拿到不錯的分數，沒記錯的話應該是 97 和 99 吧 ，因為學得很有興趣，就被問問有沒有興趣當助教。所以考試的題目基本上都是學過的東西，面試官也都是修課時看了一年的助教，沒有什麼太強烈的緊張感。  &lt;/p&gt;
&lt;p&gt;2016 年 1 月 21 日，人生第 1 份 出社會的工作正式上工以後，一直到 2017 年 12 月 1 日正式離職，在這期間雖然沒有參加任何面試，但也看到了滿多不錯的面試文章。大概在 2016 年 9 月左右，開始覺得自己好像應該把這些不錯的面試文章蒐集起來，並紀錄一下自己當時看完的心得，以供自己日後面試時可以參考複習。往後期間都只有簡短紀錄在 Trello 中，一直沒有花時間整理成一篇文章。剛好利用這段離職後比較閒暇的時間來好好整理一下，後續會紀錄在 &lt;a href="https://github.com/M157q/m157q.github.io/issues?q=is%3Aopen+is%3Aissue+label%3Ainterview"&gt;Issues · M157q/m157q.github.io · GitHub&lt;/a&gt;，如果沒忘記的話也會更新在這篇文章就是。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;內文&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.rowkey.me/blog/2015/12/31/dev-job-talk/"&gt;研发招聘之殇 - 后端技术杂谈 | 飒然Hang&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;算是作者面試許多人後給出的意見，我覺得滿中肯的。  &lt;/li&gt;
&lt;li&gt;因為有面試剛畢業的學生，所以也有點出了中國那邊學生的狀況，基本上跟台灣這邊提到的差不多：  &lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;技术脱离业界前沿  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;基础素质欠缺  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;没有畏惧心  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;知其然不知其所以然  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提出了中國那邊常見的面試型態：  &lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;N轮算法题目面试  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;掺杂计算机基础知识、算法以及项目经验的面试  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;软件设计  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;现场结对编程/ppt讲解  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;只看学历、学校。这种面试方式  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;群面  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;也提出了自己對於優秀的工程師或技術人員所預期的特質：  &lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;聪明、思维灵活  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;对技术有热情  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;基础知识扎实  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;有执行力  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ptt.cc/bbs/Soft_Job/M.1473255742.A.ED5.html"&gt;[心得] 台北多家面試心得 - 看板 Soft_Job - 批踢踢實業坊&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這個主要是夠多家（18 間），而且有不少算有一點名氣的新創公司的資訊。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://thecodist.com/article/phone-interviews-can-be-so-painful-to-do"&gt;The Codist: Phone Interviews Can Be So Painful To Do&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇是在講作者透過 Phone interview 面試人的經驗。  &lt;/li&gt;
&lt;li&gt;怨念超深，作者目前是迪士尼公司的 Lead iOS engineer，抱怨一堆來面試的人連一些很基本的問題都答不出來。  &lt;/li&gt;
&lt;li&gt;可以拿來引以為戒。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ptt.cc/bbs/Tech_Job/M.1473663935.A.177.html"&gt;[面試] 研替心得分享及請益-下 (晨星) - 看板 Tech_Job - 批踢踢實業坊&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;算是竹科的公司普遍的面試流程。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@jhihsianwu/%E9%97%9C%E6%96%BC%E8%BE%AD%E8%81%B7-%E8%BD%89%E8%A1%8C-%E6%80%9D%E8%80%83-%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB-c8c26319d25b"&gt;關於辭職、轉行、思考｜文章分享 – Jhih-Sian Wu – Medium&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇嚴格說起來不太算面試相關，不過我覺得跟思考自己的職涯有關，所以其實也滿適合整理在這的。  &lt;/li&gt;
&lt;li&gt;作者整理了滿多相關的文章，很適合給我這種離職完後的人好好想想，提到了一些我沒有想到的觀點或面向。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/hulis-blog/interview-prepare-b815d938f0de"&gt;面試問答準備心得之考前猜題 – Huli’s blog – Medium&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇真的整理的很完整，基本上把面試會提到的問題大概都列出來了。  &lt;/li&gt;
&lt;li&gt;很適合在面試前，自己花時間把這些都好好在腦中演練一下，我覺得會滿有幫助的。  &lt;/li&gt;
&lt;li&gt;如果能用英文演練的話更好。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/hulis-blog/stripe-and-i-df35a6f0a799"&gt;我與 Stripe ：一段愛與夢想的故事 – Huli’s blog – Medium&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;作者過了好幾關，而且把細節描述的非常詳細，過程中也瞭解到：真的很喜歡一間公司的話到底會為面試準備到什麼程度  &lt;/li&gt;
&lt;li&gt;自己可以拿來好好學習一下&amp;lt;但想不到最後竟然是因為聯絡延宕過久而去了另一間公司，現實生活中的事情總是這樣充滿變數和難以預料啊。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@Doppler/2017-front-end-%E5%8F%8A-ui-designer-%E9%9D%A2%E8%A9%A6%E7%B4%80%E9%8C%84-bdef59188916"&gt;2017 Front-End 及 UI Designer 面試紀錄 – Doppler Kuo – Medium&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇也紀錄的很詳細，雖然我自己應該是不會面試 Web Front-End 和 UI Designer 相關的工作，但還是很值得參考。  &lt;/li&gt;
&lt;li&gt;面試了 15 間公司，大多數都是偏叫得出名字的新創，但也有大公司。  &lt;/li&gt;
&lt;li&gt;雖然結果好像沒有很亮眼，但每次看到這種面試了很多間的我還是會挺敬佩的就是。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://crossing.cw.com.tw/blogTopic.action?id=568&amp;amp;nid=8891"&gt;「最後，你有沒有問題想問我們？」──跨國企業面試官，教你7大面試提問法 ｜ 何則文／香蕉夢想家 ｜ 換日線 Crossing&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;滿實用的一篇文章，以前面試完被問到這個都有點不太知道要問什麼，剛好近期又要開始面試了，可以好好想一下裏面的問題。  &lt;/li&gt;
&lt;li&gt;不過感覺這篇比較偏向外商的公司可以問的，像底下還是有人提到以前有問過一樣的問題，但因為被面試官覺得太直接而被迴避掉或被直接反問的。但剛好之後的目標應該主要也是鎖定國外的公司，所以應該遇到這個狀況的可能性會比較低一點。  &lt;/li&gt;
&lt;li&gt;這邊節錄一下 7 個問題：  &lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;一、「請問這個職缺是怎麼產生的？」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;二、「您喜歡這家公司嗎？為什麼？」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;三、「就我的理解，公司目前在業界的情況、主要競爭對手，我的理解是不是正確的？」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;四、「您認為公司在業界中，最大的競爭優勢是什麼？」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;五、「您認為這個職缺需要的核心能力是什麼？希望具備什麼特質？」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;六、「如果我最後沒能進入貴公司，最大的因素是？您認為我哪方面需要再加強？」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;七、「詢問姓名、職稱與聯絡方式」  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;剛好在上一份工作離職前，得到了第一次面試別人的機會，面試完後的感想紀錄在此：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面試時不要不懂裝懂，真的會讓懂得人不知道該擺出甚麼表情。  &lt;/li&gt;
&lt;li&gt;講不知道後再根據自己已知的事物聯想提問，跟一知半解得胡亂猜測單純找話講，觀感天差地遠。  &lt;/li&gt;
&lt;li&gt;上禮拜面試人的感想，近期自己可能也要去面試，順便用來自省。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Interview"></category><category term="Job"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>中國網路相關筆記</title><link href="https://blog.m157q.tw/posts/2018/01/11/dealing-with-china-network/" rel="alternate"></link><published>2018-01-11T16:00:26+08:00</published><updated>2018-01-11T16:00:26+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-11:posts/2018/01/11/dealing-with-china-network/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;2016 年 8 月緊急接到要支援客戶在中國的服務，但我們現有的 infrastructure 都是在台灣，又不可能在短時間內全部搬到中國的雲服務商那，所以就用上了各種 workaround，最後算是得到了一個還可以接受的結果，雖然不盡理想就是。  &lt;/p&gt;
&lt;p&gt;當時實在是忙到沒啥時間紀錄，最近比較有空了，用這篇文章留個紀錄一下。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;一些可以用來輔助的網站&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.greatfire.org/analyzer"&gt;https://en.greatfire.org/analyzer&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;TEST URL 可以讓你檢查某個網址在中國是不是被禁止的  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.17ce.com/"&gt;https://www.17ce.com/&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;可以用來檢查中國大部份地區以及少數國外地區連到某個網站的狀況  &lt;/li&gt;
&lt;li&gt;我後來有寫個爬蟲專門爬這網站的結果，每個小時去檢查連到某個網址的狀況。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ping.chinaz.com/"&gt;http://ping.chinaz.com/&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;可以用來檢查中國大部份地區以及少數國外地區連到某個網站的狀況  &lt;/li&gt;
&lt;li&gt;我後來有寫個爬蟲專門爬這網站的結果，每個小時去檢查連到某個網址的狀況。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.speedtest.cn/"&gt;http://www.speedtest.cn/&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;中國的 SpeedTest  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.webkaka.com/"&gt;http://www.webkaka.com/&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一樣是中國大部份地區連到某個網址的狀況，但伺服器的站點數量沒有很多，有些省分沒有。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tools.cloudxns.net/"&gt;http://tools.cloudxns.net/&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;有一系列的工具可以使用，主要都是跟 DNS 比較相關。  &lt;/li&gt;
&lt;li&gt;當時是用來查合作伙伴的伺服器到底有沒有指到中國內的伺服器用的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hidemyass.com/proxy"&gt;https://www.hidemyass.com/proxy&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;免費的 web proxy，當時用來檢測中國國內某個地方是否可以成功存取我們的資源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm"&gt;https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;免費的 chrome plugin，當時用來檢測中國國內某個地方是否可以成功存取我們的資源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.gdaily.org/8170/free-proxy-google-china-japan-usa"&gt;https://www.gdaily.org/8170/free-proxy-google-china-japan-usa&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;整理了一些免費的 proxy 資源，主要是 proxy 到牆內用。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://proxy.moo.jp/zh/?c=CN&amp;amp;pt=&amp;amp;pr=&amp;amp;a%5B%5D=0&amp;amp;a%5B%5D=1&amp;amp;a%5B%5D=2&amp;amp;u=0"&gt;http://proxy.moo.jp/zh/?c=CN&amp;amp;pt=&amp;amp;pr=&amp;amp;a%5B%5D=0&amp;amp;a%5B%5D=1&amp;amp;a%5B%5D=2&amp;amp;u=0&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;列出了有哪些免費的 proxy 位址可供使用。  &lt;/li&gt;
&lt;li&gt;但很常變動，常常要換就是。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ipcn.chacuo.net/"&gt;http://ipcn.chacuo.net/&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;列出中國 IP 對應到哪個電信商及省分的列表  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當然使用免費的 proxy 就要記得不要在網站上輸入啥私密資料了，畢竟很有可能會被錄封包。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;狀況&lt;/h2&gt;
&lt;p&gt;因為現有的服務使用 Google Cloud Platform，伺服器在美國，客戶在中國的網站直接嵌入我們原本提供的 JavaScript 會被中國的防火長城擋掉，導致客戶的網站上看到錯誤，或是要等很久才能載入，等於現有的服務無法提供使用。除了短時間內無法搬到中國的雲服務商上面以外，老闆也不太希望這麼做，一方面是時間上的壓力，一方面是費用的問題，所以還是希望能夠儘量用現有的服務，如果不能全部搬過去也沒差，只要有辦法得到的一個能接受的結果就好。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;歷程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因為連不到放在美國伺服器上的 JavaScript，所以得把目前在用的 JavaScript 放一份到中國雲服務商上，最好還要有 CDN。  &lt;ul&gt;
&lt;li&gt;原本有想說要比較中國各服務商例如：青雲、阿里雲、騰訊雲等等，哪些比較好用。但後來因為公司以前有陣子有用阿里雲的服務，所以有帳號，加上時間很趕，所以就直接使用阿里雲了。  &lt;/li&gt;
&lt;li&gt;把公司自己的 JavaScript 複製到阿里雲上之後，可以成功連到了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但使用的 Google Tag Manager 要載入的 gtm.js 在有些狀況仍然連不到，但有時候卻連得到。  &lt;ul&gt;
&lt;li&gt;這部份除非不用 Google Tag Manager，不然基本上沒有什麼太好的解法。  &lt;/li&gt;
&lt;li&gt;遇到的時候有去找中國有沒有類似 Google Tag Manager 的服務，但找不太到。  &lt;/li&gt;
&lt;li&gt;加上公司使用 Google Tag Manager 有弄出自己的一套架構，所以要搬也沒那麼好搬。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;就想說能不能幫 gtm.js 弄個 proxy。  &lt;ul&gt;
&lt;li&gt;有找到這個：&lt;a href="http://www.ajax-cross-origin.com/"&gt;Ajax Cross Origin - jQuery plugin&lt;/a&gt;，實際也有架起來。  &lt;/li&gt;
&lt;li&gt;但後來才想到這樣根本行不通，因為 gtm.js 會紀錄使用者的行為，架了一個 proxy 的話就會被擋住。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到此已經放棄讓所有使用者都載入 gtm.js 了，轉而變成「讓可以載入的使用者載入，無法載入的就不要載入，而且不能顯示有錯誤。」因為客戶要求不能在連到他們的網站時在瀏覽器的 console 中看到任何錯誤。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;於是轉而想說能不能做到「如果嘗試載入 JavaScript 一段時間後不成功的話就停止載入。」  &lt;ul&gt;
&lt;li&gt;有找到 StackOverflow 上的這篇： &lt;a href="https://stackoverflow.com/questions/5642270/load-a-javascript-file-but-cancel-if-it-takes-too-long"&gt;browser - Load a Javascript file, but cancel if it takes too long? - Stack Overflow&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;試了一下發現無法成功。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最後自己想出了一個折衷的辦法，但非常的土炮。  &lt;ul&gt;
&lt;li&gt;我在阿里雲上開了台虛擬機，用 Django 架了個伺服器。  &lt;/li&gt;
&lt;li&gt;寫了個 crawler 每小時固定去爬上面提到的 &lt;a href="https://www.17ce.com/"&gt;https://www.17ce.com/&lt;/a&gt; 和 &lt;a href="http://ping.chinaz.com/"&gt;http://ping.chinaz.com/&lt;/a&gt; ，把他們有沒有辦法載入 gtm.js 的結果紀錄起來。  &lt;ul&gt;
&lt;li&gt;其結果會包含省分、電信商及其能不能載入。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;另外一個 crawler 則是去爬 &lt;a href="http://ipcn.chacuo.net/"&gt;http://ipcn.chacuo.net/&lt;/a&gt;，把所有 IP 對應到的省分和電信商紀錄下來，每天會更新一次。  &lt;/li&gt;
&lt;li&gt;最後在使用者瀏覽客戶的網站要嘗試載入 gtm.js 之前，會先去問我用 Django 架起來的伺服器，會把使用者的 IP 當參數送過來。  &lt;/li&gt;
&lt;li&gt;伺服器收到使用者的 IP 後，先去拿到其所屬的省分和電信商，再去檢查最近一個小時的結果是否能夠載入，如果可以載入的話，API 就會回傳 true 回去，不行的話就回傳 false，當然都是包成 JSON 回傳回去。  &lt;/li&gt;
&lt;li&gt;伺服器同時也會把來詢問的結果紀錄到資料庫裡頭，以供日後查詢統計用。最後發現平均能夠載入載入的比例大概是四成左右而已，雖然少的可憐，但至少是可以接受的結果。  &lt;/li&gt;
&lt;li&gt;是說這個 Django 專案也算是我第一個完全自己獨力完成的，也學到了不少東西。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;最後整件事情弄完的結論就是：如果原本沒有做中國的服務然後哪天要做中國的服務的話，絕對不要堅持用現有的服務來用，除非確定完全可以動。不然就會出現各種奇怪的狀況，需要各種不同的 workaround 來解，真的會很累。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ajax-cross-origin.com/install.html"&gt;Ajax Cross Origin - jQuery plugin&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://webmasters.stackexchange.com/questions/81878/google-tag-manager-blocked-in-china"&gt;Google Tag Manager blocked in China..? - Webmasters Stack Exchange&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/5642270/load-a-javascript-file-but-cancel-if-it-takes-too-long"&gt;browser - Load a Javascript file, but cancel if it takes too long? - Stack Overflow&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="China"></category><category term="Network"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>Docker + Travis CI + Kubernetes + GKE</title><link href="https://blog.m157q.tw/posts/2018/01/10/docker-travis-ci-kubernetes-gke/" rel="alternate"></link><published>2018-01-11T17:01:19+08:00</published><updated>2018-01-11T17:01:19+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-10:posts/2018/01/10/docker-travis-ci-kubernetes-gke/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這篇是 2016 年 6 月時的紀錄，當時剛接觸 Docker 和 Kubernetes 4 個月左右，在把舊的服務根據性質拆分成 3 個不同的 mircro serverices，想要做到讓 Travis CI 在跑完測試後，自動 build Docker image，再把 image 丟到 Google Cloud Platform 上，讓 GKE 使用。  &lt;/p&gt;
&lt;p&gt;當時還沒有 Google Cloud Builder 可以使用，所以在找尋解法的時候看到果然有人已經這麼做了。以下就來紀錄一下方法。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;學 Kubernetes 的時候找到了這簡短的文章：&lt;a href="https://chengl.com/orchestrating-docker-with-kubernetes/"&gt;Orchestrating Docker with Kubernetes&lt;/a&gt;，覺得可以讓剛上手的人快速瞭解。  &lt;/p&gt;
&lt;p&gt;至於透過 Travis CI 自動 build image  的部份，照著這篇文章做的確有成功：&lt;a href="https://chengl.com/docker-workflow/"&gt;Docker Workflow&lt;/a&gt;（其實看這篇文章的 &lt;code&gt;.travis.yml&lt;/code&gt; 就可以瞭解整個梗概了），但發現效果不盡理想，儘管已經拆分成 base image 和 production image，在每次 build image 的時候節省掉 build base image 的時間了，但花的時間還是太久。  &lt;/p&gt;
&lt;p&gt;當時因為被抓去做其他事，這部份就只弄到這裡，我覺得滿可惜的，後來大家都還是在 local build image 然後再透過 Makefile 把指令包裝起來，在 local 這邊透過 kubectl 把 image push 到 GCP。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;後續&lt;/h2&gt;
&lt;p&gt;當時過了幾個月後，在 2016 年 9 月看到這篇文章：&lt;a href="https://blog.wu-boy.com/2016/09/docker-cache-on-travis/"&gt;在 Travis 實現 Docker Cache | 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY&lt;/a&gt;，才發現原來有這樣的解法可以用。  &lt;/p&gt;
&lt;p&gt;後來發現也有很多人遇到一樣的問題，後來也大多是用 &lt;code&gt;docker save&lt;/code&gt;, &lt;code&gt;docker load&lt;/code&gt; 解決:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://giorgos.sealabs.net/docker-cache-on-travis-and-docker-112.html"&gt;Docker cache on Travis and Docker 1.12 // Read at G's // A personal blog from Giorgos Logiotatidis.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/travis-ci/travis-ci/issues/5358"&gt;Caching Docker Images on Build · Issue #5358 · travis-ci/travis-ci · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://atodorov.org/blog/2017/08/07/faster-travis-ci-tests-with-docker-cache/"&gt;Faster Travis CI tests with Docker cache&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/35305492/cache-docker-images-on-travis-ci"&gt;performance - Cache docker images on Travis CI - Stack Overflow&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://chengl.com/orchestrating-docker-with-kubernetes/"&gt;Orchestrating Docker with Kubernetes&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://chengl.com/docker-workflow/"&gt;Docker Workflow&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.wu-boy.com/2016/09/docker-cache-on-travis/"&gt;在 Travis 實現 Docker Cache | 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Docker"></category><category term="Kubernetes"></category><category term="Travis CI"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>我平常在電腦上用了哪些程式</title><link href="https://blog.m157q.tw/posts/2018/01/09/tools-i-use/" rel="alternate"></link><published>2018-01-26T03:26:55+08:00</published><updated>2018-01-26T03:26:55+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-09:posts/2018/01/09/tools-i-use/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;身為一個懶人，不喜歡做重複的事情，所以愛寫程式來把重複的事情解決掉，也因為這樣，所以很常用一些工具來幫助自己節省時間，以提高自己的生產力。  &lt;/p&gt;
&lt;p&gt;想說利用待業這段比較有空的時間，拿這篇文章來詳細紀錄一下自己目前到底用了哪些工具，留個紀錄，之後也可以用來追蹤比較，看看自己之後換了工具的原因，以及是不是真的有比較好。也有可能會變成歷史文，見證什麼時代的眼淚之類的吧（？）  &lt;/p&gt;
&lt;p&gt;身為一個寫程式的阿宅，平常都是用電腦居多，所以這篇只會以電腦用到的部份為主。格式分類參考自一年多前看到的這篇文章：&lt;a href="https://medium.com/hungys-blog/my-software-stack-2a406c1c57c1"&gt;My Software Stack – Hungys.blog() – Medium&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;OS &amp;amp; VM &amp;amp; VPS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.archlinux.org/"&gt;Arch Linux&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;從 2012 年用到現在，算一算也有個 5~6 年了，真的覺得是個很棒的作業系統。（在這之前是使用 Ubuntu。）  &lt;/li&gt;
&lt;li&gt;預設乾乾淨淨，想要裝什麼都自己決定，可以用 pre-compiled package 也可以自己編譯，自訂性挺高的。  &lt;/li&gt;
&lt;li&gt;最棒的還是 Rolling Update 的特性，遇到一些安全性的更新都可以馬上更新，雖然剛開始用的時候會遇到升上去就爛掉的問題，但這幾年已經很少遇到了。  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.m157q.tw/posts/2015/09/10/install-arch-linux-on-macbook-air-mid-2013/"&gt;2015 年 9 月後，直接把 Arch Linux 安裝在 MacBook Air Mid 2013 上使用。&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.virtualbox.org/"&gt;Virtual Box&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;也是個用了很久的 Virtual Machine Manager，支援 Linux 使用，但近幾年開始使用 VPS 之後就沒那麼常用了。  &lt;/li&gt;
&lt;li&gt;以前在使用的時候有遇到些問題，分別寫了幾篇文章紀錄：  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.m157q.tw/posts/2014/12/04/boot-liveusb-in-virtualbox-4-3-18/"&gt;Boot LiveUSB in VirtualBox 4.3.18 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.m157q.tw/posts/2014/11/10/virtualbox-guest-additions-upgrade-install_x11_startup_app-no-script-given/"&gt;VirtualBox Guest additions upgrade: install_x11_startup_app: no script given | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.m157q.tw/posts/2014/10/16/solution-for-the-failure-to-attach-usb-device-in-virtualbox/"&gt;Solution for the Failure to Attach USB Device in VirtualBox | Just for noting&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇不知道為什麼流量莫名的高，可能很多人都有遇到這問題？  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kali.org/"&gt;Kali Linux&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;從它以前還叫作 &lt;a href="https://backtrack-linux.org/"&gt;BackTrack Linux&lt;/a&gt; 的時候就有在用了。  &lt;/li&gt;
&lt;li&gt;大學有陣子在碰資安相關的東西，所以會拿來做一些資訊安全相關的測試，最近幾年也比較少用了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.digitalocean.com/"&gt;Digital Ocean&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;大概 2015 年開始使用的，但真正開始使用是在工作後，因為在學校沒主機了，所以就租個 VPS 來用，每個月 10 美金，算滿夠用的。  &lt;/li&gt;
&lt;li&gt;雖然貌似比 Linode, Vultr 還貴，但使用上也沒啥太大的問題，所以也懶得換了就是。  &lt;ul&gt;
&lt;li&gt;結果才過沒幾天，2018/01/17 Digital Ocean 就推出了新方案，一個月 10 美金變成有 2 GB RAM, 1 vCPU, 50 GB SSD, 2TB Bandwidth，直接變得比 Linode 和 Vultr 還便宜了：&lt;a href="https://blog.digitalocean.com/new-droplet-plans/"&gt;Kicking Off the New Year with New Droplet Plans&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;這間公司的文件都寫得滿用心的，因為有專門聘請寫手來寫，滿推薦的。  &lt;/li&gt;
&lt;li&gt;拿來放些自動化的程式，例如：  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/M157q/ad375e227ec0f1ba450915df65433473"&gt;批踢踢每天定時登入&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/M157q_News_RSS"&gt;一個每小時爬 RSS feed 然後發 Tweet 的 Twitter Bot&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;之前寫&lt;a href="https://github.com/M157q/ptt_statistics"&gt;批踢踢網頁版爬蟲&lt;/a&gt;時有放在上面跑  &lt;/li&gt;
&lt;li&gt;之前找租屋處的時候，寫了一個 &lt;a href="https://github.com/M157q/5g1"&gt;591 租屋網的爬蟲&lt;/a&gt;也有放在上面跑。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://parsecgaming.com"&gt;Parsec&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;最近幾天才開始使用的 Cloud Gaming service，確定可以在上面直接用 Steam 玩遊戲，Linux 也可以使用。  &lt;/li&gt;
&lt;li&gt;可以讓你像 Steam In-Home 一樣設定自己的主機，也可以直接讓你租 AWS 或 Paperspace 的 GPU 主機來用，費用我覺得算 OK，依照分鐘收費。  &lt;/li&gt;
&lt;li&gt;租用雲端主機適合沒辦法或沒錢或沒地方或不想組 Windows 遊戲主機的人使用，但網路速度要夠快，不然 latency 可能會有點高。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Editors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.vim.org/"&gt;Vim&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;大概從 2008 年開始用到現在，赫然發現也快 10 年了。  &lt;/li&gt;
&lt;li&gt;搭配 &lt;code&gt;Vundle&lt;/code&gt; 來安裝 Plugin，詳細的設定可以參考這個設定：&lt;a href="https://github.com/M157q/dotfiles/blob/master/vimrc#L95-L179"&gt;https://github.com/M157q/dotfiles/blob/master/vimrc#L95-L179&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://atom.io/"&gt;Atom&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;Open Source 的 Text editor，有時候會開來用。  &lt;/li&gt;
&lt;li&gt;有滿多的 plugin 可以裝的，但我沒有裝。之前最有名的應該是 &lt;a href="https://atom.io/packages/activate-power-mode"&gt;activate-power-mode 這個 plugin&lt;/a&gt; 吧  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://code.visualstudio.com/"&gt;Visual Studio Code&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Microsoft/vscode"&gt;https://github.com/Microsoft/vscode&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;微軟出的 Open Source edtior，有時候會開來用。  &lt;/li&gt;
&lt;li&gt;基本上我覺得是抄 atom 的就是，但有多出更多功能。  &lt;/li&gt;
&lt;li&gt;有一個我最喜歡的功能是可以在 editor 裡頭直接開 terminal 來用，我覺得很方便，然後&lt;a href="https://github.com/Microsoft/vscode/issues/143"&gt;這個功能是一位台灣人去提的&lt;/a&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Terminal&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/bash/"&gt;urxvt-unicode&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一款 terminal emulator，類似 macOS 上的 iTerm 或 iTerm2。  &lt;/li&gt;
&lt;li&gt;搭配這份設定檔：&lt;a href="https://github.com/M157q/dotfiles/blob/master/Xresources"&gt;https://github.com/M157q/dotfiles/blob/master/Xresources&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.zsh.org/"&gt;Zsh&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;以前是使用 bash，後來預設的 shell 改成 zsh，主要是補完功能以及支援非 ASCII 比較完整。  &lt;/li&gt;
&lt;li&gt;搭配 &lt;a href="http://ohmyz.sh/"&gt;oh-my-zsh&lt;/a&gt; 針對不同的 OS 安裝不同的 plugins 來使用，設定檔在這：&lt;a href="https://github.com/M157q/dotfiles/blob/master/zshrc"&gt;https://github.com/M157q/dotfiles/blob/master/zshrc&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/bash/"&gt;Bash&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;基本上寫 shell script 還是會寫 bash 就是，管 server 的時候大多數 Linux server 也都是 bash。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;CLI Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/screen/"&gt;screen&lt;/a&gt; &amp;amp; &lt;a href="http://bxr.su/OpenBSD/usr.bin/tmux/"&gt;tmux&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這兩個指令基本上拿來做相同的事，可以在一個 terminal 裏面開多個分頁。  &lt;/li&gt;
&lt;li&gt;除了方便管理以外，在遇到某些程式要跑很久的時候也很好用，可以把該程式掛在某個分頁，然後再另外開一個分頁去做其他事，不用等到程式跑完。  &lt;/li&gt;
&lt;li&gt;screen 和 tmux 各有擁護者，偶爾會見到兩派使用者開戰。  &lt;/li&gt;
&lt;li&gt;但我自己是開 screen 再在每個 screen 的分頁裏面開 tmux，這樣我覺得很好管理，比如說在不同的 project 開發的話，我就會一個 project 用一個 screen。因為如果在 screen 裏面再開 screen 或 tmux 裏面再開 tmux 的話，會沒辦法控制到裏面那層。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hisham.hm/htop/"&gt;htop&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;可以拿來監控系統資源的工具  &lt;/li&gt;
&lt;li&gt;我通常都是開著掛在 &lt;code&gt;tmux&lt;/code&gt; 的第一個分頁  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sindresorhus/speed-test"&gt;speed-test&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;直接在 CLI 測網路速度，不用開 SpeedTest 的網頁，挺方便的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://geoff.greer.fm/ag/"&gt;ag&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;名字叫 The Silver Searcher  &lt;/li&gt;
&lt;li&gt;類似 &lt;code&gt;grep&lt;/code&gt; 和 &lt;code&gt;ack&lt;/code&gt; 的工具，但效能比較好，要下指令也很方便，只有 &lt;code&gt;ag&lt;/code&gt; 兩個字。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://virtualenv.pypa.io/en/stable/"&gt;virtualenv&lt;/a&gt; + &lt;a href="https://virtualenvwrapper.readthedocs.io/en/latest/"&gt;virtualenvwrapper&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;因為很常用 Python，然後裝東西的時候又不想影響到系統用的 Python，所以就會使用 virtualenv 來把環境隔開。  &lt;/li&gt;
&lt;li&gt;搭配 virtualenvwrapper 可以用更簡單的指令一次處理數個 virtualenv 的指令，挺方便的。  &lt;/li&gt;
&lt;li&gt;例如要新增一個新的 virtualenv 的話，只要 &lt;code&gt;mkvirtualenv py2 --python=python2&lt;/code&gt; 這樣就行了。  &lt;/li&gt;
&lt;li&gt;我自己基本上都是切成 &lt;code&gt;py2&lt;/code&gt;, &lt;code&gt;py3&lt;/code&gt; 來使用，然後各個用 Python 的專案也都會有各自的 virutalenv。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wicd.sourceforge.net/"&gt;wicd &amp;amp; wicd-curses&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;wicd 的 CLI 介面，我都用這個來選擇無線網路。  &lt;/li&gt;
&lt;li&gt;如果是圖形化介面的話則有 wicd-gtk 可以使用。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.gnome.org/NetworkManager/"&gt;NetworkManager&lt;/a&gt; &amp;amp; &lt;a href="https://developer.gnome.org/NetworkManager/stable/nmcli.html"&gt;nmcli&lt;/a&gt; &amp;amp; &lt;a href="https://developer.gnome.org/NetworkManager/stable/nmtui.html"&gt;nmtui&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;wicd 遇到會重導向到 Login 頁面的 Public Wi-Fi 常常會連 IP 都拿不到，但 NetworkManager 往往對付這種 Public Wi-Fi 都可以順利拿到 IP，所以我會在這時候使用 &lt;code&gt;nmcli&lt;/code&gt; 或 &lt;code&gt;nmtui&lt;/code&gt; 去操控 NetworkManager。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.alsa-project.org/main/index.php/Main_Page"&gt;alsamixer&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;可以用來調整 ALSA 裝置的音量，操控挺容易的，也有基於文字的圖形化介面。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Bluetooth"&gt;bluetoothctl&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;可以用指令來管理藍牙裝置  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rg3/youtube-dl/"&gt;youtube-dl&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="http://rg3.github.io/youtube-dl/"&gt;http://rg3.github.io/youtube-dl/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;下載影片跟音樂的神器  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.longwin.com.tw/2016/12/linux-pidof-get-sub-process-id-2016/"&gt;pidof&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;因為這篇文章才知道的：&lt;a href="https://blog.longwin.com.tw/2016/12/linux-pidof-get-sub-process-id-2016/"&gt;使用 pidof 找出此程式的所有 process id - Tsung's Blog&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;以前找 process 都要用 &lt;code&gt;ps aux | grep xxx&lt;/code&gt; 來找，用這個指令的話只要用 &lt;code&gt;pidof xxx&lt;/code&gt; 就行了  &lt;/li&gt;
&lt;li&gt;Arch Linux User 的話可以用 &lt;code&gt;sudo pacman -S procps-ng&lt;/code&gt; 來安裝。  &lt;ul&gt;
&lt;li&gt;但我發現 &lt;code&gt;pidof&lt;/code&gt; 之前是被放在不同的 package 裡頭，所以之後有變的話，可以用 &lt;code&gt;pkgfile pidof&lt;/code&gt; 來找 &lt;code&gt;pidof&lt;/code&gt; 被包含在哪個 package 裡頭。  &lt;/li&gt;
&lt;li&gt;如果沒有 &lt;code&gt;pkgfile&lt;/code&gt; 這個指令的話，可以透過 &lt;code&gt;sudo pacman -S pkgfile&lt;/code&gt; 來安裝  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ffmpeg.org/"&gt;ffmpeg&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;影音轉檔神器，也可以做到裁切、截圖等等的後續處理。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/traviscross/mtr"&gt;mtr&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;用來查路由的神器，方便易用，比 &lt;code&gt;traceroute&lt;/code&gt; 好用。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;GUI Tools&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wicd.sourceforge.net/"&gt;wicd-gtk&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;因為 &lt;code&gt;wicd-curses&lt;/code&gt; 有些 bug，例如遇到新的且需要輸入密碼的 SSID 時會無法設定密碼，所以偶爾會用到 &lt;code&gt;wicd-gtk&lt;/code&gt;，顧名思義，就是 GTK 介面的 wicd。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://freedesktop.org/software/pulseaudio/pavucontrol/"&gt;PulseAudio Volume Control&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;指令為 &lt;code&gt;pavucontrol&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;alsamixer&lt;/code&gt; 的功能在普通使用下算夠用，但比較複雜的操作就會顯得麻煩了點，這時候 &lt;code&gt;pavucontrol&lt;/code&gt; 就派上用場了。  &lt;/li&gt;
&lt;li&gt;可以把輸出和輸入合併為一個音源，大概就像 macOS 上的 SoundFlower 那樣。  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://wugh.github.io/posts/2015/01/linux-pulse-mix-mic-and-computer-audio/"&gt;Linux通过Pulse混合麦克风和音频输出 — Life in a Nutshell&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.lxde.org/en/PCManFM"&gt;PCManFM&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;由台灣人 PCMan 撰寫的開源檔案瀏覽器，嗯，就是那位撰寫瀏覽 BBS 程式 PCMan 的 PCMan （真繞口）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chromium.org/"&gt;Chromium&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;算是去除了非開放原始碼部份的 Google Chrome，所以整個專案的程式碼都是公開的。  &lt;/li&gt;
&lt;li&gt;和 Google Chrome 比起來也比較輕量一些些。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.mozilla.org/zh-TW/firefox/channel/desktop/"&gt;Firefox Nightly&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;2017 年 10 月左右，為了先體驗 Firefox 57 的 Quantum engine 就先裝了，之後就一直使用到現在。  &lt;/li&gt;
&lt;li&gt;剛從 Firefox 55 切換過來的時候真的覺得快了不少，但後來因為使用上覺得還是有 Memory Leak 的問題，所以就比較少用了。  &lt;/li&gt;
&lt;li&gt;加上最近又出了這個問題：&lt;a href="https://sircmpwn.github.io/2017/12/16/Firefox-is-on-a-slippery-slope.html"&gt;Firefox is on a slippery slope | Drew DeVault’s Blog&lt;/a&gt;，所以就換去使用 &lt;code&gt;qutebrowser&lt;/code&gt; 了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qutebrowser.org/"&gt;qutebrowser&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一個基於 QtWebEngine 並使用 Python 開發的開源瀏覽器。  &lt;/li&gt;
&lt;li&gt;所有的操作基本上都以 Vim 的使用習慣為主，有點類似 &lt;code&gt;dwb&lt;/code&gt;，很適合我這種 Vim user，畢竟在 Chrome, Chromium, Firefox 上我都有裝 Vimium 這個瀏覽器套件，可以讓我不太需要移動右手去使用滑鼠。  &lt;/li&gt;
&lt;li&gt;輕量化瀏覽器，比 Chrome 或 Firefox 都省資源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Version Control &amp;amp; DevOps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://git-scm.com/"&gt;Git&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;應該不用多說了，算起來從 2012 年開始接觸，也快 6 年了。  &lt;/li&gt;
&lt;li&gt;雖然也用過 &lt;code&gt;svn&lt;/code&gt; 和 &lt;code&gt;bzr&lt;/code&gt;，但還是覺得比較習慣 &lt;code&gt;git&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;現在連寫 blog 都用 &lt;code&gt;git&lt;/code&gt; 作版本控制了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.docker.com/"&gt;Docker&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;目前最主流的 Container 格式。  &lt;/li&gt;
&lt;li&gt;開源的部份在 2017 年改名叫 Moby 了，但大家還是習慣叫 Docker 就是。  &lt;/li&gt;
&lt;li&gt;Docker 現在專指這間公司，如果是企業版的話叫作 Docker EE，社群版的話叫作 Docker CE。  &lt;/li&gt;
&lt;li&gt;從 2016 年 4 月左右開始接觸，和 Microservices 息息相關。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://kubernetes.io/"&gt;Kubernetes&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kubernetes/kubernetes"&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;Google 出的 Container 管理工具，支援 Docker 和 Rocket，類似 Docker 官方出的 Docker Swarm。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Online Services&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://mail.google.com/mail/"&gt;Gmail&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這應該不用多介紹了，雖然知道隱私會被侵犯得很嚴重，但目前還是離不開。  &lt;/li&gt;
&lt;li&gt;之後其中一個計劃應該就是換到自架的 Mail Server 吧。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://calendar.google.com"&gt;Google Calendar&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這個應該也不用多做介紹，覺得真的不錯用，尤其以前辦社團活動的時候被成功提醒了不少次。  &lt;/li&gt;
&lt;li&gt;無論是個人、分享或團體的時間安排都挺方便的。  &lt;/li&gt;
&lt;li&gt;應該就只有比較不適合一次性使用吧。  &lt;/li&gt;
&lt;li&gt;雖然有用 iPhone，但還是沒用 Apple 的 Calendar。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://maps.google.com"&gt;Google Maps&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這個應該也不用多說了，現在出門去很多人都是靠這個在導航的吧。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ifttt.com"&gt;IFTTT&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;IFTTT 的意思是："If it, then that."  &lt;/li&gt;
&lt;li&gt;和多家公司合作，可以很簡單設定一些跨服務的觸發條件，除了 API 提供的觸發條件以外，還可以在這之上自己撰寫 JavaScript 做一些彈性化的設定。  &lt;/li&gt;
&lt;li&gt;每個人也可以分享自己設定的腳本供他人使用，大多數都是用來做一些提醒或是自動備份的事。  &lt;/li&gt;
&lt;li&gt;我目前是拿來把我在 Twitter 分享或在 Pocket 儲存一些我覺得不錯的文章時，會幫我自動在：&lt;a href="https://github.com/M157q/m157q.github.io/issues"&gt;Issues · M157q/m157q.github.io · GitHub&lt;/a&gt; 開個新的 Issue 紀錄，以方便我日後查詢，解決常常和人分享時想起看過某篇不錯的文章卻搜尋不到的問題。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://getpocket.com"&gt;Pocket&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;用來將文章暫存以供日後閱讀的服務。  &lt;/li&gt;
&lt;li&gt;目前我的使用方式比較像是用來儲存與分類看過的文章，再加上使用了 IFTTT  的關係，說穿了其實就只是不用自己接 API，透過 IFTTT 把我看過的文章存到 GitHub Issues 而已，連搜尋也不太會在 Pocket 作搜尋。  &lt;/li&gt;
&lt;li&gt;但因為使用 Pocket 的時間早於我把文章存到 GitHub Issues 的時間，所以一些比較舊的文章還是會來 Pocket 找就是。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://feedly.com"&gt;Feedly&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一個不錯用的 RSS Reader，目前就拿來追蹤個人與企業的技術 blog。  &lt;/li&gt;
&lt;li&gt;現在免費版的上限好像只能到 100 個來源的樣子，但我自己好像因為比較早使用，所以即便是免費版卻沒有受到這個限制。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;基本上自己已經是每天都會使用 GitHub 了。  &lt;/li&gt;
&lt;li&gt;目前全球最大的程式碼管理平台，許多開放原始碼的專案都在上面，真的是有很多非常有趣的專案，也可以很輕易得和國外的開發者交流。  &lt;/li&gt;
&lt;li&gt;雖然大家私底下好像都戲稱成「全球最大同性交友平台」(ry  &lt;/li&gt;
&lt;li&gt;因為一掛掉就會導致很多工程師沒事幹，所以也有不少公司選擇使用 Bitbucket 或是使用 Gitlab 自己架設程式碼管理平台。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://trello.com"&gt;Trello&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一套基於「看板」(KanBan) 設計的任務管理平台，可供個人或團體使用。  &lt;/li&gt;
&lt;li&gt;我自己是用來紀錄自己做過的事情、幫自己的要做的事排定時間以及快速整理一些新學到的東西，以便之後可能可以整理成一篇文章來紀錄。個人覺得免費版就很夠用了。  &lt;/li&gt;
&lt;li&gt;最近這幾天開始使用 KanbanFlow 這套類似的工具，好處應該就是多了個番茄鐘可以幫你紀錄時間，如果是番茄鐘的愛好者且還沒使用過 Trello 的話，可以直接試試看 KanbanFlow。我自己是因為 Trello 已經紀錄不少東西了，要搬挺麻煩了，所以目前是兩個搭配使用。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://travis-ci.org"&gt;Travis CI&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一個僅和 GitHub 作整合的 Continuous Integration 平台，目前還是 GitHub 上市佔率最大的 CI 平台。可以參考這篇 2017 年 11 月的文章：&lt;a href="https://github.com/blog/2463-github-welcomes-all-ci-tools"&gt;GitHub welcomes all CI tools · GitHub&lt;/a&gt;，列出了 GitHub 上使用的 CI 平台市佔率由多至少依序為：Travis CI, Circle Ci, Jenkins, AppVeyor, CodeShip, Drone, Semaphore CI, Buildkite, Wercker, TeamCity。  &lt;/li&gt;
&lt;li&gt;好處是所有 Public repo 都可以免費使用，而且搜尋一下就有很多設定檔可以參考。我目前是用來自動 build 並發佈我的個人部落格：&lt;a href="https://blog.m157q.tw/posts/2016/05/08/use-travis-ci-to-publish-pelican-blog-on-github-pages-automatically/"&gt;用 Travis CI 自動化發佈 Pelican blog 到 GitHub Pages 上 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cloudflare.com"&gt;CloudFlare&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;2016 年 6 月租了自己的 domain 之後，就拿來個人使用。在這之前是因為公司的服務有在使用，所以才接觸到，覺得設計的很簡單易用且功能又很強大。  &lt;/li&gt;
&lt;li&gt;DNS 代管設定很方便，而且加上 proxy 之後就有免費的 CDN 和 HTTPS 可以使用。有很多其他的功能，可以設定 Cache、簡單的流量分析、免費的網站資安防護等等等。  &lt;/li&gt;
&lt;li&gt;詳細一點的介紹可以參考這篇文章：&lt;a href="https://blog.m157q.tw/posts/2016/09/06/i-bought-my-first-domain-name/"&gt;買了一個叫作 m157q.tw 的域名 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;不過 2017 年 2 月的時候也有出過 CloudBleed 這個大包就是：&lt;a href="https://blog.cloudflare.com/incident-report-on-memory-leak-caused-by-cloudflare-parser-bug/"&gt;Incident report on memory leak caused by Cloudflare parser bug&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.gandi.net"&gt;Gandi&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;因為很常出現在台灣的社群會議，所以就在上面租了域名。  &lt;/li&gt;
&lt;li&gt;但我覺得使用上沒有很方便，而且因為 DNS 的管理已經被我轉到 CloudFlare 了，所以基本上只有在續租域名的時候才會開啟。  &lt;/li&gt;
&lt;li&gt;其他類似的服務有 NameCheap, GoDaddy，GoDaddy 我覺得好用一些，但也沒有認真比較過就是。  &lt;/li&gt;
&lt;li&gt;如果要用 Gandi 的服務的話，記得要開啟 "Private Domain Registration" 就是，不然個資直接被人用 &lt;code&gt;whois&lt;/code&gt; 看光光。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://slack.com"&gt;Slack&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;就是一個針對團隊協作而開發的平台，台灣不少新創公司與社群都有使用。  &lt;/li&gt;
&lt;li&gt;基本上就是功能更多元的 IRC 聊天室，可以整合許多 API，做到 CI, CD 的通知，甚至可以做到 ChatOps。  &lt;/li&gt;
&lt;li&gt;只是我沒有很喜歡一個 workspace 就要重新註冊一組帳號密碼的設計，但可以理解為什麼要這樣設計就是。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://discordapp.com"&gt;Discord&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;最近才開始使用的服務，主要是針對 Gamer 設計的即時語音通訊平台。  &lt;/li&gt;
&lt;li&gt;我個人是覺得像是 Slack + RaidCall，可以即時多人語音通訊（無上限），在 2017 年 11 月也開放了和好友視訊通話與螢幕畫面分享的功能（最多 10 人）。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com"&gt;Medium&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一個算新的部落格平台，乾淨簡潔無廣告，採用付費訂閱制，國外已經滿多人使用了，最近台灣也愈來愈多人使用。  &lt;/li&gt;
&lt;li&gt;我自己其實沒在使用，因為已經厭倦使用部落格平台了，一旦平台一倒的話要搬文章又是件痛苦的事。追蹤文章也是用 Feedly 去追。  &lt;/li&gt;
&lt;li&gt;至於為什麼有辦 Medium 的帳號，主要是有時候想要留言回覆，加上可以使用其他服務登入不用註冊帳號也還算方便，附加功能應該是可以幫別人的文章拍拍手（？）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Social Network Service  &lt;ul&gt;
&lt;li&gt;Facebook, Twitter, Line, Telegram, LinkedIn, Google+ (?)  &lt;/li&gt;
&lt;li&gt;這邊用來紀錄時代的眼淚（？）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Eating My Own Dog Food&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/zdict/zdict"&gt;zdict&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一個 CLI 的字典查詢工具，預設支援 Linux, FreeBSD 和 macOS，也可以透過 Docker 在 Windows 上面執行。  &lt;/li&gt;
&lt;li&gt;預設是使用 Yahoo 字典，也有萌典、Urban Dictionary 等等可以查詢。  &lt;/li&gt;
&lt;li&gt;當初是在看美劇的時候常常要查單字，覺得開網頁很麻煩，所以找到了 &lt;code&gt;ydict&lt;/code&gt;，但不盡理想而且開發者也停止維護了，所以就 fork 出來大改，後來身邊也有幾個朋友加入開發，所以就弄了個 organization。  &lt;/li&gt;
&lt;li&gt;現在變成我每天會使用的工具了，之後應該會寫一篇介紹這個工具。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/M157q/gettitle"&gt;gettitle&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;寫文章的時候附上參考連結的時候常常不想要只附上網址，而是連網頁標題也一起附上，覺得要自己手動複製很麻煩，所以就寫了個小程式來做這件事。  &lt;/li&gt;
&lt;li&gt;使用 Selenium，所以支援使用 JavaScript 的網頁（例如：Dcard），不過也因為這樣所以速度有點慢，但目前是沒有什麼不能等的狀況，所以算是夠用。  &lt;/li&gt;
&lt;li&gt;基本上已經是我寫文章的時候必定會使用到的工具了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/M157q_News_RSS"&gt;M157q_News_RSS&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;一個每小時發科技新聞 tweet 的機器人，主要來源是我有追蹤的科技新聞網站的 RSS feed。  &lt;/li&gt;
&lt;li&gt;之前是把科技新聞類的 RSS 放在 Feedly 裏面，但會造成未讀量暴增，常常幾天沒消未讀就會衝到 999+，後來覺得這樣不是辦法，而且很多其實不一定要看。  &lt;/li&gt;
&lt;li&gt;所以就想說能不能用個會發科技新聞的 Twitter bot，有看到的話就看，沒看到的話就算了。  &lt;/li&gt;
&lt;li&gt;是 fork 別人的程式碼來改的：&lt;a href="https://github.com/M157q/py-feedr"&gt;GitHub - M157q/py-feedr: A Python parser to tweet the latest updates from multiple RSS feeds.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;後來自己加上了訂閱事件的功能，當初是針對 Golang Taiwan Gathering 報名要搶票這件事，所以用來針對某些 KKTIX 的網頁新增事件時，會用 Twitter 的私訊通知我，讓我不會錯過報名的時間，甚至可以第一時間報名。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/hungys-blog/my-software-stack-2a406c1c57c1"&gt;My Software Stack – Hungys.blog() – Medium&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Tools"></category><category term="M157q"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>如何在 Linux 上使用 Miracast</title><link href="https://blog.m157q.tw/posts/2018/01/08/miracast-on-linux/" rel="alternate"></link><published>2018-01-15T15:49:47+08:00</published><updated>2018-01-15T15:49:47+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-08:posts/2018/01/08/miracast-on-linux/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;先說結論，試了以下兩個專案：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/albfan/miraclecast"&gt;GitHub - albfan/miraclecast: Connect external monitors to your system via Wifi-Display specification also known as Miracast&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/derekdai/miraclecast"&gt;GitHub - derekdai/miraclecast: Connect external monitors to your system via Wifi-Display specification also known as Miracast&lt;/a&gt; 這個 fork 出去修改的版本解決了比較多的問題，但最後嘗試了一番還是沒辦法順利使用。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/intel/wds"&gt;GitHub - intel/wds: Wireless Display Software For Linux OS (WDS)&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;嗯，沒錯，是那個 Intel。  &lt;/li&gt;
&lt;li&gt;這個算是試到後來可以動的，但結果不盡理想，畫面非常卡，聲音也沒有出來，猜測是還得去調整其他 &lt;code&gt;gstreamer&lt;/code&gt; 的參數，這篇會以紀錄 &lt;code&gt;wds&lt;/code&gt; 為主。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;2017 年 5 月換租屋處後，客廳有台螢幕，雖然不大，但至少比筆電的螢幕還大。想說有時候筆電或手機可以把畫面投到上面用大螢幕看比較爽，然後又懶的接有線的 VGA 或 HDMI，就想說來買個無線投影裝置。  &lt;/p&gt;
&lt;p&gt;於是就在 6 月初左右就上網買了便宜的無線投影裝置，該裝置對於 iOS 裝置的支援是使用 &lt;a href="https://en.wikipedia.org/wiki/Digital_Living_Network_Alliance"&gt;DLNA&lt;/a&gt;，對於 Android 裝置的支援則是使用 &lt;a href="https://en.wikipedia.org/wiki/Miracast"&gt;Miracast&lt;/a&gt;，當時是我第一次知道 Miracast。  &lt;/p&gt;
&lt;p&gt;想說筆電是跑 Arch Linux，和 Android 一樣都是 based on Linux，所以應該也可以使用 Miracast 吧？才發現可以用的東西少的可憐，也不一定會動。在 GitHub 上找到了 2 看起來比較有希望的專案，花了好幾個小時，看程式碼、查閱相關文件，終於成功把筆電的畫面透過 Miracast 無線投影到螢幕上。  &lt;/p&gt;
&lt;p&gt;後來因為室友買了個攜帶型投影機送了 Chromecast 之後就沒有使用 Miracast 了，所以這篇算是個半殘文，但還是想紀錄一下，畢竟花了不少時間研究。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;關於 Miracast&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以把它想像成用 Wi-Fi 來傳輸 HDMI 訊號，所以可以不用接線就能把畫面投影到其他有支援 Miracast 的裝置上。  &lt;/li&gt;
&lt;li&gt;除了不用接線外，也不需要有其他的裝置或是要連接到某個 Wi-Fi Access Point。  &lt;ul&gt;
&lt;li&gt;這點真的很方便啊，不用買其他裝置就能支援無線投影。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2012 底，由 Wi-Fi Alliance 推出，也是 Android 4.2 的重要新功能之一，但在 2015 年推出的 Android 6.0 卻消失了。  &lt;/li&gt;
&lt;li&gt;Miracast 不知道為啥一直沒有成為標準。  &lt;/li&gt;
&lt;li&gt;Google 後來推出了 Chromecast，基本上這裝置的功能完全和 Miracast 衝突，而且我覺得沒有比較好，除了得額外多接一個 Chromecast 以外，Chromecast 還需要一個額外的 Wi-Fi Access Point，更別說 Chromecast 實際使用上的體驗真的是頗差的。  &lt;/li&gt;
&lt;li&gt;關於 Miracast 詳細介紹，可以參考這篇繁體中文的文章：&lt;a href="http://www.2cm.com.tw/technologyshow_content.asp?sn=1304260008"&gt;以鏡射與Wi-Fi技術為基礎　Miracast實現多螢影音串流 - 技術前瞻 - 新通訊元件雜誌&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;紀錄&lt;/h2&gt;
&lt;p&gt;因為 &lt;a href="https://github.com/derekdai/miraclecast"&gt;MiracleCast&lt;/a&gt; 沒試成功，所以只會以紀錄 &lt;a href="https://github.com/intel/wds"&gt;WDS&lt;/a&gt; 為主。&lt;br /&gt;
其實還有找到一個 &lt;a href="https://cgit.freedesktop.org/~dvdhrm/openwfd/"&gt;openwfd&lt;/a&gt;，不過因為看起來已經年久失修了，所以就沒去試了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;WDS 的裝置分類&lt;/h3&gt;
&lt;p&gt;首先，WDS 把使用 Miracast 的裝置區分為以下兩種：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sink: 要呈現畫面的裝置。  &lt;/li&gt;
&lt;li&gt;Source: 要把畫面投影出去的裝置。  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;我使用 WDS 時遇到的問題&lt;/h3&gt;
&lt;p&gt;然後把當時遇到的問題相關連結都先列出來一下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://lists.01.org/pipermail/wysiwidi-dev/2015-April/000012.html"&gt;[wysiwidi-dev] desktop_source and mirroring display&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/intel/wds/issues/147"&gt;Working with Linux as Source and Miracast Dongle · Issue #147 · intel/wds · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/intel/wds/issues/87"&gt;source video params should be tweaked for desktop mirroring use case · Issue #87 · intel/wds · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/intel/wds/issues/133"&gt;Black/frozen screen · Issue #133 · intel/wds · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;WDS 安裝與使用步驟&lt;/h3&gt;
&lt;p&gt;WDS 會用到以下幾個程式，必須預先安裝：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wpa_supplicant&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;2.4 以後的版本，且必須要在 build 的時候開啟 &lt;code&gt;CONFIG_P2P=y&lt;/code&gt;, &lt;code&gt;CONFIG_WIFI_DISPLAY=y&lt;/code&gt;, &lt;code&gt;CONFIG_CTRL_IFACE_DBUS_NEW=y&lt;/code&gt; 這 3 個參數  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connman&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;必須是 1.28 以後的版本  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gstreamer&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來就可以照著以下步驟來嘗試：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone https://github.com/intel/wds.git&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd wds&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;修改程式碼  &lt;ul&gt;
&lt;li&gt;根據 &lt;a href="https://github.com/intel/wds/issues/87"&gt;source video params should be tweaked for desktop mirroring use case · Issue #87 · intel/wds · GitHub&lt;/a&gt; 和 &lt;a href="https://github.com/intel/wds/issues/133"&gt;Black/frozen screen · Issue #133 · intel/wds · GitHub&lt;/a&gt; 這兩個 issues 裡頭提到的解法，我們得修改程式碼裡頭用到 &lt;code&gt;gstreamer&lt;/code&gt; 的參數，不然只會出現黑的畫面，這部份可能因人而異，我只就我遇到的部份描述，附上 git diff，這個參數還有調整的空間就是。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git a/mirac_network/mirac-gst-test-source.cpp b/mirac_network/mirac-gst-test-source.cpp  &lt;/span&gt;
&lt;span class="gh"&gt;index 12c2623..821e38a 100644  &lt;/span&gt;
&lt;span class="gd"&gt;--- a/mirac_network/mirac-gst-test-source.cpp  &lt;/span&gt;
&lt;span class="gi"&gt;+++ b/mirac_network/mirac-gst-test-source.cpp  &lt;/span&gt;
&lt;span class="gu"&gt;@@ -42,7 +42,9 @@ MiracGstTestSource::MiracGstTestSource (wfd_test_stream_t wfd_stream_type, std::  &lt;/span&gt;
     } else if (wfd_stream_type == WFD_TEST_VIDEO) {  
         gst_pipeline = &amp;quot;videotestsrc ! videoconvert ! video/x-raw,format=I420 ! x264enc ! mpegtsmux ! rtpmp2tpay ! udpsink name=sink &amp;quot; + hostname_port;  
     } else if (wfd_stream_type == WFD_DESKTOP) {  
&lt;span class="gd"&gt;-        gst_pipeline = &amp;quot;ximagesrc ! videoconvert ! video/x-raw,format=I420 ! x264enc tune=zerolatency ! mpegtsmux ! rtpmp2tpay ! udpsink name=sink &amp;quot; + hostname_port;  &lt;/span&gt;
&lt;span class="gi"&gt;+        gst_pipeline = &amp;quot;ximagesrc use-damage=0 ! videoscale ! videoconvert ! video/x-raw,format=I420,width=1440,height=900,framerate=50/1 ! x264enc aud=false bitrate=2048 dct8x8=true vbv-buf-capacity=1000 tune=stillimage+zerolatency byte-stream=true ! video/x-h264,profile=high ! muxer. pulsesrc device=alsa_output.pci-0000_00_1b.0.analog-stereo.monitor ! audioconvert ! audio/x-raw,channels=2,rate=44100 ! faac ! audio/mpeg,mpegversion=4 ! muxer. mpegtsmux name=muxer alignment=0 ! rtpmp2tpay pt=33 ! udpsink name=sink sync=false &amp;quot; + hostname_port;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmake .&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo wpa_supplicant -i wlp0s20u1 -ddt -u&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;wlp0s20u1&lt;/code&gt; 請換成你的無線網卡裝置名稱  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ddt&lt;/code&gt;: 用來開啟比較詳細的 debug 訊息，且在訊息加上 timestamp  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; : 用來開啟 DBus control interface  &lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;wpa_supplicant&lt;/code&gt; 在編譯的時候沒有加入上面提到的 &lt;code&gt;CONFIG_CTRL_IFACE_DBUS_NEW=y&lt;/code&gt; 的話，這個選項就不會有用。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;執行這行指令的時候最好是先把原本有在用的 network manager 關掉，避免衝突。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo connmand -r -n -d -i wlp0s20u1&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;wlp0s20u1&lt;/code&gt; 請換成你的無線網卡裝置名稱  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;: 不要開啟 DNS proxy  &lt;ul&gt;
&lt;li&gt;官方的 README 上沒有加這個選項，是我自己加上去的，我記得當時可以解掉一些問題，但現在忘了是什麼問題了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;: 不要在背景執行，方便看到 debug 訊息  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;: 開啟 debug 模式  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo connmanctl&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;開啟 connman 的互動式介面  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; enable wifi&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; enable p2p&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; scan p2p&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; peers&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;檢查 p2p 功能是否正常  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; agent on&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果以上都正常的話，應該就會像&lt;a href="https://github.com/intel/wds/wiki"&gt;官方在其 GitHub repo 的 wiki 所列出的截圖&lt;/a&gt;一樣：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android 手機要無線投影到電腦 (Sink mode)  &lt;ul&gt;
&lt;li&gt;打開 Miracast 選單應該就可以看到電腦裝置  &lt;/li&gt;
&lt;li&gt;選擇投影到電腦上  &lt;/li&gt;
&lt;li&gt;許可連線  &lt;/li&gt;
&lt;li&gt;沒問題的話應該就可以在電腦上跳出一個視窗顯示手機的畫面了  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;電腦要無線投影到其他裝置 (Source mode)  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; scan&lt;/code&gt; 可以重新掃描附近的裝置  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; peers&lt;/code&gt; 列出可以連線的裝置  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;connmanctl&amp;gt; connect N&lt;/code&gt; 連線到該裝置  &lt;/li&gt;
&lt;li&gt;許可連線  &lt;/li&gt;
&lt;li&gt;正常的話其他裝置應該就會顯示電腦上的畫面了  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;還沒到完全能動，畫面有點卡，而且沒有聲音，猜測是還得去調整 &lt;code&gt;gstreamer&lt;/code&gt; 的參數。  &lt;/p&gt;
&lt;p&gt;但就紀錄下來，也給可能有遇到這個問題想要解決的人參考，如果有幫助到你的話很歡迎留言跟我說一下，如果試出了更好的結果當然更棒就是。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Digital_Living_Network_Alliance"&gt;Digital Living Network Alliance - Wikipedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Miracast"&gt;Miracast - Wikipedia&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.computerworld.com/article/3239864/android/android-nostalgia-old-features.html"&gt;Android nostalgia: 13 once-trumpeted features that quietly faded away | Computerworld&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.2cm.com.tw/technologyshow_content.asp?sn=1304260008"&gt;以鏡射與Wi-Fi技術為基礎　Miracast實現多螢影音串流 - 技術前瞻 - 新通訊元件雜誌&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Miracast"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>關於 Django REST framework 的一些筆記</title><link href="https://blog.m157q.tw/posts/2018/01/07/django-rest-framework-note/" rel="alternate"></link><published>2018-01-16T15:04:00+08:00</published><updated>2018-01-16T15:04:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-07:posts/2018/01/07/django-rest-framework-note/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;2016 年 9 月的時候被老闆告知公司報名了交通大學的梅竹黑客松，要我回母校當評審，然後在一個月內生出一個 API 且附帶文件的網站給參賽者使用。  &lt;/p&gt;
&lt;p&gt;當時公司並沒有這些資料的 API，只有資料而已，所以等於是從零開始設計，想說藉由這次機會，除了提供給參賽者 API 以外，未來也可以提供給公司自己使用。  &lt;/p&gt;
&lt;p&gt;在這之前就有聽過 &lt;a href="https://github.com/encode/django-rest-framework"&gt;Django REST frmaework&lt;/a&gt;，也看過滿多人用的，查了一下發現也有 &lt;a href="https://github.com/manosim/django-rest-framework-docs"&gt;DRF Docs (django-rest-framework-docs)&lt;/a&gt; 這個 plugin 可以用來生出 API 的文件，看了一下範例感覺還不錯，於是就放棄用 Flask 自己刻，直接採用 Django + Django REST framework + DRF Docs + Google Cloud SDK + Google App Engine Flexible Environment，建立一個可以從 BigQuery dataset 撈資料出來且帶有文件說明的 API。  &lt;/p&gt;
&lt;p&gt;以下會就當時使用 Django REST framework 和 DRF Docs 遇到的問題做些紀錄，當時為了馬上解決一些問題，也 fork 了 DRF Docs 的 repo 來改。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Django REST framework&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;以下為了撰寫方便，直接把 Django REST framework 簡稱為　DRF。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;整個 DRF 我覺得設計得滿完整，甚至也有 plugin 的生態系，如果找不到合適的，也可以自己撰寫 DRF 的 plugin。剛開始上手的話有份官方的 Tutorial 可看：&lt;a href="http://www.django-rest-framework.org/tutorial/quickstart/"&gt;Quickstart - Django REST framework&lt;/a&gt;，建議把整份 tutorial 都唸完會比較瞭解整個 framework 元件之間的關係，畢竟篇幅也不多，加上 Quickstart 也就 8 個頁面而已。剩下的等實際撰寫程式碼時遇到不太懂的時候，再去查詢官網上詳細一點的文件就行了，有時候真的文件說的不夠清楚的話可能還是得去看一下程式碼。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;這邊紀錄一下幾個我自己在閱讀文件的時候花比較多時間理解的部份：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.django-rest-framework.org/tutorial/1-serialization/"&gt;1 - Serialization - Django REST framework&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;基本上就是在 Django 的 Model 上再多做一層包裝，可以對 API 做一些客製化設定，比如要顯示哪些欄位、限定哪些權限...等等。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.django-rest-framework.org/api-guide/filtering/"&gt;Filtering - Django REST framework&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;如果要針對不同的使用者得到不同的結果的話，就會需要用到 filtering 的部份。  &lt;/li&gt;
&lt;li&gt;可以針對使用者、網址、可使用參數做限制。  &lt;/li&gt;
&lt;li&gt;有多種不同的 filter 可以用，搜尋、排序、權限，也可以自己繼承下來撰寫客製化的 filter。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.django-rest-framework.org/api-guide/routers/"&gt;Routers - Django REST framework&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;基本上跟 Django 的 dispatcher 寫法差不多，但多了一些可以針對 HTTP method 的設定ˇ等等。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/encode/django-rest-framework/blob/master/rest_framework/viewsets.py"&gt;django-rest-framework/viewsets.py at master · encode/django-rest-framework · GitHub&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;當時是因為對 &lt;code&gt;ViewSet&lt;/code&gt; 可以使用的參數不太清楚，看文件又看不出個所以然，所以就跑去看程式碼了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;花了一點時間熟悉之後，我在後續使用上遇到最大的問題是在效能，因為我要去查詢的資料總量滿大的，所以查詢常常都會等很久。還有 DRF 預設的 pagination 部份也沒有處理得很好，查了一下發現也有很多人遇到，所以有滿多文章在講這件事的，這裡列出我自己覺得比較有用的：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://engineering.betterworks.com/2015/09/04/ditching-django-rest-framework-serializers-for-serpy/"&gt;Ditching Django REST Framework Serializers for Serpy · BetterWorks Engineering Blog&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇是作者因為 DRF 的 Serializer 實在是太慢，所以自己寫了另外一個作 serialization 的 library: &lt;a href="https://github.com/clarkduvall/serpy"&gt;serpy&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ses4j.github.io/2015/11/23/optimizing-slow-django-rest-framework-performance/"&gt;Optimizing slow Django REST Framework performance&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇是在講怎麼透過調整 DRF 的 Serializer 來處理 query 時過慢的問題。  &lt;/li&gt;
&lt;li&gt;要用上 &lt;code&gt;queryset.prefech_realted&lt;/code&gt; 等等。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dabapps.com/blog/api-performance-profiling-django-rest-framework/"&gt;Web API performance: profiling Django REST framework&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇是作者使用了 DRF 並測試其效能以後自己歸納出的一些結論，基本上是推薦使用 DRF，算是我看過最完整對 DRF 做效能測試的文章了。  &lt;/li&gt;
&lt;li&gt;一些迷思：  &lt;ul&gt;
&lt;li&gt;自己寫個框架：即便只有用到 DRF 的 &lt;code&gt;APIView&lt;/code&gt; 其他都沒用到，還是推薦使用 DRF，比起你自己用 Django 撰寫的 API 還是好上許多。  &lt;/li&gt;
&lt;li&gt;想用輕量化的框架：DRF 雖然包含了很多功能，但核心的 view 部份是很簡單的。  &lt;/li&gt;
&lt;li&gt;DRF 會被 Django 的 model 綁住：view 和 serializer 都是可選的，沒有強制綁定。  &lt;/li&gt;
&lt;li&gt;Django/Python/DRF 太慢：這篇文章會大量討論效能的部份，基本上都可以透過適當的資料庫查詢結果暫存、設計良好的 HTTP 暫存以及 shared server-side cache 來解決。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接下來就是非常詳細的 profiling 步驟與紀錄  &lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Get your ORM lookups right.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Your database lookups will be the bottleneck.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Work on performance improvements selectively.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;You don't always need to use serializers.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但這幾篇文章其實都有點舊了，大部份都是 2015 年的，所以可能不一定符合現在的狀況，不確定 DRF 在效能方面改進了多少就是。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;另外，DRF 也有設計一些可以拿來做測試的函式，列在官方的這篇文章裡頭：&lt;a href="http://www.django-rest-framework.org/api-guide/testing/"&gt;Testing - Django REST framework&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;DRF Docs&lt;/h2&gt;
&lt;p&gt;DRF Docs 主要功能就是可以根據你在 Django REST framework 所使用的 View function 直接生出 API 文件，有要額外補充的也可以寫在 View function 的 docstring 裡頭，DRF Docs 會幫你呈現出來，這樣就不需要為了 API 額外撰寫文件，只要 docstring 寫得夠清楚就行，可以節省開發上的時間，也可以讓程式碼更容易被理解。  &lt;/p&gt;
&lt;p&gt;當時會 fork &lt;a href="https://github.com/manosim/django-rest-framework-docs"&gt;GitHub - manosim/django-rest-framework-docs: Document Web APIs made with Django Rest Framework&lt;/a&gt; 出來改的主要原因是要改首頁的標題。  &lt;/p&gt;
&lt;p&gt;但實際使用過發現有個需求，就是我想在 docstring 直接寫 markdown，覺得應該也有人有這樣的需求，所以找了一下。發現有個 PR 就是在做這件事，不過還沒被 merge：&lt;a href="https://github.com/manosim/django-rest-framework-docs/pull/117"&gt;Added markdown support for endpoint docstrings by mikeengland · Pull Request #117 · manosim/django-rest-framework-docs · GitHub&lt;/a&gt;，於是就把這個 PR merge 進來使用，基本上沒啥太大的問題。  &lt;/p&gt;
&lt;p&gt;撰寫這篇文章的時候去追了一下進度，發現已經有另外一個支援 markdown 的 PR 被 merge 了：&lt;a href="https://github.com/manosim/django-rest-framework-docs/pull/127"&gt;Add optional markdown for docstrings by rainyday · Pull Request #127 · manosim/django-rest-framework-docs · GitHub&lt;/a&gt;，所以現在的 DRF Docs 應該是有正式支援在 docstring 可以寫 markdown 這件事，但這個部份我自己沒使用過就是。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;如果熟 Django 的人真的可以很快用 DRF + DRF Docs 弄出一個可以做帳號權限管理的 REST API 網站，而且因為用上了 DRF Docs，所以不會出現程式碼和文件不一致的狀況。當時撰寫完整個網站我也不過花了 &lt;code&gt;53 commits  1,806 ++  761 --&lt;/code&gt;，為期大概一個月，學到了沒碰過的新東西，成功嘗試了 Google App Engine Flexible Environment，期間當然也有做其他事。  &lt;/p&gt;
&lt;p&gt;但如果不考慮快速完成而是考慮效能的話，我大概就不太推薦 DRF，雖然不確定目前效能改善到什麼地步，如果還是要使用的話可能就要在 Database 或架構方面多下點功夫。  &lt;/p&gt;
&lt;p&gt;因為開發完這網站之後我就沒再碰 DRF 了，所以這篇文章可能會顯得有點過時些，但可以當個參考，畢竟這篇主要目的是紀錄給我自己知道到底我把時間花在哪裡了。  &lt;/p&gt;
&lt;p&gt;技術文這種東西真的不太能囤積在草稿啊，能發就要趕快發，不然真的很容易過時。如果是一些跟人比較有關係的文章則大概很難過時，看看技術的長青書基本上都是在講人的態度或是做事的方法與原則。其實也在思考以後寫的一些技術文能否能朝這個方向去多紀錄一些。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/encode/django-rest-framework"&gt;GitHub - encode/django-rest-framework: Web APIs for Django.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/manosim/django-rest-framework-docs"&gt;GitHub - manosim/django-rest-framework-docs: Document Web APIs made with Django Rest Framework&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="Django"></category><category term="RESTful API"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>Python 中讓 urllib 使用 cookie 的方法</title><link href="https://blog.m157q.tw/posts/2018/01/06/use-cookie-with-urllib-in-python/" rel="alternate"></link><published>2018-01-07T01:42:00+08:00</published><updated>2018-01-07T01:42:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-06:posts/2018/01/06/use-cookie-with-urllib-in-python/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;其實一般來說只要用 &lt;a href="https://github.com/requests/requests"&gt;&lt;code&gt;requests&lt;/code&gt;&lt;/a&gt; 這個超強的 third-party library 就可以解了，&lt;code&gt;requests&lt;/code&gt; 已經把 Cookie 的部份處理好了，那為什麼要紀錄這篇？其實這問題也是約莫一年前在前公司工作時遇到的問題，以下說明一下：  &lt;/p&gt;
&lt;p&gt;Google App Engine Standard Environment 除了預設使用 Python 2 以外，加上因為是 PaaS 的關係，做了不少限制，直接拿 &lt;code&gt;requests&lt;/code&gt; 來用的話會無法使用，必須再搭配 &lt;a href="https://github.com/requests/toolbelt"&gt;&lt;code&gt;requests-toolbelt&lt;/code&gt;&lt;/a&gt; 這個工具，讓 &lt;code&gt;requests&lt;/code&gt; 在 GAE Standard 上使用的時候，底層會抽換成 GAE 提供的 &lt;code&gt;urlfetch&lt;/code&gt;，這樣才能使用，而在 GAE Standard 上預設可以使用 &lt;code&gt;urlfetch&lt;/code&gt; 和 &lt;code&gt;urllib2&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;那為什麼不用 &lt;code&gt;requests&lt;/code&gt; 就好了？因為 Legacy code 的緣故，無法很輕易使用 &lt;code&gt;requests&lt;/code&gt;，所以採用 &lt;code&gt;urllib2&lt;/code&gt;，但又遇到有需要使用 Cookie 的需求，而 &lt;code&gt;urllib2&lt;/code&gt; 是沒有支援 Cookie 的，所以就必須再搭配 &lt;code&gt;cookielib&lt;/code&gt; 來使用。  &lt;/p&gt;
&lt;p&gt;就用這篇文章紀錄一下作法，順便連 Python 3 的寫法也順便紀錄一下，因為 Python 2 裡的 &lt;code&gt;urllib2&lt;/code&gt; 和 &lt;code&gt;cookielib&lt;/code&gt; 在 Python 3 裡頭都有做更動。順便也把最簡單的 &lt;code&gt;requests&lt;/code&gt; 的寫法也一併附上。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Python 2: &lt;code&gt;urllib2&lt;/code&gt; + &lt;code&gt;cookielib&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python 2 中的 &lt;code&gt;urllib2&lt;/code&gt; 是 &lt;code&gt;urllib&lt;/code&gt; 的加強版，在實際使用上比較常使用 &lt;code&gt;urllib2&lt;/code&gt;，所以這裡直接講 &lt;code&gt;urllib2&lt;/code&gt; 的寫法。&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;範例其實在官方網站的說明文件最底下的範例就有了：&lt;a href="https://docs.python.org/2/library/cookielib.html#examples"&gt;20.21. cookielib — Cookie handling for HTTP clients — Python 2.7.14 documentation&lt;/a&gt;，其實也不會很複雜。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cookielib&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;urllib2&lt;/span&gt;  
&lt;span class="n"&gt;cj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cookielib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CookieJar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="n"&gt;opener&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HTTPCookieProcessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opener&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://example.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;不從檔案匯入，直接設定 Cookie&lt;/h3&gt;
&lt;p&gt;但如果今天我們沒有一份先存好的 Cookie 設定檔，卻又想在發送 request 前預先設定一些 Cookie 的 value 怎麼辦？先講結論：「有辦法做到，但不推薦使用。」（如果是要改 "User-Agent" 的話，這個是 request header，而不是 cookie，所以是 &lt;code&gt;urllib&lt;/code&gt; 要處理，而不是 &lt;code&gt;cookielib&lt;/code&gt; 處理，請勿搞混。）  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;cookielib.CookieJar&lt;/code&gt; 有個 &lt;code&gt;set_cookie()&lt;/code&gt; 的函式，其預設接收的參數是 &lt;code&gt;cookielib.Cookie&lt;/code&gt;，但 &lt;code&gt;cookielib.Cookie&lt;/code&gt; 的文件中卻有著以下這段說明：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class represents Netscape, RFC 2109 and RFC 2965 cookies. It is not expected that users of &lt;code&gt;cookielib&lt;/code&gt; construct their own &lt;code&gt;Cookie&lt;/code&gt; instances. Instead, if necessary, call &lt;code&gt;make_cookies()&lt;/code&gt; on a &lt;code&gt;CookieJar&lt;/code&gt; instance.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是說，預設其實是不期望使用者自己設定 Cookie 的，但並不是不能做到，這個在 StackOverflow 上的回答有給出範例：&lt;a href="https://stackoverflow.com/questions/4685337/python-add-cookie-to-cookiejar#12682437"&gt;python - add cookie to cookiejar - Stack Overflow&lt;/a&gt;，但我自己是覺得非常的不直觀，用這種開發方式應該很難維護，除非初始化 &lt;code&gt;cookielib.Cookie&lt;/code&gt; 的時候把參數的 key 都加上去。順待一提，這篇文章的提問者誤把 &lt;code&gt;Cookie.SimpleCooke&lt;/code&gt; 丟給 &lt;code&gt;cookielib.CookieJar.set_cookie()&lt;/code&gt; 當參數餵入，但這個函式可以接受的參數必須是 &lt;code&gt;cookielib.Cookie&lt;/code&gt;，而不是 &lt;code&gt;Cookie.SimpleCookie&lt;/code&gt;，所以出了錯，而且這兩者並沒有任何關係，完全是繼承自不同的 class。  &lt;/p&gt;
&lt;h3&gt;從檔案匯入/匯出到檔案&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/library/cookielib.html#cookielib.FileCookieJar.save"&gt;&lt;code&gt;cookielib.FileCookieJar.save&lt;/code&gt;&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;將現有的 Cookie export 到檔案中。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/library/cookielib.html#cookielib.FileCookieJar.load"&gt;&lt;code&gt;cookielib.FileCookieJar.load&lt;/code&gt;&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;從檔案中 import Cookie 的設定進來。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣一來在實作爬蟲時，遇到會利用 Cookie 來判斷使用者是否登入的網站時就很方便。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Python 3: &lt;code&gt;urllib.request&lt;/code&gt; + &lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/h2&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;p&gt;一樣在 Python 官方的說明文件底下就有範例可以參考了：&lt;a href="https://docs.python.org/3/library/http.cookiejar.html?highlight=cookiejar#examples"&gt;21.24. http.cookiejar — Cookie handling for HTTP clients — Python 3.6.4 documentation&lt;/a&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;http.cookiejar&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;urllib.request&lt;/span&gt;  
&lt;span class="n"&gt;cj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cookiejar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CookieJar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="n"&gt;opener&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build_opener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HTTPCookieProcessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;opener&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://example.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其實可以看到跟 Python 2 的寫法一模一樣，只是把 &lt;code&gt;cookielib&lt;/code&gt; 換成 &lt;code&gt;http.cookiejar&lt;/code&gt;，&lt;code&gt;urllib2&lt;/code&gt; 換成 &lt;code&gt;urllib.request&lt;/code&gt; 而已。  &lt;/p&gt;
&lt;h3&gt;不從檔案匯入，直接設定 Cookie。&lt;/h3&gt;
&lt;p&gt;這部份跟 Python 2 一樣，可以做到，但不推薦，就不贅述。  &lt;/p&gt;
&lt;h3&gt;從檔案匯入/匯出到檔案&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/http.cookiejar.html?highlight=cookiejar#http.cookiejar.FileCookieJar.save"&gt;&lt;code&gt;http.cookiejar.FileCookieJar.save&lt;/code&gt;&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;將目前的 Cookie 匯出到檔案。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/http.cookiejar.html?highlight=cookiejar#http.cookiejar.FileCookieJar.load"&gt;&lt;code&gt;http.cookiejar.FileCookieJar.load&lt;/code&gt;&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;從現有的檔案中匯入 Cookie。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;requests&lt;/h2&gt;
&lt;p&gt;官方文件的 Quickstart 就有一個關於 Cookies 的部份：&lt;a href="http://docs.python-requests.org/en/master/user/quickstart/#cookies"&gt;Quickstart — Requests 2.18.4 documentation&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;requests&lt;/code&gt; 本身就自帶 Cookie 的處理了，用法簡單了許多：  &lt;/p&gt;
&lt;h3&gt;基本使用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If a response contains some Cookies, you can quickly access them:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://example.com/some/cookie/setting/url&amp;#39;&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cookies&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;example_cookie_name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="s1"&gt;&amp;#39;example_cookie_value&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;To send your own cookies to the server, you can use the cookies parameter:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://httpbin.org/cookies&amp;#39;&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cookies&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cookies_are&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;working&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cookies&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cookies&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;  
&lt;span class="s1"&gt;&amp;#39;{&amp;quot;cookies&amp;quot;: {&amp;quot;cookies_are&amp;quot;: &amp;quot;working&amp;quot;}}&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;不從檔案匯入，直接設定 Cookie。&lt;/h3&gt;
&lt;p&gt;基本上這邊的作法就是上面 Python 2 那邊提到的作法，不過 &lt;code&gt;requests&lt;/code&gt; 把剛剛說的加上參數 key  這件事情稍微處理了一下。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cookies are returned in a &lt;code&gt;RequestsCookieJar&lt;/code&gt;, which acts like a &lt;code&gt;dict&lt;/code&gt; but also offers a more complete interface, suitable for use over multiple domains or paths. Cookie jars can also be passed in to requests:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cookies&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RequestsCookieJar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;tasty_cookie&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;yum&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;httpbin.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/cookies&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gross_cookie&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blech&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;httpbin.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/elsewhere&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://httpbin.org/cookies&amp;#39;&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cookies&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;  
&lt;span class="s1"&gt;&amp;#39;{&amp;quot;cookies&amp;quot;: {&amp;quot;tasty_cookie&amp;quot;: &amp;quot;yum&amp;quot;}}&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;從檔案匯入/匯出到檔案&lt;/h3&gt;
&lt;p&gt;這部份在 &lt;code&gt;requests&lt;/code&gt; 就比較麻煩一點，但也不難，需要額外用到 &lt;code&gt;requests.utils.dict_from_cookiejar()&lt;/code&gt;，詳細可以參考這篇 StackOverflow 的解答：&lt;a href="https://stackoverflow.com/questions/13030095/how-to-save-requests-python-cookies-to-a-file/13031628#13031628"&gt;How to save requests (python) cookies to a file? - Stack Overflow&lt;/a&gt;，它還有用到 &lt;code&gt;pickle&lt;/code&gt; 這個函式庫。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無論是 &lt;code&gt;requests.Response.cookies&lt;/code&gt; 或 &lt;code&gt;requests.Sessions.Session.cookies&lt;/code&gt; 都是 &lt;code&gt;requests.cookies.cookiejar_from_dict()&lt;/code&gt; 的輸出結果。  &lt;/li&gt;
&lt;li&gt;可以用 &lt;code&gt;requests.utils.dict_from_cookiejar()&lt;/code&gt; 這個函式，將 &lt;code&gt;response.cookies&lt;/code&gt; 或是 &lt;code&gt;session.cookies&lt;/code&gt; 當作輸入，就可以得到該 Cookie 以 &lt;code&gt;dict&lt;/code&gt; 方式呈現結果，當然也就可以匯出到檔案。  &lt;/li&gt;
&lt;li&gt;要匯入的話，可以使用 &lt;code&gt;requests.utils.cookiejar_from_dict()&lt;/code&gt; 這個參數來把 &lt;code&gt;dict&lt;/code&gt; 轉成 &lt;code&gt;RequestsCookieJar&lt;/code&gt;。  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;requests.utils.cookiejar_from_dict()&lt;/code&gt; 是從 &lt;code&gt;requests.cookies&lt;/code&gt; import 來的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用到 &lt;code&gt;pickle&lt;/code&gt; 只是方便以 &lt;code&gt;pickle&lt;/code&gt; 的形式儲存而已。  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;能用 &lt;code&gt;requests&lt;/code&gt; 的話當然就直接用吧，如果遇到我提到的這種狀況才會需要特殊的解法。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/2018026/what-are-the-differences-between-the-urllib-urllib2-and-requests-module"&gt;python - What are the differences between the urllib, urllib2, and requests module? - Stack Overflow&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/requests/requests"&gt;GitHub - requests/requests: Python HTTP Requests for Humans™ ✨🍰✨&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/requests/toolbelt"&gt;GitHub - requests/toolbelt: A toolbelt of useful classes and functions to be used with python-requests&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2.7/library/urllib.html?highlight=urllib"&gt;20.5. urllib — Open arbitrary resources by URL — Python 2.7.14 documentation&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2.7/library/urllib2.html"&gt;20.6. urllib2 — extensible library for opening URLs — Python 2.7.14 documentation&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/library/cookielib.html"&gt;20.21. cookielib — Cookie handling for HTTP clients — Python 2.7.14 documentation&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/urllib.html?highlight=urllib"&gt;21.5. urllib — URL handling modules — Python 3.6.4 documentation&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/http.cookiejar.html?highlight=cookiejar#module-http.cookiejar"&gt;21.24. http.cookiejar — Cookie handling for HTTP clients — Python 3.6.4 documentation&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.python-requests.org/en/master/user/quickstart/#cookies"&gt;Quickstart — Requests 2.18.4 documentation&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="Python 2"></category><category term="Python 3"></category><category term="urllib"></category><category term="cookie"></category><category term="requests"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>Linux 設定桌面環境預設開啟程式</title><link href="https://blog.m157q.tw/posts/2018/01/05/set-default-application-in-desktop-environment-on-linux/" rel="alternate"></link><published>2018-01-06T00:52:26+08:00</published><updated>2018-01-06T00:52:26+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-05:posts/2018/01/05/set-default-application-in-desktop-environment-on-linux/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;xdg-settings {get | check | set} {property} [subproperty] [value]&lt;/code&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;其實主要是最近用了 qutebrowser 以後，要把預設瀏覽器從 Firefox 改成 qutebrowser，因為在 qutebrowser 的設定裡頭找不到，查了 qutebrowser 的說明也沒看到，後來發現一個指令就可以做掉了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;如果是 CLI 環境的話，可以透過 &lt;code&gt;EDITOR&lt;/code&gt;, &lt;code&gt;BROWSER&lt;/code&gt; 等環境變數來做設定。  &lt;/p&gt;
&lt;p&gt;如果是桌面環境的話，我通常是在我使用的應用程式裏面找看看有沒有可以把該程式設定為預設開啟程式的選項，但因為這在 qutebrowser 上行不通，所以用下面這個方法。  &lt;/p&gt;
&lt;p&gt;只要是走 &lt;a href="https://specifications.freedesktop.org/mime-apps-spec/mime-apps-spec-1.0.html"&gt;XDG 標準&lt;/a&gt; 都可以用這個設定方式。（XDG 為 X Desktop Group 的縮寫）  &lt;/p&gt;
&lt;p&gt;XDG 的設定檔有下面三種路徑：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;個別使用者設定檔  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;~/.config/mimeapps.list&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有使用者共用  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/xdg/mimeapps.list&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系統預設設定檔  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;/usr/local/share/applications/mimeapps.list&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/share/applications/mimeapps.list&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但我修改了以後發現沒用，所以就直接透過 &lt;code&gt;xdg-settings&lt;/code&gt; 這個指令做設定，&lt;br /&gt;
後來用下面這一行解決：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;xdg-settings set default-web-browser qutebrowser.desktop&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;xdg-settings --list&lt;/code&gt; 可以察看有哪些 XDG properties 可以設定。  &lt;/p&gt;
&lt;p&gt;詳細內容可以參考這篇文章：&lt;a href="https://wiki.archlinux.org/index.php/Default_applications#xdg-utils"&gt;Default applications - ArchWiki&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/Default_applications#xdg-utils"&gt;Default applications - ArchWiki&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Freedesktop.org"&gt;freedesktop.org - Wikipedia&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Desktop"></category><category term="XDG"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>解決 Arch Linux 上 gcin 2.8.5-2 無法在 Qt 5.9.x 以後的應用程式中執行的問題</title><link href="https://blog.m157q.tw/posts/2018/01/04/solution-for-gcin-2-8-5-2-cannot-run-in-application-using-qt-after-5-9-x-on-arch-linux/" rel="alternate"></link><published>2018-01-05T01:21:00+08:00</published><updated>2018-01-05T01:21:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-04:posts/2018/01/04/solution-for-gcin-2-8-5-2-cannot-run-in-application-using-qt-after-5-9-x-on-arch-linux/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://hyperrate.com/thread.php?tid=33785"&gt;在基於較新版qt 5.9.1的軟體中無法輸入中文&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/qutebrowser/qutebrowser"&gt;qutebrowser&lt;/a&gt; 是一款以 Vim 操作流程為主、基於 PyQt5 上開發的的輕量化瀏覽器（有點類似 &lt;a href="https://bitbucket.org/portix/dwb"&gt;dwb&lt;/a&gt;）。2017 年中的時候就知道這款瀏覽器了，但沒有特別強烈的需求，因為我在使用 Firefox 或 Chromium 的時候都有安裝 Vimium 這個套件，所以可以做到一樣的事。  &lt;/p&gt;
&lt;p&gt;2017 年後半從 Firefox 55.0 開始，使用 Quantum 之後，我就從 Chromium 又跳回 Firefox 的懷抱，但接近 2017 年年底的時候，這篇文章：&lt;a href="https://sircmpwn.github.io/2017/12/16/Firefox-is-on-a-slippery-slope.html"&gt;Firefox is on a slippery slope | Drew DeVault’s Blog&lt;/a&gt;，講到了 Firefox 和美國的 NBCUniversal "合作"，為該公司新一季的電視劇 "Mr.Robot" 作宣傳。其手法是當你在瀏覽網頁的時候，如果裏面文字有和該劇相關的關鍵字的話，就會被倒過來顯示，而且也會在你造訪某些特定網站的時候，在你的 HTTP request 加入特定的 Header。重點是這是在未經使用者同意就預設開啟的測試功能內，直接幫使用者安裝一個叫作 "Looking Glass" 的 plugin，而且如果你把它關掉的話，在下次更新 Firefox 的時候又會被自動開啟。  &lt;/p&gt;
&lt;p&gt;再者是，討論這個功能的 ticket 是被鎖定的，只有 Mozilla 內部的人可以看到。這是非常不尊重使用者的行為，尤其 Firefox 又總是以不追蹤使用者、自由的開源軟體自居。雖然 Mozilla 在幾天後發了篇道歉文：&lt;a href="https://blog.mozilla.org/firefox/update-looking-glass-add/"&gt;Update: Looking Glass Add-on | The Firefox Frontier&lt;/a&gt;，但這件事還是讓滿多人留下不好的印象的，畢竟這代表專案主導人不尊重使用者，難保之後不會又發生。  &lt;/p&gt;
&lt;p&gt;剛好這篇文章的作者有提到他已經換到 qutebrowser 一陣子了，覺得還不錯用。剛好我也有在考慮要不要換過去使用，因為用了 Firefox 一陣子，雖然有比以前快，但還是常常會 crash，而且貌似也有 Memory Leak 的問題，常常用了一陣子記憶體就會愈用愈多，得重開才能解決。所以今天就下定決心拿 qutebrowser 來當預設的瀏覽器。  &lt;/p&gt;
&lt;p&gt;有機會的話可能會寫篇關於 qutebrowser 的介紹文，因為預設的 qutebrowser 其實不太好用，我花了點時間調整了設定才覺得比較能用。但這篇文章是要紀錄我在 Arch Linux 上安裝了基於 Qt5 開發的 qutebrowser 後，無法在其中使用 gcin 輸入法打中文字的問題。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;這篇應該只有在 Arch Linux 上的使用者可能會遇到，解法是在 gcin 論壇的這個討論串看到的：&lt;a href="https://hyperrate.com/thread.php?tid=33785"&gt;在基於較新版qt 5.9.1的軟體中無法輸入中文&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;先附上發生 bug 的軟體版本：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcin 2.8.5-2  &lt;/li&gt;
&lt;li&gt;Qt 5.10.0  &lt;/li&gt;
&lt;li&gt;qutebrowser v1.0.4  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步驟：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先到 &lt;a href="https://git.archlinux.org/svntogit/packages.git/tree/trunk?h=packages/gcin"&gt;https://git.archlinux.org/svntogit/packages.git/tree/trunk?h=packages/gcin&lt;/a&gt; 把要 build &lt;code&gt;gcin&lt;/code&gt; 需要的檔案都抓下來，開個資料夾放這些檔案。  &lt;/li&gt;
&lt;li&gt;進到該資料夾內，根據討論串裡提到的解法修改 &lt;code&gt;PKGBUILD&lt;/code&gt;，加上這個 patch，&lt;a href="/files/solution-for-gcin-2-8-5-2-cannot-run-in-application-using-qt-after-5-9-x-on-arch-linux/qt-5.9.patch"&gt;這裡附上 patch 的純文字檔連結&lt;/a&gt;：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git a/gcin/trunk/PKGBUILD b/gcin/trunk/PKGBUILD  &lt;/span&gt;
&lt;span class="gh"&gt;index ca08fcb57f3..7048c13411d 100644  &lt;/span&gt;
&lt;span class="gd"&gt;--- a/gcin/trunk/PKGBUILD  &lt;/span&gt;
&lt;span class="gi"&gt;+++ b/gcin/trunk/PKGBUILD  &lt;/span&gt;
&lt;span class="gu"&gt;@@ -39,6 +39,12 @@ prepare() {  &lt;/span&gt;
         -e &amp;#39;/^MODVERSION=/a INCS+=-I/usr/include/qt/QtGui/$(MODVERSION) -I/usr/include/qt/QtCore/$(MODVERSION)&amp;#39; \  
         -i qt5-im/Makefile  

&lt;span class="gi"&gt;+    # Patch to make gcin work in qt &amp;gt;= 5.9.x  &lt;/span&gt;
&lt;span class="gi"&gt;+    # ref: &amp;lt;https://hyperrate.com/thread.php?tid=33785&amp;gt;  &lt;/span&gt;
&lt;span class="gi"&gt;+      sed \  &lt;/span&gt;
&lt;span class="gi"&gt;+          -e &amp;#39;s/org.qt-project.Qt.QPlatformInputContextFactoryInterface/&amp;amp;.5.1/&amp;#39; \  &lt;/span&gt;
&lt;span class="gi"&gt;+          -i qt5-im/gcin-qt5.h.in  &lt;/span&gt;
&lt;span class="gi"&gt;+  &lt;/span&gt;
     # FS#45732  
     patch -p1 -i ../qt-5.5.patch  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;在該資料夾內下 &lt;code&gt;makepkg -s&lt;/code&gt; 這個指令，就會開始 build gcin  &lt;/li&gt;
&lt;li&gt;build 好之後應該會出現 &lt;code&gt;gcin-2.8.5-2-x86_64.pkg.tar.xz&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;sudo pacman -U gcin-2.8.5-2-x86_64.pkg.tar.xz&lt;/code&gt; 來安裝 patch 過後的 gcin  &lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;qtplugininfo /usr/lib/qt/plugins/platforminputcontexts/libgcinplatforminputcontextplugin.so&lt;/code&gt; 來檢查  &lt;ul&gt;
&lt;li&gt;如果沒問題的話應該會得到下面這樣的輸出：  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ qtplugininfo /usr/lib/qt/plugins/platforminputcontexts/libgcinplatforminputcontextplugin.so  
IID &lt;span class="s2"&gt;&amp;quot;org.qt-project.Qt.QPlatformInputContextFactoryInterface.5.1&amp;quot;&lt;/span&gt; Qt &lt;span class="m"&gt;5&lt;/span&gt;.10.0 &lt;span class="o"&gt;(&lt;/span&gt;debug&lt;span class="o"&gt;)&lt;/span&gt;  
User Data: &lt;span class="o"&gt;{&lt;/span&gt;  
    &lt;span class="s2"&gt;&amp;quot;Keys&amp;quot;&lt;/span&gt;: &lt;span class="o"&gt;[&lt;/span&gt;  
        &lt;span class="s2"&gt;&amp;quot;gcin&amp;quot;&lt;/span&gt;  
    &lt;span class="o"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;重新開啟 gcin  &lt;/li&gt;
&lt;li&gt;重開 qutebrowser  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣應該就沒問題了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;總之，我發了一個 bug report: &lt;a href="https://bugs.archlinux.org/task/56949"&gt;FS#56949 : [gcin] gcin 2.8.5-2 cannot run in qutebrowser v1.0.4&lt;/a&gt;，希望這個 patch 會被加進去，這樣之後更新應該就沒問題了。  &lt;/p&gt;
&lt;p&gt;好像有點久沒有自己 build package 了啊，原本打算用 &lt;code&gt;abs&lt;/code&gt;，然後才想起來 &lt;code&gt;abs&lt;/code&gt; 已經被 deprecated 了：&lt;a href="https://www.archlinux.org/news/deprecation-of-abs/"&gt;Arch Linux - News: Deprecation of ABS tool and rsync endpoint&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/qutebrowser/qutebrowser"&gt;GitHub - qutebrowser/qutebrowser: A keyboard-driven, vim-like browser based on PyQt5.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://bitbucket.org/portix/dwb"&gt;portix / dwb — Bitbucket&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://sircmpwn.github.io/2017/12/16/Firefox-is-on-a-slippery-slope.html"&gt;Firefox is on a slippery slope | Drew DeVault’s Blog&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.mozilla.org/firefox/update-looking-glass-add/"&gt;Update: Looking Glass Add-on | The Firefox Frontier&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://hyperrate.com/thread.php?tid=33785"&gt;在基於較新版qt 5.9.1的軟體中無法輸入中文&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Arch Linux"></category><category term="Qt5"></category><category term="qutebrowser"></category><category term="gcin"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>嘗試在 Python 中做到 Golang fmt 的效果</title><link href="https://blog.m157q.tw/posts/2018/01/03/try-to-do-gofmt-in-python/" rel="alternate"></link><published>2018-01-18T03:11:54+08:00</published><updated>2018-01-18T03:11:54+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-03:posts/2018/01/03/try-to-do-gofmt-in-python/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;去年開始學 Golang，但早在這之前就已經聽過很多 Gopher 說過 &lt;code&gt;gofmt&lt;/code&gt; 有多麼方便，當 Pythonista 還在靠 syntax checker 和自制力來遵守 &lt;a href="https://www.python.org/dev/peps/pep-0008/"&gt;PEP8&lt;/a&gt; 的時候，Gopher 根本都不用管什麼 coding style，不管你是怎麼寫的，只要寫好之後用 &lt;code&gt;gofmt&lt;/code&gt; 執行一下，就可以自動幫你把程式碼排版排好，還可以順便幫你檢查錯誤。  &lt;/p&gt;
&lt;p&gt;故事起源於 2016 底，和平常不是寫 Python 的朋友一起弄了一個用 Python 寫的 side project，因為朋友平常不是寫 Python 的，然後那陣子他又剛好在寫 Golang，覺得要遵守 PEP8 很麻煩，所以問我 Python 有沒有類似 &lt;code&gt;go fmt&lt;/code&gt; 的工具。  &lt;/p&gt;
&lt;p&gt;當下想了一下好像還真的沒有，頂多就是像 &lt;code&gt;pep8&lt;/code&gt;, &lt;code&gt;flake8&lt;/code&gt;, &lt;code&gt;pyflakes&lt;/code&gt; 這類的 syntax checker 而已，好像沒聽聞過什麼好用的 code formatter，也因為這樣，所以開始想辦法做到這件事。  &lt;/p&gt;
&lt;p&gt;當然真的去查了之後發現還是有的，但使用起來不盡理想。於是找了些現成的程式兜一兜，再加上 git pre-commit hook 後，最後算是勉強做到了，當下有做個凌亂的紀錄，但一直沒有整理成一篇文章，利用最近離職後比較閒的時間，把它整理紀錄一下。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;紀錄&lt;/h2&gt;
&lt;p&gt;當時一開始是直接找到 GitHub 上的這個 repo: &lt;a href="https://github.com/Psycojoker/pyfmt"&gt;GitHub - Psycojoker/pyfmt: automatic code formatter for python following pep8 using baron FST, like gofmt&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;看起來好像不錯，但實際上使用起來有滿多問題的，而且作者又用了另外一個自己寫的 Python Full Syntax Tree library: &lt;a href="https://github.com/PyCQA/baron"&gt;GitHub - PyCQA/baron: IDE allow you to refactor code, Baron allows you to write refactoring code.&lt;/a&gt;，當時因為急著找現成的工具來用，所以就沒有多花時間研究。但後來才發現 PyCQA 裡頭的工具都滿不錯的: &lt;a href="https://github.com/PyCQA"&gt;Python Code Quality Authority · GitHub&lt;/a&gt;，基本上都是用來提升 Python 程式碼品質的工具，滿推薦寫 Python 的人看一下的。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;之後試了幾個工具以後，最後變成 &lt;code&gt;autoflake&lt;/code&gt; + &lt;code&gt;isort&lt;/code&gt; + &lt;code&gt;autopep8&lt;/code&gt; + git pre-commit hook 來做到這件事，老實說真的有點繁瑣，但我找不到更好的方法，如果有人知道的話還請不吝告知。  &lt;/p&gt;
&lt;p&gt;總之，接下來稍微介紹一下這幾個工具分別做了哪些事：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;autoflake&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/myint/autoflake"&gt;GitHub - myint/autoflake: Removes unused imports and unused variables as reported by pyflakes&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;就如同其 GitHub 的敘述，可以把沒有用到的 &lt;code&gt;import&lt;/code&gt; 和變數移除。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isort&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/timothycrosley/isort"&gt;GitHub - timothycrosley/isort: A Python utility / library to sort imports.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;可以針對 Python 的 imports 做符合 PEP8 的字母序排序。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;autopep8&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/hhatto/autopep8"&gt;GitHub - hhatto/autopep8: A tool that automatically formats Python code to conform to the PEP 8 style guide.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;可以將 Python 程式碼自動以符合 PEP8 的方式排版。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;git pre-commit hook  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks"&gt;Git - Git Hooks&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;pre-commit hook 的觸發時間是在使用者下 &lt;code&gt;git commit&lt;/code&gt; 後，編寫 commit message 之前。  &lt;/li&gt;
&lt;li&gt;這裡是用來確保使用者每次 commit 的 Python 程式碼會被以上這三種程式處理過。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;後來發現 Google 也出了一個 Python formatter: &lt;a href="https://github.com/google/yapf"&gt;GitHub - google/yapf: A formatter for Python files&lt;/a&gt;，用了以後覺得比 &lt;code&gt;autopep8&lt;/code&gt; 好用，所以就把 &lt;code&gt;autopep8&lt;/code&gt; 換成 &lt;code&gt;yapf&lt;/code&gt; 了：&lt;a href="https://github.com/pellaeon/fengyuan/commit/abc9fc995a9c49fa208716954c2bc262fe6b783e"&gt;Use yapf instead of autopep8 as python code formatter. · pellaeon/fengyuan@abc9fc9 · GitHub&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;結果&lt;/h2&gt;
&lt;p&gt;最後的結果就是整合到一個 git pre-commit hook 裡頭，麻煩的是 clone 下來以後，得用這個指令初始化 git pre-commit hook：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ln -sf ../../pre-commit.sh .git/hooks/pre-commit  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其實還是很麻煩，之後應該會再繼續尋找有沒有更方便的方法，不排除自己寫一個就是。  &lt;/p&gt;
&lt;p&gt;最後的結果就是一個 git pre-commit hook：&lt;a href="https://github.com/pellaeon/fengyuan/blob/master/pre-commit.sh"&gt;fengyuan/pre-commit.sh at master · pellaeon/fengyuan · GitHub&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;以下直接複製貼上原程式碼留個紀錄，以防哪天 GitHub 掛了。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh  &lt;/span&gt;
&lt;span class="c1"&gt;#  &lt;/span&gt;
&lt;span class="c1"&gt;# An example hook script to verify what is about to be committed.  &lt;/span&gt;
&lt;span class="c1"&gt;# Called by &amp;quot;git commit&amp;quot; with no arguments.  The hook should  &lt;/span&gt;
&lt;span class="c1"&gt;# exit with non-zero status after issuing an appropriate message if  &lt;/span&gt;
&lt;span class="c1"&gt;# it wants to stop the commit.  &lt;/span&gt;
&lt;span class="c1"&gt;#  &lt;/span&gt;
&lt;span class="c1"&gt;# To enable this hook, rename this file to &amp;quot;pre-commit&amp;quot;.  &lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; git rev-parse --verify HEAD &amp;gt;/dev/null &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;  
&lt;span class="k"&gt;then&lt;/span&gt;  
    &lt;span class="nv"&gt;against&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;HEAD  
&lt;span class="k"&gt;else&lt;/span&gt;  
    &lt;span class="c1"&gt;# Initial commit: diff against an empty tree object  &lt;/span&gt;
    &lt;span class="nv"&gt;against&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;4b825dc642cb6eb9a060e54bf8d69288fbee4904  
&lt;span class="k"&gt;fi&lt;/span&gt;  

&lt;span class="c1"&gt;# If you want to allow non-ASCII filenames set this variable to true.  &lt;/span&gt;
&lt;span class="nv"&gt;allownonascii&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;git config --bool hooks.allownonascii&lt;span class="k"&gt;)&lt;/span&gt;  

&lt;span class="c1"&gt;# Redirect output to stderr.  &lt;/span&gt;
&lt;span class="nb"&gt;exec&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;  

&lt;span class="c1"&gt;# Cross platform projects tend to avoid non-ASCII filenames; prevent  &lt;/span&gt;
&lt;span class="c1"&gt;# them from being added to the repository. We exploit the fact that the  &lt;/span&gt;
&lt;span class="c1"&gt;# printable range starts at the space character and ends with tilde.  &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$allownonascii&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;  
    &lt;span class="c1"&gt;# Note that the use of brackets around a tr range is ok here, (it&amp;#39;s  &lt;/span&gt;
    &lt;span class="c1"&gt;# even required, for portability to Solaris 10&amp;#39;s /usr/bin/tr), since  &lt;/span&gt;
    &lt;span class="c1"&gt;# the square bracket bytes happen to fall in the designated range.  &lt;/span&gt;
    &lt;span class="nb"&gt;test&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;git diff --cached --name-only --diff-filter&lt;span class="o"&gt;=&lt;/span&gt;A -z &lt;span class="nv"&gt;$against&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;  
      &lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;C tr -d &lt;span class="s1"&gt;&amp;#39;[ -~]\0&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; wc -c&lt;span class="k"&gt;)&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;  
&lt;span class="k"&gt;then&lt;/span&gt;  
    cat &lt;span class="s"&gt;&amp;lt;&amp;lt;\EOF  &lt;/span&gt;
&lt;span class="s"&gt;Error: Attempt to add a non-ASCII file name.  &lt;/span&gt;

&lt;span class="s"&gt;This can cause problems if you want to work with people on other platforms.  &lt;/span&gt;

&lt;span class="s"&gt;To be portable it is advisable to rename the file.  &lt;/span&gt;

&lt;span class="s"&gt;If you know what you are doing you can disable this check using:  &lt;/span&gt;

&lt;span class="s"&gt;  git config hooks.allownonascii true  &lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;  
    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;  
&lt;span class="k"&gt;fi&lt;/span&gt;  

&lt;span class="c1"&gt;# Run syntax checker and formatter for Python files.  &lt;/span&gt;
&lt;span class="nv"&gt;STAGED_PYTHON_FILES&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;git diff --cached --name-only HEAD &lt;span class="s2"&gt;&amp;quot;*.py&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;  

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$STAGED_PYTHON_FILES&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;  
&lt;span class="k"&gt;then&lt;/span&gt;  
    autoflake -i --remove-all-unused-imports --remove-unused-variables &lt;span class="nv"&gt;$STAGED_PYTHON_FILES&lt;/span&gt;  
    isort -y &lt;span class="nv"&gt;$STAGED_PYTHON_FILES&lt;/span&gt;  
    yapf -i &lt;span class="nv"&gt;$STAGED_PYTHON_FILES&lt;/span&gt;  
    git add &lt;span class="nv"&gt;$STAGED_PYTHON_FILES&lt;/span&gt;  
&lt;span class="k"&gt;fi&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Psycojoker/pyfmt"&gt;GitHub - Psycojoker/pyfmt: automatic code formatter for python following pep8 using baron FST, like gofmt&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/PyCQA/baron"&gt;GitHub - PyCQA/baron: IDE allow you to refactor code, Baron allows you to write refactoring code.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/myint/autoflake"&gt;GitHub - myint/autoflake: Removes unused imports and unused variables as reported by pyflakes&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/timothycrosley/isort"&gt;GitHub - timothycrosley/isort: A Python utility / library to sort imports.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/hhatto/autopep8"&gt;GitHub - hhatto/autopep8: A tool that automatically formats Python code to conform to the PEP 8 style guide.&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks"&gt;Git - Git Hooks&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/google/yapf"&gt;GitHub - google/yapf: A formatter for Python files&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pellaeon/fengyuan/commit/abc9fc995a9c49fa208716954c2bc262fe6b783e"&gt;Use yapf instead of autopep8 as python code formatter. · pellaeon/fengyuan@abc9fc9 · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pellaeon/fengyuan/commit/2de3e199f2193ea25f4cd5bbb7f89673879862c6"&gt;Add git pre-commit hook for python files. · pellaeon/fengyuan@2de3e19 · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pellaeon/fengyuan/blob/master/pre-commit.sh"&gt;fengyuan/pre-commit.sh at master · pellaeon/fengyuan · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category><category term="formatter"></category><category term="Golang"></category><category term="gofmt"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>Facebook 網址的一些黑魔法</title><link href="https://blog.m157q.tw/posts/2018/01/02/tips-about-facebook-url/" rel="alternate"></link><published>2018-01-03T19:01:27+08:00</published><updated>2018-01-03T19:01:27+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-02:posts/2018/01/02/tips-about-facebook-url/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://netbootcamp.org/facebookpeoplesearchtips/"&gt;https://netbootcamp.org/facebookpeoplesearchtips/&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;去年因為一些事件得知 Facebook 的網址列可以針對單一使用者作滿多查詢的，當下就有紀錄起來，但遲遲沒有整理成一篇文章。其實也是看到有人講了以後去做了些查詢，發現這篇英文文章：&lt;a href="https://netbootcamp.org/facebookpeoplesearchtips/"&gt;Facebook People Search Tips | OSINT Training by Bob Brasich&lt;/a&gt; 整理的挺完整的，所以這篇文章算是擷取整理這篇文章的內容，然後以中文呈現。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;要先知道什麼是 Facebook User ID&lt;/h2&gt;
&lt;p&gt;首先，你要知道你想查詢的使用者在 Facebook 上的 ID 是什麼，對這個有點概念的人都會知道這是一串流水號，而最常見的例子就是 Facebook 創辦人 Mark Zuckerburg 本人的 Facebook ID 是 4，所以你只要連到 &lt;a href="https://www.facebook.com/4"&gt;https://www.facebook.com/4&lt;/a&gt;，就會連到 Mark Zuckerburg 本人的 Facebook 頁面，而每一位 Facebook 使用者都會有這樣一個不與其他使用者重複的流水號作為其 Facebook 的 ID。  &lt;/p&gt;
&lt;p&gt;在接下來的使用方式裡頭，一定要要拿到使用者的 ID，拿到使用者自己自訂的唯一 username 是沒用的。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;要怎麼拿到 Facebook 使用者的 ID？&lt;/h2&gt;
&lt;p&gt;如果該名使用者沒有自訂 username 的話，只要連到該名 Facebook 使用者的個人頁面後，檢查一下網址列，就會看到最後面應該會是一串數字，那個就是該名使用者的 Facebook。  &lt;/p&gt;
&lt;p&gt;如果該名使用者有自訂 username 的話，你連到他的 Facebook 個人頁面應該會看到網址最後面就是他自訂的 username，而不會是 Facebook User ID。這時候可以透過這個網頁來做查詢：&lt;a href="https://findmyfbid.in"&gt;https://findmyfbid.in&lt;/a&gt;，這個網站本身就有教學了，用法也很簡單。  &lt;/p&gt;
&lt;p&gt;一樣是連到該名 Facebook 使用者的個人頁面，把他的網址複製下來，然後貼到 &lt;a href="https://findmyfbid.in"&gt;https://findmyfbid.in&lt;/a&gt; 進行查詢就行了。如果有順利查詢到的話，就會得到代表該名 Facebook 使用者的一串數字，即為其 ID。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;拿到 ID 後？&lt;/h2&gt;
&lt;p&gt;就可以進入正題了，一般人在 Facebook 進行搜尋的時候，應該普遍都是透過網頁上方的 Search bar 進行搜尋吧？這些查詢的結果都是透過 API 進行搜尋的，其實可以透過修改網址直接得到查詢結果，操作方式也不難，以下簡單講解。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;基本格式&lt;/h2&gt;
&lt;p&gt;最基本的網址格式長的像這樣：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://www.facebook.com/search/str/$FACEBOOK_USER_ID&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;也可以是  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;fb.com/search/str/$FACEBOOK_USER_ID&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;以 Mark Zuckerburg 為例的話，就會是：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://www.facebook.com/search/str/4&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;或是  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;fb.com/search/4&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;知道了這個基本格式以後，接下來會加上的參數都是加在後面，就可以得到相對應的搜尋結果，這個方法可以用在所有的使用者身上，但得到的結果會是以你登入的 Facbeook 帳號權限而定，並不會得到該名使用者所有的資訊，除非你是查詢你目前登入的 Facebook 使用者。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;基本參數&lt;/h2&gt;
&lt;p&gt;以下參數都是直接接在上面提到的基本格式字串的後面就行了，會是這樣的形式：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;fb.com/search/str/$FACEBOOK_USER_ID/$OPTION&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;舉例來說，如果選項是下面提到的 &lt;code&gt;/photos-by/&lt;/code&gt; 的話，就會是這樣使用：  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://fb.com/search/4/photos-by/"&gt;&lt;code&gt;fb.com/search/4/photos-by/&lt;/code&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;其他參數依此類推，以下就列出有哪些參數可以使用，因為這些參數其實都已經和使用英文版 Facebook 搜尋時會顯示的一般英文一樣了，所以就不多做說明，有興趣的人可以試一試。  &lt;/p&gt;
&lt;h3&gt;和發文有關的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/stories-by/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-liked/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-commented/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-publishers/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-tagged/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-media-tagged/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-in/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-topic/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-news/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-recent/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/reshare-stories-by/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/reviews-at/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/hashtag/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;和照片有關的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/photos-by/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-uploaded/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-of/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-tagged/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-in/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-keyword/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-liked/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-commented/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-interested/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-interacted/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-recommended-for/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/recent-photos/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;和按讚有關的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/stories-liked/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-liked/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;和留言有關的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/stories-commented/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-commented/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;和打卡、地點、評論有關的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/recent-places-visited/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/places-visited/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/places-checked-in/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/visitors/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/places-named/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/places-in/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/places-near/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/places-reviewed/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/pages-in/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/stories-at/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/reviews-at/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/events-at/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/events-near/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/residents/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/home-residents/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/users-birth-place/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;善用這些搜尋網址可能可以在 Facebook 上做更有效的搜尋，有些是透過預設的搜尋介面比較難選取到的部份，參考的這篇文章：&lt;a href="https://netbootcamp.org/facebookpeoplesearchtips/"&gt;Facebook People Search Tips | OSINT Training by Bob Brasich&lt;/a&gt; 裡頭還有提到一些更進階的小技巧，可以結合兩個參數做搜尋，例如搜尋某間公司擁有某個名字的 Facebook 使用者、搜尋住處在某個地方擁有某個姓名的使用者、……等等，像下面這些參數就是可以用來做更進階一些搜尋用的參數：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和時間有關的  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;/yesterday/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/today/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/this-week/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/last-week/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/recent/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/this-month/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/last-month/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/this-year/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/last-year/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/YEAR/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/before/ /after/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;和關鍵字有關的  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;/stories-keyword/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/photos-keyword/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;和名字有關的  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;/users-named/&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;/pages-named/&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這部份必須要在網址最後加上 &lt;code&gt;/intersect/&lt;/code&gt;，表示取這幾個選項的交集做搜尋，格式也有稍稍的不太一樣，這邊就不做詳細的介紹，有興趣的人可以再點下面參考文章的第一篇進去察看，裏面有滿多實際例子的。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://netbootcamp.org/facebookpeoplesearchtips/"&gt;Facebook People Search Tips | OSINT Training by Bob Brasich&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://findmyfbid.in/"&gt;Find Facebook ID in two simple steps | Find Facebook ID&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Facebook"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>Linux 上如何透過指令更改鍵盤鍵位</title><link href="https://blog.m157q.tw/posts/2018/01/01/change-keymap-on-linux/" rel="alternate"></link><published>2018-01-02T22:17:41+08:00</published><updated>2018-01-02T22:17:41+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2018-01-01:posts/2018/01/01/change-keymap-on-linux/</id><summary type="html">&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setxkbmap -option ctrl:swapcaps -option altwin:swap_alt_win&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/M157q/dotfiles/blob/master/swap_win_keyboard_layout.sh"&gt;dotfiles/swap_win_keyboard_layout.sh at master · M157q/dotfiles · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setxkbmap -option ctrl:swapcaps&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/M157q/dotfiles/blob/master/swap_mac_keyboard_layout.sh"&gt;dotfiles/swap_mac_keyboard_layout.sh at master · M157q/dotfiles · GitHub&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這邊提到的都會是在 X Window 環境下的設定方式為主，這是我目前正在使用也確定可行的方法。非 X Window 的環境下則是放在補充，但因為這部份我沒有親自試過，所以僅供參考。  &lt;/p&gt;
&lt;p&gt;之前都是用 &lt;code&gt;xmodmap&lt;/code&gt; 這個指令，搭配一份已經預先寫好的設定檔：&lt;a href="https://github.com/M157q/dotfiles/blob/master/Xmodmap"&gt;dotfiles/Xmodmap at master · M157q/dotfiles · GitHub&lt;/a&gt;，讓 &lt;code&gt;xmodmap&lt;/code&gt; 去執行這份設定檔，它會依照設定檔把鍵位更換掉。但因為我有時候是使用 Mac Book Air 的 Mac 鍵盤，有時候是外接 Filco 的鍵盤，差別最大的地方在於左下角。Mac 的鍵盤會多了一顆 Command 鍵，然後在桌面環境下，無論是我之前使用的 AwesomeWM 或是現在使用的 i3wm，在使用 Mac 鍵盤的時候會以 Command 鍵來當作 Mod4 鍵，但在非 Mac 鍵盤上，則會以 Win 鍵來當作 Mod4 鍵。  &lt;/p&gt;
&lt;p&gt;問題就在於我已經習慣 Mac 鍵盤上的設定，覺得 Mod4 鍵在空白鍵的左邊比較順手，如果使用非 Mac 鍵盤的話，Mod4 鍵則會在空白鍵左邊的左邊，按起來比較抝手。所以針對不同的鍵盤我得有不同鍵位的改變設定，讓我的操作習慣一致。  &lt;/p&gt;
&lt;p&gt;之前就覺得 &lt;code&gt;xmodmap&lt;/code&gt; 的設定檔有點冗長，我只是要單純切換 CapsLock 和左邊的 Ctrl 鍵就要 6 行，等於是我要寫另外一份設定檔，加上我去看了設定檔的文件，覺得挺麻煩的，我也常常搞混。於是就花了點時間找尋看看有沒有比較方便的方式，後來找到 &lt;code&gt;setxkbmap&lt;/code&gt; 這個指令，可以直接一行指令解決，利用這篇文章紀錄一下。  &lt;/p&gt;
&lt;p&gt;不管是 Mac 鍵盤上的 Command 鍵，或是非 Mac 鍵盤上的 Win 鍵，在 X Window 的鍵位判定上都會被當作是 "Super" 鍵，即這兩個會被當成是一樣作用的按鈕，但是他們在鍵盤上排列的位置卻不相同：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mac 鍵盤，Command 鍵都是在空白鍵隔壁。  &lt;/li&gt;
&lt;li&gt;非 Mac 鍵盤，Win 鍵都是在空白鍵隔壁的隔壁，中間隔著一個 Alt 鍵。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是只要我使用非 Mac 鍵盤的話，我就會需要把 Super 鍵和 Alt 鍵對調。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;首先當然是得安裝 &lt;code&gt;setxkbmap&lt;/code&gt; 這個程式，如果是使用 Arch Linux 的話，可以用以下指令安裝：&lt;br /&gt;
&lt;code&gt;sudo pacman -S xorg-setxkbmap&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;安裝好了之後，使用方式也很簡單，就只要一行指令就行，然後每一個設定就使用 &lt;code&gt;-option&lt;/code&gt; 參數來設定，有三個設定就會有三個 &lt;code&gt;-option&lt;/code&gt;。切換的規則可以在 &lt;code&gt;/usr/share/X11/xkb/rules/base&lt;/code&gt; 找到，我覺得名稱還算好懂，但裏面其實有滿多規則的，這篇文章裏面不會一一介紹，只會講到我有用到的。  &lt;/p&gt;
&lt;p&gt;舉例來說，如果我要單純把 Ctrl 和 CapsLock 對調的話，就使用以下指令：&lt;br /&gt;
&lt;code&gt;setxkbmap -option ctrl:swapcaps&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;如果要把 Ctrl 和 CapsLock 對調還要把 Alt 和 Win 鍵對調的話，就使用以下指令：&lt;br /&gt;
&lt;code&gt;setxkbmap -option ctrl:swapcaps -option altwin:swap_alt_win&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;可以透過 &lt;code&gt;-device&lt;/code&gt; 這個參數來做到只針對特定的鍵盤來更改鍵位，不會同時更 MacBook Air 本身的鍵盤和 USB 外接鍵盤。至於這個參數要接的 device id 則可以透過 &lt;code&gt;xinput&lt;/code&gt; 這個指令來察看。而原先使用的 &lt;code&gt;xmodmap&lt;/code&gt; 則貌似無法針對個別鍵盤來做設定。  &lt;/p&gt;
&lt;p&gt;但每次要從已經更改後的鍵位，換到另外一個更改鍵位的時候，不能直接使用指令切換，而是得先用 &lt;code&gt;setxkbmap -option&lt;/code&gt; 來重置鍵位，然後才能再下另外一個指令來切換到另外一種鍵位，因為 &lt;code&gt;setxkbmap&lt;/code&gt; 預設是會繼續新增 &lt;code&gt;-option&lt;/code&gt; 到目前的設定，這也是為什麼我上面自己整理的兩個 script 的第一行都要先用 &lt;code&gt;setxkbmap -option&lt;/code&gt; 的原因。如果不這樣做的話，可能會出現很奇怪的狀況，這點是要注意的。在 &lt;code&gt;man setxkbmap&lt;/code&gt; 裡頭關於 &lt;code&gt;-option&lt;/code&gt; 的說明部份也有提到這點：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="setxkbmap-option" src="/files/change-keymap-on-linux/setxkbmap-option.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;補充：xkbcomp&lt;/h2&gt;
&lt;p&gt;其實在 X Window 底下，除了使用 &lt;code&gt;xmodmap&lt;/code&gt; 和 &lt;code&gt;setxkbmap&lt;/code&gt; 兩個指令以外，還有一個 &lt;code&gt;xkbcomp&lt;/code&gt; 指令可以使用，但因為我覺得這個指令還是沒有 &lt;code&gt;setxkbmap&lt;/code&gt; 來得方便，所以後來沒有採用。&lt;code&gt;xkbcomp&lt;/code&gt; 一樣可以透過 &lt;code&gt;-i&lt;/code&gt; 來針對個別鍵盤做設定，而 device id 也是一樣透過 &lt;code&gt;xinput&lt;/code&gt; 這個指令來察看。  &lt;/p&gt;
&lt;p&gt;有關於 &lt;code&gt;xkbcomp&lt;/code&gt; 的設定：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;簡單的範例可以參考這篇文章：&lt;a href="https://lampjs.wordpress.com/2015/06/26/remapchange-your-secondaryusb-keyboard-keys/"&gt;Remap/change your secondary/usb keyboard keys – Linux, Apache, MySQL, PHP, Javascript&lt;/a&gt;。  &lt;/li&gt;
&lt;li&gt;詳細一點的可以參考 ArchWiki：&lt;a href="https://wiki.archlinux.org/index.php/X_KeyBoard_extension#Multiple_keyboards"&gt;X KeyBoard extension - ArchWiki&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;補充：在無 X Window 的 virtual console 環境下切換鍵位&lt;/h2&gt;
&lt;p&gt;其實也有找到方法，在這篇文章有提到：&lt;a href="https://www.emacswiki.org/emacs/MovingTheCtrlKey#toc7"&gt;EmacsWiki: Moving The Ctrl Key&lt;/a&gt;，可以使用 &lt;code&gt;dumpkeys&lt;/code&gt; 和 &lt;code&gt;loadkeys&lt;/code&gt; 這兩個指令來辦到，但目前沒有強烈需求，如果哪天真的有在非 X Window 的環境下做到這件事不可的動機的話，應該就會花點時間來設定，看起來其實也是以下這樣的步驟，只是是在非 X Window 的環境下使用：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 &lt;code&gt;dumpkeys&lt;/code&gt; 匯出鍵位設定檔  &lt;/li&gt;
&lt;li&gt;修改設定檔  &lt;/li&gt;
&lt;li&gt;再用 &lt;code&gt;loadkeys&lt;/code&gt; 匯入鍵位設定檔  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://superuser.com/questions/760602/how-to-remap-keys-under-linux-for-a-specific-keyboard-only"&gt;How to remap keys under Linux for a specific keyboard only - Super User&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.reddit.com/r/linux/comments/1kyikn/a_one_line_command_to_remap_the_capslock_key_to/"&gt;A one line command to remap the CapsLock key to Ctrl : linux&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://askubuntu.com/questions/33774/how-do-i-remap-the-caps-lock-and-ctrl-keys"&gt;keyboard - How do I remap the Caps Lock and Ctrl keys? - Ask Ubuntu&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.noah.org/wiki/CapsLock_Remap_Howto"&gt;CapsLock Remap Howto - Noah.org&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇也算是篇滿完整的文章，重點是它是個人用 Wiki 的頁面，覺得很厲害。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://lampjs.wordpress.com/2015/06/26/remapchange-your-secondaryusb-keyboard-keys/"&gt;Remap/change your secondary/usb keyboard keys – Linux, Apache, MySQL, PHP, Javascript&lt;/a&gt;。  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/X_KeyBoard_extension#Multiple_keyboards"&gt;X KeyBoard extension - ArchWiki&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.emacswiki.org/emacs/MovingTheCtrlKey#toc7"&gt;EmacsWiki: Moving The Ctrl Key&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Keymap"></category><category term="xmodmap"></category><category term="setxkbmap"></category><category term="X Window"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>Linux 上如何拿到 iPhone 裡的資料</title><link href="https://blog.m157q.tw/posts/2017/12/31/mount-iphone-on-linux/" rel="alternate"></link><published>2017-12-31T19:01:07+08:00</published><updated>2017-12-31T19:01:07+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-31:posts/2017/12/31/mount-iphone-on-linux/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;今年 4 月換新手機，因為不愛大尺寸的手機，五吋以下的手機只剩 iPhone SE 和 Sony Xperia X Compact。但查了一下以後發現 Sony Xperia XC 似乎有過熱的問題，加上剛好當時在公司的時候有位同事幾週前才買 iPhone SE，跟他借來操作一下覺得還不錯，上網查了一些評價也都沒啥問題，而且又是秉持當初 Steve Jobs 的 iPhone 設計造型，於是就買了。  &lt;/p&gt;
&lt;p&gt;因為之前都是用 Android 手機，所以對 iPhone 的生態系不太熟，花了一點時間熟悉，其中一個就是現在紀錄的這篇。以前 Android 手機用 USB 線接到電腦後，基本上只要用 &lt;code&gt;adb&lt;/code&gt; 就可以搞定一切了，但 iPhone 這邊我花了點時間熟悉一下，還好有 ArchWiki 上有一篇專門在講 iOS 的條目：&lt;a href="https://wiki.archlinux.org/index.php/IOS"&gt;iOS - ArchWiki&lt;/a&gt;，省事了不少。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;方法&lt;/h2&gt;
&lt;p&gt;首先要安裝 &lt;code&gt;ifuse&lt;/code&gt;，如果是 Arch Linux 的使用者，可以直接用以下指令來安裝：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo pacman -S ifuse&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;安裝好之後使用也很簡單，只要按照以下的步驟：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;將你的 iPhone 接上電腦的 USB 埠  &lt;/li&gt;
&lt;li&gt;接上之後可以透過 &lt;code&gt;lsusb&lt;/code&gt; 或 &lt;code&gt;dmesg&lt;/code&gt; 來做確認  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifuse ${PATH_FOR_IPHONE_DATA}&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;透過這個指令就可以 mount iPhone 的資料了  &lt;/li&gt;
&lt;li&gt;以我來說的話，我是特別開了一個 &lt;code&gt;/media/iPhone-SE&lt;/code&gt; 的資料夾來使用，所以指令會是 &lt;code&gt;ifuse /media/iPhone-SE&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;記得資料夾的權限要設定好  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;umount ${PATH_FOR_IPHONE_DATA}&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;使用完了以後要 unmount 也很簡單，就直接透過上面這個指令就行了  &lt;/li&gt;
&lt;li&gt;如果出現 Permission Denied 的話就加上 &lt;code&gt;sudo&lt;/code&gt; 吧  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.archlinux.org/index.php/IOS"&gt;iOS - ArchWiki&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="iPhone"></category><category term="ifuse"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>使用 Git 時如何做出跨 repo 的 cherry-pick</title><link href="https://blog.m157q.tw/posts/2017/12/30/git-cross-repo-cherry-pick/" rel="alternate"></link><published>2017-12-31T01:52:05+08:00</published><updated>2017-12-31T01:52:05+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-30:posts/2017/12/30/git-cross-repo-cherry-pick/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;會有這個需求是因為在前公司的時候，有個舊的 repo 執行的服務被因為裡頭的程式碼有太多舊的東西，但仍然有目前要用的部份，所以複製到了一個新的 repo。同時舊的這邊的改動又有需要更新到新的 repo，所以必須做到跨 repo 的 cherry-pick。查了一下，StackOverflow 上也有不少人問，打聽了一下身邊工程師的朋友們，也有人有過同樣的需求。這篇把我知道的 3 個方法整理起來，並列出哪個比較好及為什麼比較好的原因。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git format-patch -k --stdout ${commit_hash_1}..${commmit_hash_2} | git am -3 -k&lt;/code&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;"git remote add + git fetch + git cherry-pick"&lt;/h3&gt;
&lt;p&gt;這個應該是最好懂的，只要有在 GitHub 上 fork 過別人的 repo，並按照 GitHub 的官方教學把對方的 repo 用 &lt;code&gt;git remote add&lt;/code&gt; 設定成 upstream 的人，對這套流程應該不陌生，大概就是以下的步驟：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git remote add&lt;/code&gt; 有你想要 &lt;code&gt;cherry-pick&lt;/code&gt; 的 commit 的 repo  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;git fetch&lt;/code&gt; 剛剛設定好的 remote  &lt;/li&gt;
&lt;li&gt;fetch 下來後就可以 &lt;code&gt;git checkout&lt;/code&gt; 到你要的 branch，然後用 &lt;code&gt;git log&lt;/code&gt; 找尋你要的 commit，紀錄下來後就可以進行 &lt;code&gt;cherry-pick&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果這樣還是不太懂的話，底下有人回覆了這篇文章：&lt;a href="https://coderwall.com/p/sgpksw/git-cherry-pick-from-another-repository"&gt;Git cherry-pick from another repository (Example)&lt;/a&gt;，把完整的步驟與指令都清楚的列出來了。  &lt;/p&gt;
&lt;p&gt;這個方式很好懂，但很麻煩，因為步驟真的有點多。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;"git diff + git apply"&lt;/h3&gt;
&lt;p&gt;比較進階一點的 Git user 會用這個方法，觀念上沒有很難懂，只是要瞭解 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git apply&lt;/code&gt; 這兩個指令在幹嘛。其實從字面上看來大概就可以猜測到，&lt;code&gt;git diff&lt;/code&gt; 生出一個 diff 檔，而 &lt;code&gt;git apply&lt;/code&gt; 把這個 diff 檔 apply 到某個 branch 上。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 應該對大部分的 git user 來說不陌生，主要都是在修改檔案後要 &lt;code&gt;git add&lt;/code&gt; 之前，用 &lt;code&gt;git diff ${FILE_PATH}&lt;/code&gt; 來確認某個檔案修改的部份。但 &lt;code&gt;git diff&lt;/code&gt; 也可以用來看從 A commit 到 B commit 之間修改了哪些東西，用法也不難，&lt;code&gt;git diff ${A_COMMIT_HASH} ${B_COMMIT_HASH}&lt;/code&gt; 就行了。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;git apply&lt;/code&gt; 可能是一般 Git user 比較少用到的，但也沒有很難懂。&lt;code&gt;man git-apply&lt;/code&gt; 顯示的簡介是 &lt;strong&gt;git-apply - Apply a patch to files and/or to the index&lt;/strong&gt;，簡單來說就把一個 patch 檔 apply 到你現在的 branch。  &lt;/p&gt;
&lt;p&gt;知道了這兩個指令在幹嘛以後，我們就可以透過以下步驟來達到我們想要的效果：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git diff ${A_COMMIT_HASH} ${B_COMMIT_HASH} &amp;gt; xxx.patch&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;在我們要抓 commmits 的 repo 下這行指令得到 patch 檔，以我的例子來說就是舊 repo。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git apply xxx.patch&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在我們要加入這些 commits 的 repo 使用這行指令把 commits 新增進來，以我的例子來說就是新 repo。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要記住 xxx.patch 的路徑要是對的，因為上個指令產生的 xxx.patch 應該是不會在新 repo 的目錄底下才對 XD  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在 &lt;code&gt;git apply&lt;/code&gt; 的過程中遇到 trailing whitespace error 的話，可以參考這篇文章：&lt;a href="https://stackoverflow.com/questions/14509950/my-diff-contains-trailing-whitespace-how-to-get-rid-of-it"&gt;git - My diff contains trailing whitespace - how to get rid of it? - Stack Overflow&lt;/a&gt;，透過加入 &lt;code&gt;--whitespace=warn&lt;/code&gt; 或 &lt;code&gt;--whitespace=nowarn&lt;/code&gt; 參數來解決。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這樣是不是比上面那個步驟少多了？但這個方法有個缺點，就是使用 &lt;code&gt;git apply&lt;/code&gt; 的話，committer 會是使用 &lt;code&gt;git apply&lt;/code&gt; 的人，而不是原本的 committer，所以要介紹下面這個方法。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;"git format-patch + git am"&lt;/h3&gt;
&lt;p&gt;這個是 3 個方法裏面最推薦的，最後會講一下 GitHub 有一個小方法可以直接拿到 patch，可以直接給 &lt;code&gt;git am&lt;/code&gt; 使用。  &lt;/p&gt;
&lt;p&gt;基本上這方法應該是最正統的如何把別人的 commit 拿來給自己用的方式了，GitHub 也只是把這個包裝起來而已。如果是已經習慣透過 email 或者論壇收發 patch 的 Open Source contributer 兼 git 使用者，應該對這個方法習以為常。  &lt;/p&gt;
&lt;p&gt;一般的 GitHub user 應該都對這兩個指令不熟，因為 GitHub 已經把這塊都處理好了，所以使用者基本上不太需要自己操作。&lt;code&gt;man git-format-patch&lt;/code&gt; 和 &lt;code&gt;man git-am&lt;/code&gt; 就可以看到，這兩個指令基本上都是設計成在 email 的環境下使用：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;man git-format-patch&lt;/code&gt;: &lt;strong&gt;git-format-patch - Prepare patches for e-mail submission&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;man git-am&lt;/code&gt;: &lt;strong&gt;git-am - Apply a series of patches from a mailbox&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有興趣的人可以自己去看個詳細，這邊就不多談，直接講使用方法：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git format-patch -k --stdout ${A_COMMIT_HASH}..${B_COMMIT_HASH} &amp;gt; xxx.patch&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;在我們要抓 commmits 的 repo 下這行指令，以我的例子來說就是舊 repo。  &lt;/li&gt;
&lt;li&gt;A commit 要比 B commit 早，不然 output 會是空的。  &lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;--keep-subject&lt;/code&gt;: Do not strip/add [PATCH] from the first line of the commit log message.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;加入 &lt;code&gt;-k&lt;/code&gt; 這個參數的話， commit log 的第一行就不會加上 &lt;code&gt;[PATCH]&lt;/code&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git am -k -3 &amp;lt; xxx.patch&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;在我們要加入這些 commits 的 repo 使用這行指令，以我的例子來說就是新 repo。  &lt;ul&gt;
&lt;li&gt;要記住 xxx.patch 的路徑要是對的，因為上個指令產生的 xxx.patch 應該是不會在新 repo 的家目錄底下才對 XD  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-k&lt;/code&gt; 是為了接收加了 &lt;code&gt;-k&lt;/code&gt; 參數沒有加了 &lt;code&gt;[PATCH]&lt;/code&gt; 字串的 patch 檔  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;-3&lt;/code&gt; 是使用 three-way merge  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其實跟 &lt;code&gt;git diff&lt;/code&gt; + &lt;code&gt;git apply&lt;/code&gt; 非常像。  &lt;/p&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/a/9507417"&gt;在 StackOverflow 上的這個回答&lt;/a&gt; 直接教你怎麼把這兩個指令合在 1 行解決。  &lt;/p&gt;
&lt;h4&gt;GitHub 支援 &lt;code&gt;git format-patch&lt;/code&gt; 的小功能&lt;/h4&gt;
&lt;p&gt;GitHub 其實可以在 commit, pull request, compare 的網址後面加上 &lt;code&gt;.patch&lt;/code&gt;，就會拿到 &lt;code&gt;git format-patch&lt;/code&gt; 產生的檔案，不過這邊的 output 是沒有加 &lt;code&gt;-k&lt;/code&gt; 參數的，所以會有 "[PATCH]" 字串，以下是範例：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commit: &lt;a href="https://github.com/zdict/zdict/commit/b871cd6c8a6a71f595fe93132cc9d5c9a71eb82d.patch"&gt;https://github.com/zdict/zdict/commit/b871cd6c8a6a71f595fe93132cc9d5c9a71eb82d.patch&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;pull request: &lt;a href="https://patch-diff.githubusercontent.com/raw/zdict/zdict/pull/149.patch"&gt;https://patch-diff.githubusercontent.com/raw/zdict/zdict/pull/149.patch&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;compare: &lt;a href="https://github.com/zdict/zdict/compare/issue-23.patch"&gt;https://github.com/zdict/zdict/compare/issue-23.patch&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/5120038/is-it-possible-to-cherry-pick-a-commit-from-another-git-repository/9507417#9507417"&gt;Is it possible to cherry-pick a commit from another git repository? - Stack Overflow&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這邊有列出一些可以做到的方法  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/12320863/how-do-you-take-a-git-diff-file-and-apply-it-to-a-local-branch-that-is-a-copy-o/12320940#12320940"&gt;How do you take a git diff file, and apply it to a local branch that is a copy of the same repository? - Stack Overflow&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;這篇解釋了為什麼 "&lt;code&gt;git format-patch&lt;/code&gt; + &lt;code&gt;git am&lt;/code&gt;" 比 "&lt;code&gt;git diff&lt;/code&gt; + &lt;code&gt;git apply&lt;/code&gt;" 好  &lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;A better way to exchange whole commits by file is the combination of the commands git format-patch on the sender and then git am on the receiver, because it also transfers the authorship info and the commit message.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://coderwall.com/p/sgpksw/git-cherry-pick-from-another-repository"&gt;Git cherry-pick from another repository (Example)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/14509950/my-diff-contains-trailing-whitespace-how-to-get-rid-of-it"&gt;git - My diff contains trailing whitespace - how to get rid of it? - Stack Overflow&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="git"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>利用 ngrok 直接在本機開發 chatbot</title><link href="https://blog.m157q.tw/posts/2017/12/29/ngrok-https-proxy-to-write-chatbot-in-localhost/" rel="alternate"></link><published>2017-12-31T15:54:20+08:00</published><updated>2017-12-31T15:54:20+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-29:posts/2017/12/29/ngrok-https-proxy-to-write-chatbot-in-localhost/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;去年第 4 季部份時間，加上今年上半年大部份時間，幾乎都在做 chatbot 相關的開發。剛開始的時候真的是感到相關開發的工具是很不齊全（當然經過了一年多的發展，現在有更多更方便開發 chatbot 的工具了。），尤其是臺灣最多人用的 Facebook 和 Line 真的是對開發者挺不友善的。主要都是 API 的限制比較多，但 Line 至少還有個官方的 SDK，Facebook Messenger Bot 則連個官方的 SDK 都沒有，基本上都是第三方的，絕大多數都是開發者自己包的。  &lt;/p&gt;
&lt;p&gt;好像有點離題了，總之，一開始開發 Facebook Messenger Bot 的時候，都是在 Webhook 網址填入 Google App Engine service 給的預設網址，每次有改動就要 deploy 上去 GAE，等新版本的 service 正常運作之後，還要再等 Facebook 一段時間才會真的切換到新版本，時間不太一定。一開始還可以接受，但後來就覺得這樣實在是太麻煩了，所以就開始尋找有沒有比較方便的解法。  &lt;/p&gt;
&lt;p&gt;一開始是往「有沒有辦法在本機架一個模擬 Messenger Bot 介面的網頁前端出來」去找，還真的有人寫：&lt;a href="https://github.com/spchuang/fb-local-chat-bot"&gt;https://github.com/spchuang/fb-local-chat-bot&lt;/a&gt;，但因為是獨立開發，而且 Messenger Bot 的介面或 API 其實很常改動，所以我後來沒有採用這個方法。  &lt;/p&gt;
&lt;p&gt;後來詢問了一些人後，才往 web proxy 的方向找，有人推薦我使用免費的 &lt;a href="https://ngrok.com/"&gt;ngrok&lt;/a&gt;：可以拿到一個支援 https 的 web proxy，在 Facebook Messenger Bot 使用的 Webhook 網址填入 ngrok 的 https 網址，之後 Facebook 送到該網址的 request 都會由 ngrok 轉送到本機的某一個 port 上，只要你有在 localhost 把 Messenger Bot 的 Webhook server 執行起來的話，就可以很方便得用自己的手機開啟 chatbot 來邊操作邊即時修改程式碼。  &lt;/p&gt;
&lt;p&gt;作法其實滿簡單的，用了以後開發速度真的加快不少，也可以很即時跟跟 PM 那邊去做確認，確認沒問題了以後再 deploy。而且無論任何語言寫的 chatbot 都可以使用這方法，以下做個介紹。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;介紹&lt;/h2&gt;
&lt;p&gt;官方網站：&lt;a href="https://ngrok.com/"&gt;https://ngrok.com/&lt;/a&gt; 有安裝方式，安裝好後也只要一行指令就可以使用了，我自己是這樣用：  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;ngrok http 8080&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;這樣就會拿到一個接到 local host 8080 port 的 HTTP/HTTPS proxy，至於要用哪個 port 可以自己選擇，不一定要用 8080。  &lt;/p&gt;
&lt;p&gt;執行後，Termianl 就會拿到像下面這樣的畫面：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="ngrok cli" src="/files/ngrok-https-proxy-to-write-chatbot-in-localhost/ngrok-cli.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;也會在 local 開一個 web interface，連入以後的畫面像是這樣：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="ngrok web admin 1" src="/files/ngrok-https-proxy-to-write-chatbot-in-localhost/ngrok-web-admin-1.jpg" /&gt;&lt;br /&gt;
&lt;img alt="ngrok web admin 2" src="/files/ngrok-https-proxy-to-write-chatbot-in-localhost/ngrok-web-admin-2.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;接下來只要把拿到的 https proxy 的 url 填入 chatbot 的 webhook url，然後在 local 把自己開發的 chatbot webhook server 開在接入的 port 就行了。  &lt;/p&gt;
&lt;p&gt;如果是 Google App Engine 的 dev_appserver.py 的話，預設就會開在 8080 port。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ngrok.com/"&gt;ngrok - secure introspectable tunnels to localhost&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/inconshreveable/ngrok"&gt;GitHub - inconshreveable/ngrok: Introspected tunnels to localhost&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="ngrok"></category><category term="chatbot"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>關於 Django 的 F() expressions, Q object, Aggregation 的一些筆記</title><link href="https://blog.m157q.tw/posts/2017/12/28/about-django-f-expression-q-object-and-aggregation/" rel="alternate"></link><published>2017-12-28T23:15:00+08:00</published><updated>2017-12-28T23:15:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-28:posts/2017/12/28/about-django-f-expression-q-object-and-aggregation/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這篇算是在清草稿，約莫一年前紀錄在自己使用的 Trello board 的其中一張 card 裏面。  &lt;/p&gt;
&lt;p&gt;當時接手維護已離職的前同事的專案，是當時將員工內部使用的後台前後分離出來的網頁後端伺服器。他透過使用 Django 的 F() expressions, Q object, Aggregation 創造了一個 base view class（命名為 &lt;code&gt;ModelView&lt;/code&gt;），讓所有繼承這個 base class 的 view 都可以有類似 GraphQL 的效果，可以接收帶有符合 Django Query 參數的 json request 後，直接透過 model 去拿資料，再把資料包成 json response 吐回去。  &lt;/p&gt;
&lt;p&gt;這讓新增新的 API 變得很簡單，只要以下幾個步驟：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義好新的 model  &lt;/li&gt;
&lt;li&gt;寫一個新的 View 繼承自 &lt;code&gt;ModelView&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;第一行宣告繼承，第二行寫說對應到哪個 model 就行了  &lt;/li&gt;
&lt;li&gt;只要兩行，所有的 CRUD 以及 response 都會自動處理好  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;urls.py&lt;/code&gt; 裡頭新增對應到該 View 的網址  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;真的是用了滿多黑魔法的，我們在開發的時候都開玩笑得說：「這算是『魔改 Django』了吧？」但因為程式碼是放在 private repo，所以以下就只紀錄當時我去 trace source code 時紀錄的一些筆記。  &lt;/p&gt;
&lt;p&gt;最讓我覺得厲害的地方是，前同事 Jay 寫出這個東西之前根本沒碰過 Django，雖然其中也有問我一些問題，但他大概只花 3 個月就寫出這東西，後來我去看他寫的程式碼發現許多地方我看不懂，讓我挺佩服的。有點可惜這裡不能拿程式碼來一一講解就是。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href="https://docs.djangoproject.com/en/1.10/ref/models/expressions/#f-expressions"&gt;&lt;code&gt;F()&lt;/code&gt; expressions&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;code&gt;F()&lt;/code&gt; object represents the value of a model field or annotated column. It makes it possible to refer to model field values and perform database operations using them without actually having to pull them out of the database into Python memory.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;不會真的從 db 拿出值，可以減少 db query，讓效能好一點。  &lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;F()&lt;/code&gt; 以後，要真的更新值的話，必須要使用 &lt;code&gt;refresh_from_db()&lt;/code&gt;，&lt;code&gt;save()&lt;/code&gt; 只會先紀錄而已，並不會真的寫入。  &lt;/li&gt;
&lt;li&gt;可以避免 race condition 的問題，因為每個人不用拿到現在的值以後才去做更改，只要每個動作都有 &lt;code&gt;save()&lt;/code&gt; 的話，最後再一次 &lt;code&gt;refresh_from_db()&lt;/code&gt; 就好。  &lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;F()&lt;/code&gt; assignments persist after &lt;code&gt;Model.save()&lt;/code&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;save()&lt;/code&gt; 兩次的話，就會作用兩次。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href="https://docs.djangoproject.com/en/1.10/topics/db/queries/#complex-lookups-with-q"&gt;Q object&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Django &lt;code&gt;QuerySet&lt;/code&gt; 的 &lt;code&gt;filter()&lt;/code&gt; 基本上只能處理 AND 的 Query，如果想要使用 OR 或者更複雜一點的 Query 的話，就必須要使用 &lt;code&gt;Q()&lt;/code&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href="https://docs.djangoproject.com/en/1.10/topics/db/aggregation/"&gt;Aggregation&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QuerySet.annotate()&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;回傳一個 &lt;code&gt;QuerySet&lt;/code&gt;，可以給 &lt;code&gt;admin.ModelAdmin&lt;/code&gt; 使用。  &lt;/li&gt;
&lt;li&gt;基本上等同於 SQL 語句的 &lt;code&gt;AS&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;可搭配 &lt;code&gt;values()&lt;/code&gt;, &lt;code&gt;order_by()&lt;/code&gt; 做到 SQL 語句的 &lt;code&gt;GROUP BY&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;values()&lt;/code&gt; 和 &lt;code&gt;annotate()&lt;/code&gt; 的前後順序生出來的 Query 語句是有差別的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuerySet.aggregate()&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;回傳一個 dictionary，基本上就是拿來統計數字用而已。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;print(QuerySet.query)&lt;/code&gt; 來察看 QuerySet 生成的 SQL query statement.  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;後記&lt;/h2&gt;
&lt;p&gt;讓我有點不勝唏噓的是，筆記內容的連結依然是 Django 1.10，一年半前是最新的版本，但現在點進去已經顯示 &lt;strong&gt;"This document is for an insecure version of Django that is no longer supported. Please upgrade to a newer release!"&lt;/strong&gt; 了。  &lt;/p&gt;</summary><category term="Python"></category><category term="Django"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>用 Python 抓出我在前公司貢獻了多少 GitHub commits</title><link href="https://blog.m157q.tw/posts/2017/12/27/fetch-my-github-commits-in-one-organization-with-python-script/" rel="alternate"></link><published>2018-01-13T20:45:13+08:00</published><updated>2018-01-13T20:45:13+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-27:posts/2017/12/27/fetch-my-github-commits-in-one-organization-with-python-script/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;主要是因為&lt;a href="/posts/2017/12/26/i-left-my-first-full-time-job/"&gt;上一篇文章撰寫了離職心得&lt;/a&gt;，在寫的過程中想到，好像可以用 GitHub API 抓一下我在前公司這將近兩年的日子到底送了多少 commits。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;廢話不多說，直接進程式碼。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Python 3  &lt;/li&gt;
&lt;li&gt;要用到 &lt;a href="https://github.com/sigmavirus24/github3.py"&gt;github3.py&lt;/a&gt; 這個 package  &lt;ul&gt;
&lt;li&gt;請使用 &lt;code&gt;pip install --pre github3.py&lt;/code&gt; 來安裝  &lt;/li&gt;
&lt;li&gt;使用的版本為 &lt;code&gt;github3.py (1.0.0a4)&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;雖然可以直接用帳號密碼登入，但因為我有用 2FA，所以直接產生一組 Access Token 比較方便，也比較安全。  &lt;ul&gt;
&lt;li&gt;可以到 &lt;a href="https://github.com/settings/tokens"&gt;https://github.com/settings/tokens&lt;/a&gt; 產生一組，只需要勾選最基本的 repo 權限就行了，詳細可以參考 &lt;a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/"&gt;GitHub 的官方教學&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;這個 script 可以拿來算你在某個 organization 的總 commits 數，總共 35 行就搞定了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python3  &lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pprint&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;pprint&lt;/span&gt;  

&lt;span class="c1"&gt;# Make sure you&amp;#39;ve installed github3.py via `pip install --pre github3.py`  &lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;github3&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt;  


&lt;span class="n"&gt;MY_GITHUB_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  
&lt;span class="c1"&gt;# Visit https://github.com/settings/tokens to create a token if you don&amp;#39;t have.  &lt;/span&gt;
&lt;span class="c1"&gt;# Check &amp;quot;repo&amp;quot; permission  &lt;/span&gt;
&lt;span class="n"&gt;MY_GITHUB_TOKEN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;TARGET_ORGNIZATION_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  

&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;token&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;MY_GITHUB_TOKEN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;org&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;organization&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TARGET_ORGNIZATION_NAME&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;my_stats&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;  

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;repo&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;repositories&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;contribution&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;repo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contributor_statistics&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;MY_GITHUB_USERNAME&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contribution&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;author&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;repo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contribution&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;my_stats&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;repo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contribution&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;=&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GitHub username: {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MY_GITHUB_USERNAME&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Target GitHub organization: {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TARGET_ORGNIZATION_NAME&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Total contributed repos: {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_stats&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Total commits: {}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;commits&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;repo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;commits&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;my_stats&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;  

&lt;span class="n"&gt;my_stats_desc_sorted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_stats&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Repo and commits:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;pprint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_stats_desc_sorted&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一樣把程式碼開一個 gist 存：&lt;a href="https://gist.github.com/M157q/94be5759d2f13bfdcdd485feff2be3e6"&gt;https://gist.github.com/M157q/94be5759d2f13bfdcdd485feff2be3e6&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;結果&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;GitHub username: M157q  
Target GitHub organization: Tagtoo  
Total contributed repos: 36  
Total commits: 1521  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;總共在 36 個 repos 貢獻了 1521 個 commits，由於大多是 private repo，所以就不一一秀出了。&lt;br /&gt;
這邊只有算在 master branch 上的 commits 而已，不包含 issue 跟 PR。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hvelarde.blogspot.tw/2014/01/how-to-get-statistics-about-your.html"&gt;hvelarde: How to get statistics about your contributions on a GitHub organization&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="GitHub"></category><category term="Python"></category><category term="Python 3"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>我的新鮮人離職紀錄</title><link href="https://blog.m157q.tw/posts/2017/12/26/i-left-my-first-full-time-job/" rel="alternate"></link><published>2018-01-23T13:48:30+08:00</published><updated>2018-01-23T13:48:30+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-26:posts/2017/12/26/i-left-my-first-full-time-job/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這個標題是為了與另一篇將近兩年前寫的文章：&lt;a href="/posts/2016/02/12/first-job-interviews/"&gt;我的新鮮人面試紀錄&lt;/a&gt; 相互呼應，&lt;br /&gt;
這篇文章因為把面試過程紀錄的很詳細，&lt;br /&gt;
導致被 Google 搜尋到的機率很高，&lt;br /&gt;
意外成了我部落格上瀏覽量最高的文章，&lt;br /&gt;
是當初始料未及的，&lt;br /&gt;
原本只是想紀錄給自己看。  &lt;/p&gt;
&lt;p&gt;至於為什麼這篇文章要與其相呼應的原因也很明顯了，&lt;br /&gt;
嗯，因為我離職了。&lt;br /&gt;
算是這輩子第一份離開的全職工作，&lt;br /&gt;
想說既然當初找工作的時候紀錄得這麼詳細，&lt;br /&gt;
那就不要虎頭蛇尾。&lt;br /&gt;
所以這篇文章會紀錄我在 2016/01/21~2017/11/30 這段時間，&lt;br /&gt;
於塔圖科技擔任 Web back-end engineer 發生的事情。  &lt;/p&gt;
&lt;p&gt;其實 2017/09/30 就辦離職了，&lt;br /&gt;
但 2017/10/01~2017/11/30 轉為約聘，&lt;br /&gt;
把停了一年多的架構搬遷的專案收個尾，&lt;br /&gt;
也算是為自己負責吧。&lt;br /&gt;
而頭銜雖然是掛 Web Back-end Engineer，&lt;br /&gt;
實際上算是 DevOps + Architect + 半個 Support engineer。  &lt;/p&gt;
&lt;p&gt;主要當然還是紀錄下來給我自己以後有空的時候回頭檢視用的，&lt;br /&gt;
但如果有幫助到閱讀這篇文章的你的話，&lt;br /&gt;
我也會感到滿開心的就是，&lt;br /&gt;
如果真的有幫助的話也請你不吝留言讓我知道。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;紀錄&lt;/h2&gt;
&lt;p&gt;就先從我做了哪些事開始回想好了，一方面也是為了最近要開始改履歷用。&lt;br /&gt;
這裡當然會比較流水帳一點，會再從這找比較重點的事蹟更新到履歷上。&lt;br /&gt;
以下依照到職時間以每 6 個月來切分：  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;剛到職到六個月&lt;/h3&gt;
&lt;p&gt;因為剛到職的狀況比較多變，所以這裡我再區分成每個月來紀錄：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;剛到職  &lt;ul&gt;
&lt;li&gt;只有我一個 Web Back-end Engineer，另外是寫 JavaScript 的 Support Engineer，也剛進公司沒多久，之前的開發團隊都到另外一間公司去了。  &lt;/li&gt;
&lt;li&gt;雖然在 Slack 上有位前員工可以問，但也只有一開始一兩個月有問而已，其他都靠自己摸索。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;到職一個月  &lt;ul&gt;
&lt;li&gt;把所有前人留下來的文件讀完並進到還有在用的伺服器自行尋找相關設定。  &lt;/li&gt;
&lt;li&gt;因為前人留下來的文件不夠完整，這部份真的很像在打站，拿到一個可以登入的 shell 以後就什麼都要自己找...  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;到職兩個月  &lt;ul&gt;
&lt;li&gt;把伺服器搞炸。  &lt;/li&gt;
&lt;li&gt;不小心把 Google Cloud Platform 上的 Compute Engine Service Account 給砍了，到處求助但都無法解決，最後只好開一個新的 GCP Project。  &lt;/li&gt;
&lt;li&gt;因為之前的人把服務都跑在同一台 Google Cloud Compute Engine 上，所以一堆服務都掛掉，為此加班熬夜幾天搞定自己捅出來的簍子。  &lt;/li&gt;
&lt;li&gt;第一次參加 GCPUG.tw 就非常狼狽得來問這個問題，這裡有尋求協助的紀錄：&lt;a href="https://www.facebook.com/groups/GCPUG.TW/permalink/1695449067380624/"&gt;https://www.facebook.com/groups/GCPUG.TW/permalink/1695449067380624/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;剛好公司方向有改變，很多之前的服務用不到，適合開個新的 GCP project 把還有要用的東西移過去。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;到職三個月  &lt;ul&gt;
&lt;li&gt;把雲端平台的使用費省下 70% 左右。  &lt;/li&gt;
&lt;li&gt;大概是從每個月 2x 萬新台幣降到 6 萬左右，大概是降了 20&lt;br /&gt;
萬新台幣左右，雖然嚴格說起來真的沒有很多就是。  &lt;/li&gt;
&lt;li&gt;原因是因為之前團隊的人走了之後，沒把 GCP Cloud Bigtable（可以想成是跑在 GCP 上的 Spark）關掉，也沒在跑啥運算，就這樣每個月白白燒掉 20 萬新台幣。  &lt;/li&gt;
&lt;li&gt;當然也還把一些確定沒用到的服務都一併暫停了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;到職四個月  &lt;ul&gt;
&lt;li&gt;已經把有在跑的服務大致上都搞懂了，可以修改並加上新功能，只剩下一些非常久遠的 legacy package 沒有去動它。  &lt;/li&gt;
&lt;li&gt;開始撰寫新文件，因為對服務都大致瞭解了，所以也從舊的文件中篩選出還有用的部份，將其獨立出來，並儘量完整補充。  &lt;/li&gt;
&lt;li&gt;因為之前的團隊把服務都集中在某台 Google Compute Engine 上，所以開始跟約聘的 Web Back-end Engineer 同事討論計劃把服務拆分出來，以避免之後「一個掛、全部掛」的狀況。  &lt;/li&gt;
&lt;li&gt;剛好同事有用過 Docker 跟 Kubernetes，也是我當時想學的新技術之一，於是就開始計劃把現有的服務都拆分成 microservices。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;到職五個月  &lt;ul&gt;
&lt;li&gt;年資最久的工程師離職了（其實也只比我早進公司 3 個月），所以要花比較多時間帶兩位跟我同期進來，但比較沒經驗的同事。（其實在這之前多少就有花時間帶了，因為座位在旁邊，年紀也相仿，所以比較好溝通。）  &lt;/li&gt;
&lt;li&gt;有新的全職 Web Back-end Engineer 加入，雖然是有經驗的，但也得額外花點時間帶他熟悉。  &lt;/li&gt;
&lt;li&gt;開始針對現有服務的效能做改善。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;到職六個月到一年&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;和後來加入的 Web Back-end Engineer 磨合，年紀差了一輪以上，溝通上面有很嚴重的問題，許多觀念差太多，這是第一個腦海浮現讓我想離職的時候。  &lt;ul&gt;
&lt;li&gt;另外一位年紀與我相仿的約聘同事也在和他的合作上遇到滿大的問題，剛好當時他們有個案子要合作，常常溝通到後來都要請我居中協調。  &lt;/li&gt;
&lt;li&gt;常常在溝通的時候不發表意見，都說「好」「沒問題」，但之後實作出來的程式碼卻不是照討論的結果，而是他原本想做的事，浪費的討論的時間。  &lt;/li&gt;
&lt;li&gt;程式碼會動就好，常常直接 copy-paste 程式碼，因為很快就能交差了事，老闆都會覺得他的進度很快很棒，甚至我包好的 function 也被直接複製出去修改，然後原本的就被棄置。  &lt;/li&gt;
&lt;li&gt;每天都要跑來問我們昨天的進度，但明明大家都會寫在 Trello 上，其實每個人就只是把 Trello 打開，講昨天紀錄的東西，所以是浪費時間，溝通很多次了也沒用，後來就不了了之。  &lt;/li&gt;
&lt;li&gt;所以後來在分配專案的時候，我都會儘量與其避開，因為實在是太累，是心理上的那種累。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;開始把服務拆分並轉移到新的 GCP Project，這中間比較有挑戰性的事情是和另外兩位同事們討論如何做到 zero downtime 的 Database migration，透過架構與程式碼的修改以及撰寫 script 進行資料搬移，大家各負責不同的部份，後來也成功做到了。  &lt;/li&gt;
&lt;li&gt;解決現有服務要提供給中國客戶使用的問題  &lt;ul&gt;
&lt;li&gt;其實這原本不是我主要負責的事，老闆是先指派給年紀比我大一輪的那位同事做，因為他剛好做完了上一件老闆交代的事。我一開始有給些方向與想法，但該同事就沒再來找我討論，結果一個禮拜過去了，上線前測試，根本不會動。跟客戶講說下禮拜就可以好的東西，老闆只好去請客戶寬限一週，然後就落到了我頭上，開啟了一個禮拜的爆炸加班之旅。  &lt;/li&gt;
&lt;li&gt;中國網路環境特殊，要使用 GCP 的服務直接提供根本不可能，因為會被擋光光，但老闆談這筆生意的時候又很急著上線，所以根本來不及把所有的服務都複製到中國的雲端平台上使用，更別說可能還有域名得立案的問題。  &lt;/li&gt;
&lt;li&gt;後來當然是沒有遇域名立案，因為根本沒時間，而是老闆先跟同行借了中國的伺服器，但要佈署服務很麻煩，畢竟不是自己的伺服器，再加上狀況其實不太好，所以最後還是用了中國的雲端服務。  &lt;/li&gt;
&lt;li&gt;加了三天晚上的班，吃老闆請的披薩等等速食晚餐，總算是弄出了個能用的東西。但效果不太好，即便是在中國牆內的網路，還是被擋的很慘，不然就是 latency 太高，而且還被同行合作的程式碼雷到。XD  &lt;/li&gt;
&lt;li&gt;之後大概又來來回回折騰了一個多月，仍舊無法完全克服 Google Tag Manager 部份被擋的狀況。折衷弄了一個全由自己獨立開發的 Django server，撰寫爬蟲定時去抓取資訊，並提供 API，做到確保能載入 &lt;code&gt;gtm.js&lt;/code&gt; 的時候才載入，不能載入的時候就不載入。當然也有把 request 資訊紀錄到資料庫裏面，方便之後拉資料出來觀察狀況。詳細紀錄在這篇文章：&lt;a href="https://blog.m157q.tw/posts/2018/01/11/dealing-with-china-network/"&gt;中國網路相關筆記 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2016 梅竹黑客松  &lt;ul&gt;
&lt;li&gt;回交大當評審，其他評審看起來都至少大我 5~10 歲以上，第一次當程式相關的評審，其實有點抖。  &lt;/li&gt;
&lt;li&gt;為此弄了一個 Django server，搭配 Django REST framework 和 Django REST framework Docs 提供 API 給參加者撈出 BigQuery 裡頭的資料。詳細紀錄在這篇文章：&lt;a href="https://blog.m157q.tw/posts/2018/01/07/django-rest-framework-note/"&gt;關於 Django REST framework 的一些筆記 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;開始開發 Facebook Messenger Bot  &lt;ul&gt;
&lt;li&gt;用 Google App Engine 搭配 &lt;code&gt;webapp2&lt;/code&gt; 開發，因為 Facebook 官方沒有 SDK，所以啥都得自己接。  &lt;/li&gt;
&lt;li&gt;也踩到了不少雷，例如：  &lt;ul&gt;
&lt;li&gt;Facebook 的開發文件很雷這應該就不用說了，有程式碼的話直接去看程式碼比較快，程式碼寫的比文件好。  &lt;/li&gt;
&lt;li&gt;Generic Template 10 個 element 都放圖片的話，即便已經用了 cache 快速回應給 Facebook 的伺服器，訊息仍舊非常慢才在 client 端被 render 出來，主要都是卡在圖片。  &lt;/li&gt;
&lt;li&gt;沒有完善的測試環境，基本上大家都是開一個 production bot、一個 testing bot 分開維護。  &lt;/li&gt;
&lt;li&gt;API 常常沒在管 backward compability，major version 都還在 1 的時候常常 API 行為突然就改了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;到職一年到一年半&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;繼續開發 Facebook Messenger Bot  &lt;ul&gt;
&lt;li&gt;2017 上半年時間幾乎都在弄 Facebook Messenger Bot，主要是功能需求其實有點違反 Facebook 的 policy，所以在實作上為了不要觸犯 policy，一直在花時間想要怎麼繞路。  &lt;/li&gt;
&lt;li&gt;主要是需求沒有確定下來，PM 是個初心者，所以浪費了不少時間在做重複的事，導致之後要儲存使用者行為及分析的流程延宕了很久。  &lt;/li&gt;
&lt;li&gt;為了更加瞭解 Facbeook Messenger Bot，2017 年 6 月參加了 &lt;a href="https://fdctaipei.kktix.cc/events/fdc201706"&gt;Facebook Developer Circle: Taipei - Meetup #2&lt;/a&gt;，有篇筆記文：&lt;a href="https://blog.m157q.tw/posts/2017/06/22/facebook-developer-circle-taipei-meetup-2/"&gt;Facebook Developer Circle: Taipei - Meetup #2 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支援同事  &lt;ul&gt;
&lt;li&gt;這反而是我這段時間做得比較有成就感的，實在是因為 Messenger Bot 的開發沒規劃好，讓我覺得有點厭煩了。  &lt;/li&gt;
&lt;li&gt;幫忙解決了一些數字落差的問題，有點像是網站方面的 debug，除了更加熟悉架構與細節以外，有時候也挺享受確定問題的發生的原因跟自己思考出來的結果是相同的那種成就感。  &lt;/li&gt;
&lt;li&gt;幫忙把原本在 Travis CI 上要跑一個半小時的測試（沒錯，一個半小時。），加上 multiprocessing，縮短到只要花 15 分鐘就跑完。  &lt;/li&gt;
&lt;li&gt;加上廣告商品自動下架機制，因為原本的下架機制很陽春，常常被客戶抱怨。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;到職一年半到離職前&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因為覺得公司走向改變，工作內容已經變成我不太喜歡的部份，經過多次思考後，在 2017 的 7 月底提離職。  &lt;ul&gt;
&lt;li&gt;談完之後調整了工作內容，回歸到架構和資料分析的部份。  &lt;/li&gt;
&lt;li&gt;並設定兩個月的觀察期，期間順便把工作相關的部份逐步交接給同事，如果不行的話就 2017 的 9 月底離職。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;開始做 data cleaning 和接觸 Machine Learning  &lt;ul&gt;
&lt;li&gt;參加了幾場資料科學年會辦的活動，學到了不少東西：  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.m157q.tw/posts/2017/08/12/dive-into-deep-learning-datasci-tw/"&gt;台灣資料科學年會之系列活動：深入淺出深度學習 (Dive into Deep Learning) | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.m157q.tw/posts/2017/08/13/deep-learning-hands-on-step-by-step-datasci-tw/"&gt;台灣資料科學年會之系列活動：手把手的深度學習實務 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;這期間真的是比較多時間在碰 Machine Learing 和 Deep Learning，但花在上面的時間沒有很多，因為還有其他事情得做，而且主要負責機器學習相關專案的開發者不是我，所以自己覺得只學了點皮毛。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;儘量把文件補齊全  &lt;ul&gt;
&lt;li&gt;花最多時間的應該是用 draw.io 畫出了整個公司的伺服器架構圖。  &lt;/li&gt;
&lt;li&gt;其次則是撰寫新的員工訓練與入門文件。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最後還是在 2017 的 9 月底離職了，但後續以約聘的方式完成了一件案子，直到 2017 年 11 月底。  &lt;ul&gt;
&lt;li&gt;主要內容是 API 搬遷以及整理資料流。  &lt;/li&gt;
&lt;li&gt;API 搬遷算是 2016 年中做到一半的東西，因為相關人員都已經離職，只剩我比較瞭解，自己也想做個了斷，所以就接了。  &lt;ul&gt;
&lt;li&gt;主要是去除舊的 API 以及增添新的資料庫欄位因應新的需求。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整理資料流則是儘量讓不同服務之間傳遞資料的方式有個統一的規則，在此之前是有點雜亂無章的，常常會搞混。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;反省&lt;/h2&gt;
&lt;p&gt;「人非聖賢，孰能無過？」其實在這段時間內自己覺得也犯了不少錯，在這邊紀錄下來，用來提醒以後的自己。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;絕對要克制自己看到 legacy code 就想改的強迫症。  &lt;ul&gt;
&lt;li&gt;基本上沒有錯誤或者嚴重效能瓶頸的 legacy code 就別動它了。  &lt;/li&gt;
&lt;li&gt;剛進公司的時候逞一時之勇，改了一些 legacy code 導致行為改變，都是後來有人回報或是察看資料才發現。  &lt;/li&gt;
&lt;li&gt;如果真的要改的話，先確定自己瞭解整個服務在幹嘛，最好還要確定有夠完整的測試，避免修改後出錯卻不知道。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在面對年紀比自己大的同事時的溝通能力還不夠好  &lt;ul&gt;
&lt;li&gt;無法像和年紀相仿的同事那樣直接溝通  &lt;/li&gt;
&lt;li&gt;這部份目前真的沒啥其他想法，之後可能要多注意一下。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;對於技術瞭解得不夠深入  &lt;ul&gt;
&lt;li&gt;很多時候都是網路上查到覺得不錯就用某個工具或方法，但用了以後發現有不少的問題或者中途才發現有更好的處理方法，但要改的話進度又會落後。  &lt;/li&gt;
&lt;li&gt;對於該如何用什麼樣的技術、什麼樣的架構、什麼樣的演算法、什麼樣的資料結構還是不夠確定，資工的基礎部份還是不夠熟，得多花時間加強。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;對於專案進度的安排不夠準確  &lt;ul&gt;
&lt;li&gt;常常有進度落後的狀況出現，對於專案的估期還是不夠準確，其實某方面應該也代表自己的技術能力不夠純熟。  &lt;/li&gt;
&lt;li&gt;當然也會遇到需求變動而導致專案進度落後的部份，這部份可能之後要多熟悉 Agile 的流程，畢竟在這份工作並沒有使用到 Agile。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解釋東西的時候常常會太過發散  &lt;ul&gt;
&lt;li&gt;有時候為了要讓人比較好懂反而會講得太過詳細或太過多餘，甚至不自覺得離了題，這點是自己之後要注意的部份，講話要多講些重點。  &lt;/li&gt;
&lt;li&gt;還有一點要注意的是講解技術相關的東西時，必需要再多加確定聽的人的程度，這樣才能更有效且更精準的討論或解答，不會太過或不及。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仍舊沒養成寫測試的習慣  &lt;ul&gt;
&lt;li&gt;雖然知道寫測試很重要，但常常因為開發進度的關係來不及寫測試。  &lt;/li&gt;
&lt;li&gt;知道 TDD，但還是不太習慣，總覺得有機會應該找一個 side project，強迫自己試試 TDD，去體會其中明顯的差別。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;英文口說沒太大進步  &lt;ul&gt;
&lt;li&gt;畢竟在台灣能用到的場合相對來說真的比較少，這部份還要自己再找時間精進。  &lt;/li&gt;
&lt;li&gt;基本上現在已經不太怕口說了，但重點是用字會趨於過度單調，常常重複使用同樣的字。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;和人交談技巧還是不夠  &lt;ul&gt;
&lt;li&gt;算是我自己長久以來的問題吧，常常都是事後才想到當時其實應該還有很多東西可以聊，有助於建立人際網路。  &lt;/li&gt;
&lt;li&gt;出社會以後算是真的體驗到人際網路比我以前想像中的重要些。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聽完演講歸納問題並勇於發問的能力仍舊不足  &lt;ul&gt;
&lt;li&gt;之後應該要多訓練自己聽講時的歸納與分析能力，並和自己的一些想法結合，提出一些精闢的問題。  &lt;/li&gt;
&lt;li&gt;這個算是 2016 年底去 33C3 的時候有非常深刻的體會，會場不僅提問踴躍，每個人問的問題也都很棒，我覺得這是從小到大習慣了填鴨式教育最大的問題。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;時間管理不夠好、自信不足、應該多嘗試面試邀約  &lt;ul&gt;
&lt;li&gt;在這將近兩年的時間內，從 LinkedIn 或 Email 至少收到 7 位獵頭詢問、與一間東南亞頗大間公司的 HR 當面吃飯聊天、和想在加拿大創業的高中同班同學聊過，不過都因為覺得自己還在工作中加上個性的關係沒有進一步去面試，現在覺得導致自己少了滿多學習的機會的。  &lt;/li&gt;
&lt;li&gt;之後在工作中如果有不錯的面試邀約應該就會去嘗試看看，不然老實說將近兩年的時間沒有面試，對於面試的東西實在有點生疏，現在要額外準備的心力讓我的拖延症更嚴重了。以後不如就把面試當健身，讓自己保持在習慣面試的狀態，也許這樣會比較好。  &lt;/li&gt;
&lt;li&gt;期間還有一件事是，2015 年底找工作的時候在 Livecoding.tv 這個平台（現在改名為 LiveEdu）上開了寫程式的實況，後來找到工作後因為租屋觸網路問題所以就沒繼續開了，結果後來發生了幾件事：  &lt;/li&gt;
&lt;li&gt;收到不少次該平台的工作人員寄訊息來說覺得我的實況不錯，不知道為什麼我沒繼續開了，想邀請我參加他們的 Premium member，可能每週固定時間開實況這樣。  &lt;/li&gt;
&lt;li&gt;也在該平台的私訊收到一些人表示剛學 Python，說看我之前的實況 VOD 學到不少，算是在這平台上還不錯的影片，問我什麼時候能繼續開。  &lt;ul&gt;
&lt;li&gt;當時我因為 2016 年下半年比較忙，再加上租屋處網路問題短時間內也無法解決，所以只回說目前因為網路問題無法解決所以不會開，之後有可能會再開，但不一定。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收到該平台中國區工作人員邀請我進行一段訪問，我也因為工作因素加上自信不足沒有回應，就這樣算是錯失了一個可以小小建立一點自己的能見度的機會。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;在這將近兩年的工作時間，收穫其實也不少，就在這邊把一些心得感想寫下來。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大的收穫應該是認識了一群感情很好的同事吧  &lt;ul&gt;
&lt;li&gt;週末晚上會約去唱歌、吃飯、喝酒，還有自己揪團的小旅行。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用中文和技術職或非技術職的同事溝通的能力算是有長進吧  &lt;ul&gt;
&lt;li&gt;獲得了「會講人話的工程師」的稱號  &lt;/li&gt;
&lt;li&gt;關於回答問題的部份，最近翻譯的這篇文章算是把我想講的話都講出來了：&lt;a href="https://blog.m157q.tw/posts/2017/12/21/how-to-answer-questions-in-a-helpful-way-zh-tw/"&gt;《回答的智慧》 | Just for noting&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Docker 和 Kubernetes 算是這份工作學到比較多的吧  &lt;ul&gt;
&lt;li&gt;雖然自己覺得對於 Docker 和 Kubernetes 的實作還是不夠瞭解，如果要進行效能方面的改善的話應該還是會有問題就是。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;獨立完成的兩個使用 Django 的專案  &lt;ul&gt;
&lt;li&gt;無論是程式碼、註解、說明文件，我自己都覺得還算滿意。  &lt;/li&gt;
&lt;li&gt;最不滿意的都是效能的部份，之後從事 Python 相關開發的話得提醒自己多注重要怎麼讓效能更好這一部份。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算是有點確定自己有興趣的方向了  &lt;/li&gt;
&lt;li&gt;對於網站後端架構以及自動化測試與佈署的部份，覺得能幫助同事和自己節省更多時間或看到因為架構改善讓開發變得比較容易，會滿有成就感的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;紀錄一下這次離職的一些原因，想說在之後有新工作的時後可以拿來檢視。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公司著重方向改變，和我想做的事情以及當初面試進來的工作內容不符合。  &lt;ul&gt;
&lt;li&gt;主要是我對於新的方向沒有很強烈的興趣。  &lt;/li&gt;
&lt;li&gt;雖然工作內容有調整，但剛進來的新人也無法成為即戰力，等於是我要做更多的事。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;覺得自己的技術能力沒有什麼顯著的長進  &lt;ul&gt;
&lt;li&gt;自己覺得剛畢業後的工作應該要能夠讓自己的技術能力有顯著的成長，不然會嚴重影響之後的職涯發展  &lt;/li&gt;
&lt;li&gt;因為同事大部份都算是初學者，所以花比較多時間在帶人，基本上同事有問問題的話我都是儘量回答到好，畢竟從別人的問題也常常可以學到新東西或發現自己的盲點。  &lt;/li&gt;
&lt;li&gt;甚至連非工程師的同事提出的問題我也儘量回答，而且是儘我最大的能力用比喻的方式讓不懂技術名詞的同事也能理解其中的概念。  &lt;/li&gt;
&lt;li&gt;其實我還滿享受這種幫助同事的成就感，但肯定是會擠壓到我精進技術能力的時間。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;薪資成長不如預期  &lt;ul&gt;
&lt;li&gt;覺得調薪幅度跟我做的事情不太成比例。  &lt;/li&gt;
&lt;li&gt;當然也可能跟我自己沒有積極爭取加薪有關，算是下一份工作會想要有所突破的部份吧。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;其實在這將近兩年的工作時間內，我也有好幾次不斷問自己，「到底下一份工作要不要找個大公司試試？」每次問完自己以後，都還是偏向找比較小型的公司。  &lt;/p&gt;
&lt;p&gt;最近再次問了自己這個問題，還是想要找小型的新創公司來待，可能跟我自己的個性有關吧，不是很在意 brand name。  &lt;/p&gt;
&lt;p&gt;但我想之後還是會每隔一段時間問自己這個問題就是，我自己也知道大公司與小公司各有優缺點，唯一一個讓我覺得最有感的是，大公司比較有可能遇到好的 mentor 授予你一些經驗，不是說小公司遇不到，主要是小公司每個人得各司其職，工作範圍可能都不太重疊，所以比較沒有人有時間可以帶你。大公司則制度比較完善，人力資源也比較多，也大多會分配 mentor，當然能不能遇到好 mentor 也是要看運氣就是。  &lt;/p&gt;
&lt;p&gt;這份工作會想離職有滿大一部份原因是「沒有人可以帶我」，所以都得靠自己摸索，也不是說自己就無法自學，只是就進步得比較緩慢，然後就覺得自己將近兩年來在能力上沒啥成長。也許跟之前的工作都有比我有經驗的人在帶有關，被有經驗的人指點或者被有經驗的人電，會讓我學得非常快，我想這是我自己的盲點，需要多花點時間去思考。  &lt;/p&gt;
&lt;p&gt;下一份工作應該會先從國外的小型新創公司開始找吧，如果能夠 relocate 的話最好，但目前並沒有鎖定美國，畢竟美國現在因為 Trump 當總統，所以對技術移民不是那麼友善。  &lt;/p&gt;
&lt;p&gt;但也有在考慮大公司就是，主要是可以面對規模比較大的服務以及可以接觸到比較深的技術，這是主要考量的點，很多問題在規模夠大的服務才會浮現，而且通常滿有挑戰性的。畢竟小公司大多數狀況會因為人少而且要急著有個賺錢的產品，所以會比較偏快速弄出個應用，且剛上線的服務使用人數不會太多。總之最近跟朋友聊完以後，對大公司可能有這樣的工作環境有點興趣，但就是要多花更多心力去準備大公司繁瑣的面試流程就是。  &lt;/p&gt;
&lt;p&gt;我反而比較想去比較少人去的歐洲或是紐澳，總之可能就是邊緣人個性作祟吧，想去試一些比較少人試過的事。也因為這樣，其實雖然知道 referral 是比較容易找到工作的，但我其實沒有很喜歡從朋友變成同事，不知道為什麼下意識就會覺得多了一份利害關係而感到尷尬，還是覺得朋友之間可以分享彼此都不知道的事情比較有趣些。  &lt;/p&gt;
&lt;p&gt;但我可以接受從同事變成朋友，我也不太確定為啥我會有這種想法，可能是因為我對朋友的要求並沒有很嚴格，就算我不太喜歡某位朋友的作風，我還是可以接受他比較 OK 的地方，但如果要成為同事的話，可能就會超越這條線讓我無法接受吧。再加上我的個性很難與人深交，所以寧願多認識一些不同的人之類的。  &lt;/p&gt;
&lt;p&gt;總之，目前應該還是會傾向 Web Back-end 和 DevOps 的部份吧，我自己是覺得算有興趣，至於 Data Analysis 和 Machine Learning 的部份也要找時間好好碰一下，算是有興趣，但在這份工作比較沒有機會接觸到。  &lt;/p&gt;</summary><category term="Job"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>加密和雜湊有什麼不一樣？</title><link href="https://blog.m157q.tw/posts/2017/12/25/differences-between-encryption-and-hashing/" rel="alternate"></link><published>2017-12-26T12:29:40+08:00</published><updated>2017-12-26T12:29:40+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-25:posts/2017/12/25/differences-between-encryption-and-hashing/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;其實雜湊（Hash）的部份，本來是打算放在 &lt;a href="/posts/2017/12/23/differences-between-encryption-compression-and-encoding/"&gt;如何區分加密、壓縮、編碼&lt;/a&gt; 這篇一起講。但在撰寫的過程中發覺雜湊跟其他三者相比起來的差異性較大，一起講其實蠻突兀的，不太好比較。而且我自己目前看到的狀況是，雜湊比較容易跟加密搞混，所以才獨立出這篇來講一下雜湊與加密的關係。  &lt;/p&gt;
&lt;p&gt;你可能或多或少都有看過或聽過「MD5 加密」、「MD5 解密」、「SHA-1 加密」、「SHA-1 解密」、「雜湊加密演算法」。但 MD5 和 SHA-1 實際上並不是加密演算法，而是雜湊演算法。究竟加密跟雜湊到底有什麼不一樣，又該如何區分，這篇會簡單講解一下。  &lt;/p&gt;
&lt;p&gt;因為加密的部份已經在 &lt;a href="/posts/2017/12/23/differences-between-encryption-compression-and-encoding/"&gt;如何區分加密、壓縮、編碼&lt;/a&gt; 這篇提過了，所以就不重述，還不清楚的人歡迎點擊上述文章連結前去察看。以下會先講雜湊的特性，再講雜湊跟加密的區別。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;雜湊（Hash）&lt;/h3&gt;
&lt;p&gt;其實雜湊在一些壓縮演算法或者排序演算法也都有用到，&lt;br /&gt;
但這邊只就資訊安全相關的部份進行討論。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;無論原文的內容長短，透過雜湊演算法運算完的輸出都會是固定的長度，即輸出的長度不受原文長度影響。  &lt;/li&gt;
&lt;li&gt;雜湊演算法的輸出又被稱做「雜湊值」（hash value）。  &lt;/li&gt;
&lt;li&gt;不同雜湊演算法的輸出長度不同。  &lt;/li&gt;
&lt;li&gt;兩個原文的內容即便只差一個字，雜湊演算法產生的兩個輸出內容卻會差非常多。  &lt;/li&gt;
&lt;li&gt;相同的內容作為相同雜湊演算法的輸入，得到的輸出必定一樣。  &lt;/li&gt;
&lt;li&gt;不同的內容作為相同雜湊演算法的輸入，得到的相同輸出的機率極低。  &lt;/li&gt;
&lt;li&gt;無法將雜湊演算法的輸出解回原本的輸入，雜湊是單向的。  &lt;ul&gt;
&lt;li&gt;但因為相同輸入會得到相同輸出，所以最常見的破解方法就是透過 brute-force 的方式，用程式把各種可能的輸入都餵給雜湊演算法，得到輸出後，把輸入跟輸出以及所使用的雜湊演算法記起來，成為一張對應表（被稱做 rainbow table，彩虹表）。  &lt;/li&gt;
&lt;li&gt;然後拿雜湊值去其使用之雜湊演算法的 rainbow table 找尋輸入值，因為 rainbow table 是可以一直累積的，所以理論上來說，只要 rainbow table 夠大的話，就能夠找到原始的輸入值。  &lt;/li&gt;
&lt;li&gt;所以資安實務上會再為原始資料加入 salt 之後，才會丟給雜湊演算法運算，獲得加了 salt 以後的雜湊值。  &lt;ul&gt;
&lt;li&gt;salt 基本上就是額外加入的字串，可以用固定的規則改變原本的輸入值。  &lt;/li&gt;
&lt;li&gt;這樣的好處是，就算被破解了，破解的人拿到的字串仍然不會是密碼，拿去登入是不會成功的。  &lt;/li&gt;
&lt;li&gt;但在比對使用者輸入的密碼時，一樣可以加了 salt 之後再進行雜湊去比對，仍然可以驗證密碼是否正確，而安全性會增加。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用途  &lt;ul&gt;
&lt;li&gt;檔案校驗碼（Checksum）  &lt;ul&gt;
&lt;li&gt;用來快速判斷檔案是否和原本相同。  &lt;/li&gt;
&lt;li&gt;有在論壇下載過檔案的人應該都很常見到一長串 MD5 或 SHA-1 驗證碼，就是用來讓你快速檢查你下載的檔案裡頭的內容，是不是跟上傳者上傳的檔案一樣。  &lt;/li&gt;
&lt;li&gt;不一樣的話可能就是你載錯檔案、檔案有毀損或檔案被人加料了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不需要被還原的資料  &lt;ul&gt;
&lt;li&gt;例如：避免明文儲存使用者密碼  &lt;ul&gt;
&lt;li&gt;避免直接儲存使用者的明文密碼，除了避免資料庫外洩時，攻擊者無需進一步運算就可以直接得到明文密碼外，一方面也是尊重使用者，因為正常情況下只有使用者知道自己的密碼。  &lt;/li&gt;
&lt;li&gt;要簡單判斷網站有沒有明文儲存你的密碼最簡單的兩個方法：  &lt;ul&gt;
&lt;li&gt;寄信給你的時候有沒有直接把密碼寫在內文。  &lt;/li&gt;
&lt;li&gt;忘記密碼的時候不是要求你或幫你重新設定密碼，而是直接告訴你你的密碼。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但因為相同原文透過相同的雜湊演算法會得到相同的輸出，所以可以在不明文儲存使用者密碼的情況下，確認使用者輸入的密碼是否正確。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;SHA 系列：  &lt;ul&gt;
&lt;li&gt;SHA-0  &lt;/li&gt;
&lt;li&gt;SHA-1  &lt;ul&gt;
&lt;li&gt;SHA-1 已經被證明不夠安全。（在可接受的時間範圍內，可以找到內容不相同輸入卻得到相同輸出。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SHA-2  &lt;ul&gt;
&lt;li&gt;SHA-256  &lt;/li&gt;
&lt;li&gt;SHA-512  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SHA-3  &lt;ul&gt;
&lt;li&gt;SHA3-256  &lt;/li&gt;
&lt;li&gt;SHA3-512  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MD5  &lt;ul&gt;
&lt;li&gt;MD5 也已經被證明不夠安全。（在可接受的時間範圍內，可以找到內容不相同輸入卻得到相同輸出。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BLAKE2  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;就是一串拿來做檢查的字串，但根據使用需求可以有不同的用途。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;所以，為什麼雜湊不是加密？&lt;/h2&gt;
&lt;p&gt;我個人認為，雜湊和加密很容易被人搞混的原因，主要是因為，雜湊和加密通常是一起使用的，常常被拿在一起講，所以久而久之就搞混了。  &lt;/p&gt;
&lt;p&gt;但其實可以透過以下幾點來區分：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密需要密鑰，且可以透過解密得到原文。（加密可逆）  &lt;/li&gt;
&lt;li&gt;雜湊不需密鑰，無法逆向解出原始輸入。（雜湊不可逆）  &lt;ul&gt;
&lt;li&gt;雖然可以透過額外儲存的 rainbow table 來找尋原始輸入，但彩虹表是預先計算並儲存下來的，而不是雜湊演算法本身的設計。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;舉例  &lt;ul&gt;
&lt;li&gt;今天如果我拿到一串密文，我是有辦法透過解密，得到原始的明文的，而且如果使用非對稱式加密的話，我甚至還可以驗證傳送方是不是本人（是否有被進行中間人攻擊）。  &lt;ul&gt;
&lt;li&gt;雜湊演算法在這裡也會被使用，通常會被拿來檢驗傳送的訊息是否有被更改過。  &lt;/li&gt;
&lt;li&gt;傳送方附上原始訊息經過某個雜湊演算法得出的雜湊值，接收方在解開這個訊息之後，會透過相同的雜湊演算法來驗證。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但如果是拿到一串雜湊值的話，理論上是無法逆向得到原始的明文的，根本無法拿來做資料的傳遞。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以別再說出「MD5 加密」、「MD5 解密」、「SHA-1 加密」、「SHA-1 解密」之類的話啦~  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;小測驗&lt;/h2&gt;
&lt;p&gt;如果這兩篇有看懂的話，應該就可以理解&lt;a href="https://mobile.twitter.com/orsonwang/status/944400953591021568"&gt;這個 tweet&lt;/a&gt; 在講什麼：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pkcs7 簽章使用 RSA 加密演算法對資料的 SHA256 雜湊值簽章，台灣的金融機構習慣對這簽章做 base64 編碼來避免古早用 Cobol 的系統以 ASCII 字碼接收而產生所有資料第 8 bit 都是 0 而引起的驗證錯誤。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dotblogs.com.tw/regionbbs/2017/09/21/hashing_is_not_encryption"&gt;[Security] 雜湊不是加密，雜湊不是加密，雜湊不是加密。 | 小朱® 的技術隨手寫 - 點部落&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.securityinnovationeurope.com/blog/page/whats-the-difference-between-hashing-and-encrypting"&gt;What is The Difference Between Hashing and Encrypting&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)"&gt;鹽 (密碼學) - 維基百科，自由的百科全書&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Encryption"></category><category term="Hashing"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>我愛開源，因為會遇到路人幫我寫測試。</title><link href="https://blog.m157q.tw/posts/2017/12/24/i-love-open-source-because-someone-will-write-testings-for-me/" rel="alternate"></link><published>2017-12-26T12:05:12+08:00</published><updated>2017-12-26T12:05:12+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-24:posts/2017/12/24/i-love-open-source-because-someone-will-write-testings-for-me/</id><summary type="html">&lt;h2&gt;先講結論&lt;/h2&gt;
&lt;p&gt;感恩開源！讚嘆開源！（啥）【詳見附 1】  &lt;/p&gt;
&lt;h2&gt;故事內文&lt;/h2&gt;
&lt;p&gt;故事緣起於 9 月底的某個星期六晚上&lt;br /&gt;
因為太邊緣了沒人約&lt;br /&gt;
加上一時興起&lt;br /&gt;
於是花了幾個小時&lt;br /&gt;
用 Python 寫了個把文字從橫書轉成直書的小程式&lt;br /&gt;
詳情請見：&lt;a href="https://github.com/M157q/hor2vec"&gt;https://github.com/M157q/hor2vec&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;之後有收到些回饋&lt;br /&gt;
有人說想寫個 JavaScript 版&lt;br /&gt;
也有說人說想寫個 Rust 版  &lt;/p&gt;
&lt;p&gt;也有收到網友的訊息說&lt;br /&gt;
在隔幾天的十月初&lt;br /&gt;
日本知名的 GitHub 使用者 mattn&lt;br /&gt;
（在 GitHub 上有 3.6k followers，有用 Vim 和寫 Golang 的人應該對他的 id 不陌生）&lt;br /&gt;
也用 Golang 寫了一個用途一樣的程式&lt;br /&gt;
&lt;a href="https://github.com/mattn/tate"&gt;https://github.com/mattn/tate&lt;/a&gt;&lt;br /&gt;
裏面有些我沒有實作的功能可以參考看看  &lt;/p&gt;
&lt;p&gt;看了一下才知道&lt;br /&gt;
原來日文的平假名和片假名也有分全形和半形&lt;br /&gt;
然後連標點符號也可以從橫的轉成直的  &lt;/p&gt;
&lt;p&gt;於是我就開了幾個 issue 紀錄要新增的功能&lt;br /&gt;
然後因為我是測試苦手不太會寫測試&lt;br /&gt;
所以一開始就沒寫測試&lt;br /&gt;
於是就&lt;a href="https://github.com/M157q/hor2vec/issues/5"&gt;開了一個 issue 提醒我自己要寫測試&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;沒！想！到！&lt;br /&gt;
竟然收到一個路人的 pull request 幫我加上了測試&lt;br /&gt;
&lt;a href="https://github.com/M157q/hor2vec/pull/6"&gt;https://github.com/M157q/hor2vec/pull/6&lt;/a&gt;&lt;br /&gt;
花了 27 個 commits&lt;br /&gt;
更動了 400 多行程式碼&lt;br /&gt;
太神奇啦！&lt;br /&gt;
這種路過幫人寫測試的神奇小精靈哪裡找啊？  &lt;/p&gt;
&lt;p&gt;最神奇的還不只這個&lt;br /&gt;
重點是他的 27 個 commits 裡頭的內容之詳細&lt;br /&gt;
比他更改的程式碼還多行&lt;br /&gt;
實在是太令人賞心悅目&lt;br /&gt;
&lt;a href="https://github.com/M157q/hor2vec/pull/6/commits/0f67f0fe8be0312b08195b8157fac5f0be6c9830"&gt;https://github.com/M157q/hor2vec/pull/6/commits/0f67f0fe8be0312b08195b8157fac5f0be6c9830&lt;/a&gt;&lt;br /&gt;
於是我就忍不住在底下詢問他&lt;br /&gt;
到底是怎麼寫 commit message 的  &lt;/p&gt;
&lt;p&gt;他也很認真得&lt;a href="https://github.com/M157q/hor2vec/pull/6#issuecomment-343633972"&gt;給了一個很詳細的回覆&lt;/a&gt;&lt;br /&gt;
真的讓我很佩服&lt;br /&gt;
推薦對如何把 commit message 寫好有興趣的人點進去看一下  &lt;/p&gt;
&lt;p&gt;開源大法太神奇啦&lt;br /&gt;
竟然可以吸引到幫人寫測試的小精靈&lt;br /&gt;
感恩開源！讚嘆開源！&lt;br /&gt;
你在等什麼？&lt;br /&gt;
還不趕快加入開源的行列嗎？&lt;br /&gt;
搞不好你也可以找到你的開源小精靈並向對方學習喔！  &lt;/p&gt;
&lt;p&gt;（我好像該去 Review 他的 PR 了...）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;附錄&lt;/h2&gt;
&lt;p&gt;[1] 開源&lt;br /&gt;
全稱「開放源始碼」或「開放原始碼」&lt;br /&gt;
英文 "Open Source"，常被戲稱為「歐噴壽司」&lt;br /&gt;
（例句：「我今天放了一顆歐噴壽司，釣到一個路過的小精靈幫我寫測試，潮爽 der」）&lt;br /&gt;
為一種將程式原始程式碼公開讓人檢視、修改、散佈、使用的行為。&lt;br /&gt;
在台灣隸屬宗教為「開源大法教」（這是玩笑&lt;br /&gt;
教眾口號為「感恩開源！讚嘆開源！」（這也是玩笑&lt;br /&gt;
年度最大教眾聚會為「開源人年會」&lt;br /&gt;
英文全名為 Conference for Open Source Coders, Users and Promoters&lt;br /&gt;
簡稱「COSCUP」，常被戲稱為「餘弦杯」及常被誤認為台灣年度最大型 Cosplay 比賽&lt;br /&gt;
官方網址：&lt;a href="https://coscup.org"&gt;https://coscup.org&lt;/a&gt;  &lt;/p&gt;</summary><category term="Open Source"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>如何區分加密、壓縮、編碼</title><link href="https://blog.m157q.tw/posts/2017/12/23/differences-between-encryption-compression-and-encoding/" rel="alternate"></link><published>2017-12-25T17:49:55+08:00</published><updated>2017-12-25T17:49:55+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-23:posts/2017/12/23/differences-between-encryption-compression-and-encoding/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;base64 加密？base64 壓縮？base64 編碼？傻傻分不清？&lt;br /&gt;
究竟：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密（Encrypt）  &lt;/li&gt;
&lt;li&gt;壓縮（Compress）  &lt;/li&gt;
&lt;li&gt;編碼（Encode）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到底有什麼差別？  &lt;/p&gt;
&lt;p&gt;明明不管是中文還是英文，&lt;br /&gt;
這 3 個詞長得一點都不像，&lt;br /&gt;
那到底為什麼很多人會把這 3 種東西都當成加密呢？  &lt;/p&gt;
&lt;p&gt;主要是因為透過這 3 種方式處理過後的資料，&lt;br /&gt;
都會長的跟原本不一樣，&lt;br /&gt;
一般人無法直接辨別，&lt;br /&gt;
就覺得是被加密處理過的密文天書。  &lt;/p&gt;
&lt;p&gt;然而，&lt;br /&gt;
並不是變成人看不懂的東西就叫作「加密」。&lt;br /&gt;
如果誤用的話，&lt;br /&gt;
很有可能你自以為加密了的東西，&lt;br /&gt;
實際上並沒有經過加密處理，&lt;br /&gt;
隨隨便便就可以被懂其中差異的人拿到你寶貴的原始文字（最有可能的就是你的密碼啦）。&lt;br /&gt;
以下就來簡單說明這 3 種東西各自的特性，&lt;br /&gt;
會特別拿 base64 來說，&lt;br /&gt;
希望能夠端正一下視聽。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;加密（Encryption）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;首先得產生一個新的字串作為密鑰，也就是一把鑰匙。  &lt;/li&gt;
&lt;li&gt;原文與密鑰作為加密演算法的輸入，得到的輸出即為加密過後的密文。  &lt;/li&gt;
&lt;li&gt;可以想像成，加密演算法幫你打造出你給它的這把密鑰才可以開啟的寶箱，幫你把原文放入寶箱後，用這把密鑰上鎖，上鎖後的寶盒就是密文，看不到裡面的東西是什麼。  &lt;/li&gt;
&lt;li&gt;這種只有一把鑰匙的加密演算法被稱為對稱式加密（Symmetric Encryption）。  &lt;/li&gt;
&lt;li&gt;問題也很明顯，要是你沒有保管好你的鑰匙，或者你的鑰匙構造太簡單被人打造出一模一樣的鑰匙，別人就可以打開寶箱，拿到內容物。  &lt;ul&gt;
&lt;li&gt;比如說你的密鑰是一個叫作 "5566" 的字串，因為太好猜了，所以很容易被解密回來。  &lt;/li&gt;
&lt;li&gt;這也是為什麼通常在生成密鑰的時候會建議長度愈長愈好，尤其現在電腦的運算能力愈來愈強，以往透過程式一個一個暴力猜測密鑰的方式，在相同單位時間內可以猜的數量變多了，密鑰長度太短的話，很容易就被猜到。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因為對稱式加密的安全性以及在實際應用上不夠理想，於是乎，出現了安全性更高，應用範圍更廣的非對稱式加密（Asymmetric Encryption）。  &lt;/li&gt;
&lt;li&gt;非對稱式加密演算法會有兩把鑰匙，一把稱做公鑰（可以公開），另一把稱做私鑰（自己要藏好）。  &lt;/li&gt;
&lt;li&gt;非對稱式加密除了可以做到加密以外，還可以生成數位簽章，確認密文的傳送方身份真的是本人，這篇不會細談。  &lt;/li&gt;
&lt;li&gt;但這並不代表對稱式加密就沒有人用，兩者各有各的優缺點，所以實際應用上通常都是視情況而定，常常會有兩者一起使用的情形。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;對稱式：DES, 3DES, AES  &lt;/li&gt;
&lt;li&gt;非對稱式：RSA, DSA, ECC  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;沒有這把鑰匙（無論是拿到或猜到）就無法得知真正的訊息。  &lt;/li&gt;
&lt;li&gt;使用 base64 的時候不需要密鑰，而且任何人編碼的 base64 訊息，任何人都可以經過 base64 解碼回來，所以 base64 不是加密。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;壓縮（Compression）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;輸入（通常是檔案）經過壓縮演算法後得到的輸出，大小比輸入來得小。  &lt;/li&gt;
&lt;li&gt;根據有無失真又區分為非破壞性（無損）壓縮與破壞性（有損）壓縮：  &lt;ul&gt;
&lt;li&gt;無損壓縮：無失真、壓縮率沒辦法到太高，通常用在文件檔案這種不能缺少原始資料的東西。  &lt;/li&gt;
&lt;li&gt;有損壓縮：失真、壓縮率可以比較高，通常用在圖片、視訊、音訊，因為可以去掉人眼或人耳無法辨認出差異的部份，降低檔案大小可以有效提升傳輸時的效率。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;zip, gzip, rar, 7zip, jpg, mp3, mp4, Huffman coding  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論  &lt;ul&gt;
&lt;li&gt;沒有讓輸出比輸入小的演算法就不是壓縮。  &lt;/li&gt;
&lt;li&gt;經過 base64 編碼後得到的結果，實際上會比原檔案多三分之一左右，所以 base64 不是壓縮。  &lt;ul&gt;
&lt;li&gt;base64 使用 64 個可顯示的 ASCII 字元來表示二進位資料。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;2^6 = 64&lt;/code&gt;，也就是一個 base64 單元表示 6 位元，即用 1 個 ASCII 字元（8 bits），表示 6 bits 資料，比例為 &lt;code&gt;4:3&lt;/code&gt;，也就大概多了 &lt;code&gt;1/3&lt;/code&gt; 出來。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;那為什麼很多地方會提到在網頁上用 base64 表示圖片可以加速？  &lt;ul&gt;
&lt;li&gt;主要是因為把圖片直接以 base64 字串的形式呈現在網頁上的話，就不需要額外再發 request 去要圖片。  &lt;/li&gt;
&lt;li&gt;但因為 base64 會把檔案變大不少，所以很多人會先把圖片經過 gzip 壓縮後，再編碼成 base64 字串。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;編碼（Encoding）&lt;/h3&gt;
&lt;p&gt;編碼牽涉的範圍非常廣，&lt;br /&gt;
包含了：字元編碼（Character Encoding）、音訊編碼（Audio Encoding）、視訊編碼（Video Encoding）、…… 等等，&lt;br /&gt;
所以在這篇文章不會仔細講。&lt;br /&gt;
其實廣義上來說，&lt;br /&gt;
上述提到的加密與壓縮都算是編碼的其中一種，&lt;br /&gt;
但這裡就把上述兩個排除。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特性  &lt;ul&gt;
&lt;li&gt;將原文轉換成另外一種表達方式。  &lt;/li&gt;
&lt;li&gt;不需要密鑰，只要知道你用哪個編碼演算法，任何人都可以解碼。  &lt;ul&gt;
&lt;li&gt;這也是單純編碼被拿來誤用成加密演算法最危險的地方，因為完全不需要花時間猜密鑰。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同的編碼演算法有不同的特性  &lt;ul&gt;
&lt;li&gt;錯誤偵測（Error Detection）  &lt;ul&gt;
&lt;li&gt;檢查訊息在經過傳送後是否已經改變。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;錯誤校正（Error Correction）  &lt;ul&gt;
&lt;li&gt;自動修正在經過傳送後錯誤的內容。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方便資料進行傳輸  &lt;ul&gt;
&lt;li&gt;以不同的形式表示相同的資料。  &lt;/li&gt;
&lt;li&gt;例如: base64 就把二進位的資料用 ASCII 來表示。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常見演算法  &lt;ul&gt;
&lt;li&gt;base64, urlencode, hamming code,  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有密鑰：加密  &lt;/li&gt;
&lt;li&gt;輸出比輸入小：壓縮  &lt;/li&gt;
&lt;li&gt;其他：編碼  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="Encryption"></category><category term="Compression"></category><category term="Encoding"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>用 Python 寫個程式抓出我在 Twitter 上存了哪些 tweet</title><link href="https://blog.m157q.tw/posts/2017/12/22/write-a-python-script-to-retrieve-twitter-direct-messsages/" rel="alternate"></link><published>2017-12-24T22:58:08+08:00</published><updated>2017-12-24T22:58:08+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-22:posts/2017/12/22/write-a-python-script-to-retrieve-twitter-direct-messsages/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;身為一個邊緣人，&lt;br /&gt;
沒有 Instagram 帳號，&lt;br /&gt;
卻有台灣沒什麼人用的 Twitter 帳號也是很合理的。  &lt;/p&gt;
&lt;p&gt;其實 Twitter 上很容易得到國外第一手即時資訊，&lt;br /&gt;
常常看到好幾天之後才在 Facebook 或台灣的媒體看到消息，&lt;br /&gt;
很適合我這種資訊焦慮症的人（？  &lt;/p&gt;
&lt;p&gt;Twitter 也很容易跟一些很有名的人直接交流，&lt;br /&gt;
像上一篇翻譯文章的授權，&lt;br /&gt;
我就是直接在 Twitter 上問作者，&lt;br /&gt;
大概五分鐘之內，沒錯，就是短短幾分鐘之內，就收到作者同意的回覆。  &lt;/p&gt;
&lt;p&gt;總之，&lt;br /&gt;
我平常在用 Twitter 的時候有個習慣，&lt;br /&gt;
就是把我看到覺得值得保留下來的 tweet 分成兩類，&lt;br /&gt;
一類是比較不嚴肅的，把該 tweet 私訊給自己。&lt;br /&gt;
另一類是比較嚴肅的，把該 tweet 私訊給另外一個 RSS bot 帳號。&lt;br /&gt;
（這個 RSS bot 有機會的話會發篇文章講一下）  &lt;/p&gt;
&lt;p&gt;這裡要來用 Python 寫個程式，&lt;br /&gt;
把今年存下來的這兩大類 tweet 抓出來，&lt;br /&gt;
其實我不確定是不是一定會成功，&lt;br /&gt;
大概只有 87% 的把握，&lt;br /&gt;
總之接下來就一步步講一下要怎麼做。  &lt;/p&gt;
&lt;p&gt;（謎之音：最愛寫這種無用的小程式了。）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;步驟&lt;/h2&gt;
&lt;h3&gt;看有哪個 API 可以拿來用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.twitter.com/en/docs/direct-messages/sending-and-receiving/api-reference/list-events"&gt;GET direct_messages/events/list — Twitter Developers&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;最多只能抓取最近的 200 則私訊（不限 30 天內。）  &lt;/li&gt;
&lt;li&gt;如果超過 200 則的話，只能抓取最近 30 天內的私訊。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;取得 Access Token&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;到 &lt;a href="https://apps.twitter.com/"&gt;https://apps.twitter.com/&lt;/a&gt; 建立一個新的 App。  &lt;/li&gt;
&lt;li&gt;記下 Consumer Key (API Key) 和 Consumer Secret (API Secret)  &lt;/li&gt;
&lt;li&gt;點選 Permissions  &lt;ul&gt;
&lt;li&gt;選取 Read, Write and Access direct messages。（原本只有 Read, Write）  &lt;/li&gt;
&lt;li&gt;選好之後按底下的 Update Settings  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;點進去剛建立的 App，移到底下，點選建立 Access Token。  &lt;/li&gt;
&lt;li&gt;記下 Access Token 和 Access Token Secret  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安裝要使用的 Python 套件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/bear/python-twitter"&gt;https://github.com/bear/python-twitter&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install python-twitter&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;撰寫程式&lt;/h3&gt;
&lt;p&gt;因為兩個的作法類似，&lt;br /&gt;
這邊就以抓出比較嚴肅一點的 tweet 作為範例，&lt;br /&gt;
幾行就可以寫完了。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python3  &lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib&lt;/span&gt;  

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;twitter&lt;/span&gt;  


&lt;span class="c1"&gt;# Fill these contants by yourself.  &lt;/span&gt;
&lt;span class="n"&gt;CONSUMER_KEY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;CONSUMER_SECRET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;ACCESS_TOKEN_KEY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;ACCESS_TOKEN_SECRET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;MY_TWITTER_ID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  
&lt;span class="n"&gt;MY_BOT_TWITTER_ID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  


&lt;span class="n"&gt;api&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;twitter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Api&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;consumer_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;CONSUMER_KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
    &lt;span class="n"&gt;consumer_secret&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;CONSUMER_SECRET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
    &lt;span class="n"&gt;access_token_key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ACCESS_TOKEN_KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
    &lt;span class="n"&gt;access_token_secret&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ACCESS_TOKEN_SECRET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
&lt;span class="p"&gt;)&lt;/span&gt;  

&lt;span class="c1"&gt;# Twitter API limitation:  &lt;/span&gt;
&lt;span class="c1"&gt;# &amp;quot;Last 30 days DMs&amp;quot; or &amp;quot;Up to 200 DMs which created before 30 days&amp;quot;  &lt;/span&gt;
&lt;span class="n"&gt;sent_direct_messages&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetSentDirectMessages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;dm&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sent_direct_messages&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;dm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recipient_id&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MY_BOT_TWITTER_ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="c1"&gt;# Got t.co url in DM, use urllib to get its real Twitter Status URL.  &lt;/span&gt;
            &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;urllib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;real_url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;geturl&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="k"&gt;raise&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;+ &amp;lt;{}&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;real_url&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;開一個 gist 放個程式碼：&lt;a href="https://gist.github.com/M157q/a90f5d2948442dc482e35d671b074c6f"&gt;https://gist.github.com/M157q/a90f5d2948442dc482e35d671b074c6f&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;結果&lt;/h2&gt;
&lt;p&gt;直接以網址呈現：&lt;br /&gt;
（其實應該可以直接 embed tweet 啦，但我有點懶得弄。）  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/yoyo0329/status/944230050399793152"&gt;https://twitter.com/yoyo0329/status/944230050399793152&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/rewoIf/status/943852230796484610"&gt;https://twitter.com/rewoIf/status/943852230796484610&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/zaticwu/status/943834445886267392"&gt;https://twitter.com/zaticwu/status/943834445886267392&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/zhusee2/status/943728354057887744"&gt;https://twitter.com/zhusee2/status/943728354057887744&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/TinyDenny/status/943332441699299328"&gt;https://twitter.com/TinyDenny/status/943332441699299328&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/CHl1XIB8ymdrKbC/status/943482302822150144"&gt;https://twitter.com/CHl1XIB8ymdrKbC/status/943482302822150144&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/jserv/status/942265803868487680"&gt;https://twitter.com/jserv/status/942265803868487680&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/rochacbruno/status/942419952300167169"&gt;https://twitter.com/rochacbruno/status/942419952300167169&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/daiwanhanji/status/942046653619478535"&gt;https://twitter.com/daiwanhanji/status/942046653619478535&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/thecat/status/942193282968305664"&gt;https://twitter.com/thecat/status/942193282968305664&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/riddle_ling/status/942271085495459840"&gt;https://twitter.com/riddle_ling/status/942271085495459840&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/c9s/status/942224140273987584"&gt;https://twitter.com/c9s/status/942224140273987584&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/sandokaishy/status/942057552577052672"&gt;https://twitter.com/sandokaishy/status/942057552577052672&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/johnroyer/status/941478195362119682"&gt;https://twitter.com/johnroyer/status/941478195362119682&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/ferrari_tw/status/941137503423119360"&gt;https://twitter.com/ferrari_tw/status/941137503423119360&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/lovecankill/status/940781592947048448"&gt;https://twitter.com/lovecankill/status/940781592947048448&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/linuxtoy/status/940780140081975298"&gt;https://twitter.com/linuxtoy/status/940780140081975298&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/Ignissfate/status/940453739718066177"&gt;https://twitter.com/Ignissfate/status/940453739718066177&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/schrockn/status/940037656494317568"&gt;https://twitter.com/schrockn/status/940037656494317568&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/M157q/status/939785465992953857"&gt;https://twitter.com/M157q/status/939785465992953857&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/welkineins/status/939541907612377089"&gt;https://twitter.com/welkineins/status/939541907612377089&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/WanCW/status/938624903724404736"&gt;https://twitter.com/WanCW/status/938624903724404736&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/jaceju/status/937497004690751488"&gt;https://twitter.com/jaceju/status/937497004690751488&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/ronnywang/status/937511877092847616"&gt;https://twitter.com/ronnywang/status/937511877092847616&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/hynek/status/937316249431928832"&gt;https://twitter.com/hynek/status/937316249431928832&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/Schnappiggg/status/936591006169890816"&gt;https://twitter.com/Schnappiggg/status/936591006169890816&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/tebeka/status/934013246226526210"&gt;https://twitter.com/tebeka/status/934013246226526210&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/riddle_ling/status/932499976193585152"&gt;https://twitter.com/riddle_ling/status/932499976193585152&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/PeterZaitsev/status/931485736855134213"&gt;https://twitter.com/PeterZaitsev/status/931485736855134213&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/TinyDenny/status/932093891368460288"&gt;https://twitter.com/TinyDenny/status/932093891368460288&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/ruanyf/status/931709967966412800"&gt;https://twitter.com/ruanyf/status/931709967966412800&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/dlackty/status/931328546664050689"&gt;https://twitter.com/dlackty/status/931328546664050689&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/joelgrus/status/931202032978948096"&gt;https://twitter.com/joelgrus/status/931202032978948096&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/x0rz/status/930016909231362048"&gt;https://twitter.com/x0rz/status/930016909231362048&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/TinyDenny/status/929187796752855040"&gt;https://twitter.com/TinyDenny/status/929187796752855040&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/dbader_org/status/927899530942668801"&gt;https://twitter.com/dbader_org/status/927899530942668801&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/M157q_News_RSS/status/925543091339010048"&gt;https://twitter.com/M157q_News_RSS/status/925543091339010048&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/WanCW/status/924993679156056064"&gt;https://twitter.com/WanCW/status/924993679156056064&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/jaceju/status/924455583587037184"&gt;https://twitter.com/jaceju/status/924455583587037184&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/LoveHyperApp/status/923523498743439360"&gt;https://twitter.com/LoveHyperApp/status/923523498743439360&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/suitingtseng/status/923917098233073664"&gt;https://twitter.com/suitingtseng/status/923917098233073664&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;題外話&lt;/h2&gt;
&lt;p&gt;在寫這篇的時候發現，&lt;br /&gt;
最近 Twitter 好像針對這需求有了一個&lt;a href="https://techcrunch.com/2017/11/23/twitter-is-testing-bookmarks-a-feature-to-privately-flag-tweets-for-later/"&gt;新的 Bookmark 功能&lt;/a&gt;，&lt;br /&gt;
看了一下，好像還不能分類就是，&lt;br /&gt;
所以我應該還是會繼續用這樣的方式當作 bookmark。  &lt;/p&gt;
&lt;p&gt;然後也發現好像多了個 &lt;a href="https://developer.twitter.com/en/docs/accounts-and-users/subscribe-account-activity/overview"&gt;Account Activity API&lt;/a&gt;，&lt;br /&gt;
可以設定 webhook 即時接收帳號的事件，&lt;br /&gt;
可能可以做到類似聊天機器人這樣事件觸發式的對話。  &lt;/p&gt;
&lt;p&gt;如果是這裡的用途的話，&lt;br /&gt;
可以在我每次發送私訊的時候，&lt;br /&gt;
就直接透過 webhook 把該 tweet 的內容存在資料庫裡，&lt;br /&gt;
這樣就不會受 Twitter API 的限制了，&lt;br /&gt;
有空的話再來弄吧。  &lt;/p&gt;</summary><category term="Python"></category><category term="Twitter"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>《回答的智慧》</title><link href="https://blog.m157q.tw/posts/2017/12/21/how-to-answer-questions-in-a-helpful-way-zh-tw/" rel="alternate"></link><published>2017-12-22T22:51:26+08:00</published><updated>2017-12-22T22:51:26+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-21:posts/2017/12/21/how-to-answer-questions-in-a-helpful-way-zh-tw/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;本文為翻譯文章  &lt;/li&gt;
&lt;li&gt;原文為：&lt;a href="https://jvns.ca/blog/answer-questions-well/"&gt;How to answer questions in a helpful way - Julia Evans&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://mobile.twitter.com/M157q/status/943722828188151808"&gt;本文已獲得作者 Julia Evans 同意授權翻譯並發佈&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;《回答的智慧》&lt;/h2&gt;
&lt;p&gt;當你遇到與你共事的人向你詢問問題，&lt;br /&gt;
卻描述得不太清楚時，你會怎麼回答？&lt;br /&gt;
我認為問問題是門學問，&lt;br /&gt;
（請參見我另外一篇文章 &lt;a href="https://jvns.ca/blog/good-questions/"&gt;How to ask good questions&lt;/a&gt;）&lt;br /&gt;
【譯註：這是作者另外一篇文章，有機會的話我也會嘗試翻譯。】&lt;br /&gt;
然而，&lt;br /&gt;
如何有效得回答問題同樣是門學問，&lt;br /&gt;
兩者同等實用。  &lt;/p&gt;
&lt;p&gt;在開始之前，先做個假設：&lt;br /&gt;
我知道大家多少都遇過不尊重你的寶貴時間的提問者，&lt;br /&gt;
那種感覺很糟。&lt;br /&gt;
但在這篇文章中，&lt;br /&gt;
我要先假定這樣的情況不存在。&lt;br /&gt;
假設這篇文章裡的提問者都是合乎理性且會盡全力把事情弄懂，&lt;br /&gt;
是會讓你想幫助的那種人。&lt;br /&gt;
因為身邊和我一起工作的伙伴都是這樣的人，&lt;br /&gt;
而我目前就是在這樣的環境下工作。&lt;br /&gt;
【譯註：除了讓人羨慕以外，我想這也會讓這篇文章著重在回答問題上，比較不會模糊焦點。】  &lt;/p&gt;
&lt;p&gt;以下是一些我認為如何更有效回答問題的方法：  &lt;/p&gt;
&lt;h3&gt;如果對方的問題不夠明確，幫助對方釐清問題&lt;/h3&gt;
&lt;p&gt;初學者常會提出不夠明確的問題，或者提出沒有足夠資訊、讓人無從回答的問題。&lt;br /&gt;
這裡有幾個方法可以讓你幫助他們釐清問題：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用&lt;strong&gt;更確切的問題&lt;/strong&gt;回問對方。  &lt;/li&gt;
&lt;li&gt;詢問對方沒有提供的那些&lt;strong&gt;更加確切的資訊&lt;/strong&gt;。  &lt;ul&gt;
&lt;li&gt;例如：你是使用 IPv6 嗎？  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;詢問對方&lt;strong&gt;是什麼原因而問這個問題&lt;/strong&gt;。  &lt;ul&gt;
&lt;li&gt;舉例來說，有時候我會遇到同事在群組頻道裏面詢問「我們公司的 service discovery 是如何運作的？」  &lt;/li&gt;
&lt;li&gt;通常會有此一問是因為他們正在嘗試架設或是調整某個服務。  &lt;/li&gt;
&lt;li&gt;在這種情況下，回問「你現在在弄哪個服務？我可以看一下你目前的 Pull Request  嗎？」會是有幫助的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多類似的方法在我的另外一篇文章 &lt;a href="https://jvns.ca/blog/good-questions/"&gt;How to ask good questions&lt;/a&gt; 都有被提及。&lt;br /&gt;
（然而我絕對不會對某個人說：「喔，你必須先看過這篇 &lt;a href="https://jvns.ca/blog/good-questions/"&gt;How to ask good questions&lt;/a&gt; 才能問我問題。」）  &lt;/p&gt;
&lt;h3&gt;先瞭解對方已經知道哪些東西&lt;/h3&gt;
&lt;p&gt;在回答問題之前，先瞭解對方已經知道哪些東西是很有用的。  &lt;/p&gt;
&lt;p&gt;Harold Treen 給了我一個很棒的例子：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某天有個人要我解釋 "&lt;a href="https://github.com/redux-saga/redux-saga"&gt;Redux Sagas&lt;/a&gt;" 是什麼，我並沒有直接回答：「它們就像等待 action 並幫你更新 store 的背景工作執行緒 (worker threads)！」&lt;br /&gt;
而是先從對方對於 Redux, Redux 的 action, Redux 的 store 及其他關於 Redux 的基本觀念瞭解多少著手，如此一來會讓解釋 Redux Sagas 這件事容易一些，因為這些觀念與其環環相扣。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;瞭解對你提問的人已經知道哪些東西是很重要的，&lt;br /&gt;
因為對方可能是連一些基本的觀念都還搞不太清楚的新手（例如：什麼是 Redux?），&lt;br /&gt;
也可能是遇到極端案例（corner case）的老手。&lt;br /&gt;
你的回答如果是建立在對方不知道的觀念上，會造成對方的困惑；&lt;br /&gt;
你的回答如果是重述對方已經知道的事情，則會讓對方感到厭煩。  &lt;/p&gt;
&lt;p&gt;在詢問對方已經知道哪些東西的時候，有個實用的技巧是，&lt;br /&gt;
與其問對方「你知道 XXX 嗎？」&lt;br /&gt;
也許可以試著改成問對方「你對 XXX 瞭解的程度有多少？」&lt;br /&gt;
【譯註：第一種問法得到的回答通常只有「知道」或「不知道」，而第二種通常會得到比較詳細一點的回答，能夠比第一種問法容易知道對方的程度。】  &lt;/p&gt;
&lt;h3&gt;告訴對方應該要看哪些文件&lt;/h3&gt;
&lt;p&gt;「去讀那些他媽的文件」(RTFM) 是最典型的無用回答，&lt;br /&gt;
但如果你明確告訴對方要去看哪個文件則能產生很大的幫助。&lt;br /&gt;
當我問問題的時候，比起直接得到答案，&lt;br /&gt;
我其實比較喜歡被告知該去看哪份文件，&lt;br /&gt;
因為該份文件的內容很可能也會順便解決掉我其他的問題。  &lt;/p&gt;
&lt;p&gt;我認為有件很重要的事情是，&lt;br /&gt;
你必須確保當下告知對方的文件真的有回答到他的問題，&lt;br /&gt;
如果沒有的話，至少在事後確認它有幫助到對方。&lt;br /&gt;
否則你很有可能上演這種常見的場景：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;問：「我要怎麼做到 X 這件事？」  &lt;/li&gt;
&lt;li&gt;答：（給了一份文件的連結）  &lt;/li&gt;
&lt;li&gt;問：「這份文件沒有解釋 X 啊，只有解釋 Y。」  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我告知對方的文件太過冗長的話，&lt;br /&gt;
我會明確點出我正在說的是其中的哪一個部份。&lt;br /&gt;
&lt;a href="https://linux.die.net/man/1/bash"&gt;Bash 的使用說明&lt;/a&gt; 有 44,000 個英文字（這是真的！），&lt;br /&gt;
所以如果只告訴對方「去看 Bash 的使用說明。」根本沒什麼幫助。  &lt;/p&gt;
&lt;h3&gt;告訴對方可以用什麼樣的關鍵字去搜尋&lt;/h3&gt;
&lt;p&gt;在工作上，&lt;br /&gt;
我時常會使用一些「我知道這會讓我得到答案」的關鍵字來進行搜尋。&lt;br /&gt;
然而這樣的關鍵字對於新手來說可能不是這麼顯而易見，&lt;br /&gt;
所以告訴對方「如果是我的話，我會用 XXX 關鍵字來搜尋答案。」是很有用的。&lt;br /&gt;
同樣地，記得事後確認一下你給出的關鍵字真的有幫助到他們。  &lt;/p&gt;
&lt;h3&gt;撰寫新文件&lt;/h3&gt;
&lt;p&gt;我常常不斷遇到不同的人來問我所處的團隊一模一樣的問題，&lt;br /&gt;
但這並不是這些人的錯，&lt;br /&gt;
畢竟他們不知道在這之前已經有 10 個人問過一樣的問題，&lt;br /&gt;
也不知道答案。&lt;br /&gt;
因此，與其一直重複告訴不同的人相同的答案，&lt;br /&gt;
我和團隊的其他人改用了以下的步驟：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;馬上為這個問題撰寫解答的文件  &lt;/li&gt;
&lt;li&gt;告訴提問者這份我們新撰寫的文件  &lt;/li&gt;
&lt;li&gt;皆大歡喜！  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;雖然撰寫文件花費的時間比直接回答問題還多，&lt;br /&gt;
但通常是很值得的，尤其是以下幾種問題：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一而再，再而三，不斷被人重複問的問題。  &lt;/li&gt;
&lt;li&gt;答案不太會隨時間而變動的問題。  &lt;ul&gt;
&lt;li&gt;如果答案是每週或每月就會變動的話，這份文件就很容易過期，也會令提問者感到失望。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;向對方解釋你做了哪些事&lt;/h3&gt;
&lt;p&gt;身為某個領域的初學者時，&lt;br /&gt;
如果發生以下對話，真的會令人很沮喪：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;菜鳥：「你怎麼弄這東西的？」  &lt;/li&gt;
&lt;li&gt;老鳥：「就這樣啊，我弄完了。」  &lt;/li&gt;
&lt;li&gt;菜鳥：「……，但你做了哪些事啊？」  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果向你提問的人正在嘗試瞭解某件事是如何運作的話，&lt;br /&gt;
幾個方法將對其有所幫助：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帶對方完整跑過一次流程，而不是只做給對方看。  &lt;/li&gt;
&lt;li&gt;告訴對方你是用了哪些方法得到答案的&lt;br /&gt;
【譯註：給他釣竿教他如何自己釣到魚，而不是在他面前釣魚給他看，然後把釣到的魚給他。】  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然這比你直接做給對方看要花更多時間，&lt;br /&gt;
但這對於提問者來說是個學習的機會，&lt;br /&gt;
如此一來，他們往後面對相同的問題時就能夠有所準備。  &lt;/p&gt;
&lt;p&gt;套用這樣的方法，對話狀況就會好上許多：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;菜鳥：「我在網站上看到錯誤，發生什麼事了？」  &lt;/li&gt;
&lt;li&gt;老鳥：「（檢查兩分鐘後）喔，因為資料庫正在進行容錯移轉（failover）。」  &lt;/li&gt;
&lt;li&gt;菜鳥：「原來！你是怎麼知道的啊？」  &lt;/li&gt;
&lt;li&gt;老鳥：「以下是我做的判斷：」  &lt;ul&gt;
&lt;li&gt;從錯誤訊息看來，這類的錯誤通常是因為某個服務掛了，我去察看了一下，發現該服務還在正常執行，所以問題不在這。  &lt;/li&gt;
&lt;li&gt;所以我去看了網站的後台，後台顯示有個資料庫容錯移轉的動作正在執行。  &lt;/li&gt;
&lt;li&gt;然後我再去察看該服務的紀錄檔，紀錄裡頭顯示連線到資料庫的時候出錯了，看起來問題就出在這。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你向對方解釋你如何針對問題進行除錯，&lt;br /&gt;
將有利於讓對方瞭解你如何排除其他原因及如何發現真正的問題點。&lt;br /&gt;
當你遇到問題時，能馬上判斷出原因，的確是件讓人覺得很爽的事。&lt;br /&gt;
但幫助他人學得更好、更深入分析問題，&lt;br /&gt;
並瞭解到自己想出來的對策是有效的，&lt;br /&gt;
是件更棒的事。  &lt;/p&gt;
&lt;h3&gt;解決最根本的問題&lt;/h3&gt;
&lt;p&gt;這個方法比較難一點，有時候會遇到一種情況，&lt;br /&gt;
提問者覺得自己已經找到了正確的解決方法，&lt;br /&gt;
且只差最後一個關鍵就可以把問題解決，&lt;br /&gt;
但其實很可能不是這麼一回事。&lt;br /&gt;
舉例來說：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;George:「我現在在想辦法搞定 X，然後出錯了，我要怎麼解掉這個錯誤？」  &lt;/li&gt;
&lt;li&gt;Jasminda: 「你實際上是不是想搞定 Y？如果是的話，你不應該從 X 下手，你應該要從 Z 下手才對。」  &lt;/li&gt;
&lt;li&gt;George：「對耶！感謝！那我要先來解決 Z。」  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上面的對話中，Jasminda 並沒有直接回答 George 的問題，&lt;br /&gt;
而是根據經驗推測 George 實際上不是想搞定 X 這件事，&lt;br /&gt;
而她對了，這個舉動非常的有用。  &lt;/p&gt;
&lt;p&gt;但有一點要注意的是，&lt;br /&gt;
如果回答者太過於高姿態的話，很可能會造成反效果，&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;George:「我現在在想辦法搞定 X，然後出錯了，我要怎麼解掉這個錯誤？」  &lt;/li&gt;
&lt;li&gt;Jasminda:「不用解這個錯誤，你實際上應該是想搞定 Y，然後你應該先從 Z 著手。」  &lt;/li&gt;
&lt;li&gt;George:「ㄜ，我真的沒有想解決 Y，我是真的因為某些原因想要搞定 X，我到底該怎麼做？」  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以回答時切忌高姿態，&lt;br /&gt;
而且要記住，有些提問者有可能會附上他們已經做了哪些事，&lt;br /&gt;
最好的回答方式是，&lt;br /&gt;
針對「對方提問的問題」及「對方真正該問的問題」都進行回答，&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;p&gt;「如果你想要解決 X 的話，你可以試試看這個方法，但如果你想用這個方法解決 Y 的話，我建議你用另外一個方法，那個方法比較有效。」  &lt;/p&gt;
&lt;h3&gt;問對方「這樣有回答到你的問題嗎？」&lt;/h3&gt;
&lt;p&gt;我喜歡在自認為已經回答到對方的問題後，&lt;br /&gt;
額外向對方確認：「這樣有回答到你的問題嗎？還有更多想問的嗎？」  &lt;/p&gt;
&lt;p&gt;然後我會停下來等對方回答這個問題，&lt;br /&gt;
這樣做的好處是，人們總是需要個一兩分鐘確認自己是不是真的搞懂了。&lt;br /&gt;
我是在撰寫文件的時候才特別發現，&lt;br /&gt;
這句額外的「這樣有回答到你的問題嗎？」是很有用的，&lt;br /&gt;
我因為這點，&lt;br /&gt;
常常在為我已經熟知的事物撰寫文件時，&lt;br /&gt;
留下一些對他人而言重要的資訊而不自知。  &lt;/p&gt;
&lt;h3&gt;嘗試當面、視訊或語音通話來溝通，不要只用文字&lt;/h3&gt;
&lt;p&gt;我是一位遠端工作者，&lt;br /&gt;
所以我和同事絕大多數的對話都是用文字溝通，&lt;br /&gt;
對我來說，文字是預設的溝通方式。  &lt;/p&gt;
&lt;p&gt;現今，我們活在一個很容易進行視訊會議與分享螢幕畫面的世界。&lt;br /&gt;
工作時，我可以點個按鈕就開始和某人進行視訊會議，&lt;br /&gt;
並分享螢幕畫面給對方。&lt;br /&gt;
許多問題用講的會比用打字的更容易解決。  &lt;/p&gt;
&lt;p&gt;例如：&lt;br /&gt;
最近有人問我要如何規劃與設定服務自動擴充（autoscaling）的容量，&lt;br /&gt;
我腦中大概可以想出有哪些東西需要釐清，&lt;br /&gt;
但還不是非常確定真正的情況。&lt;br /&gt;
於是我們快速通了個視訊電話，&lt;br /&gt;
五分鐘之後，&lt;br /&gt;
就回答完他們提出的所有問題了。  &lt;/p&gt;
&lt;p&gt;我特別相信，如果有人對於某件事情不知道如何下手，&lt;br /&gt;
以結對程式設計（pair programming）的方式進行當面的溝通，&lt;br /&gt;
只要幾分鐘就會很有幫助，&lt;br /&gt;
比只用電子郵件或即時通訊軟體來溝通有效多了。  &lt;/p&gt;
&lt;h3&gt;回答問題時不要表現得很驚訝&lt;/h3&gt;
&lt;p&gt;這個原則出自於 &lt;a href="https://www.recurse.com/manual#no-feigned-surprise"&gt;Recurse Center 手冊的其中一條：別假裝很驚訝&lt;/a&gt;，&lt;br /&gt;
常見的情況：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小明：「什麼是 Linux kernel？」  &lt;/li&gt;
&lt;li&gt;小華：「蛤？你竟然沒有聽過 Linux kernel？真的假的啊？」  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小華的反應（姑且先不論他到底是真的訝異還是假的訝異）一點幫助也沒有，&lt;br /&gt;
只會讓小明因為自己不知道 Linux kernel 是什麼而感到非常受傷。  &lt;/p&gt;
&lt;p&gt;即便我因為聽到對方不知道某個東西而真的感到有點訝異，&lt;br /&gt;
我反而會故作鎮定，能做到這點的話會是件很棒的事。  &lt;/p&gt;
&lt;h3&gt;能夠有效得回答問題是件非常棒的事&lt;/h3&gt;
&lt;p&gt;顯然的，以上這些方法並不是任何情況都適用，&lt;br /&gt;
但希望你至少可以從中找到幾個你覺得有用的方法。&lt;br /&gt;
我發現花時間回答問題與教導別人是非常有收穫的一件事。  &lt;/p&gt;
&lt;p&gt;非常感謝 Josh Triplett 為這篇文章給出許多建議和幫忙新增很多很棒的內容。&lt;br /&gt;
感謝 Harold Treen、Vaibhav Sagar、Peter Bhat Harkins、Wesley Aptekar-Cassels 和 Paul Gowder 花時間閱讀這篇文章並給予評論。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;更多譯註&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;這篇是目前在 Stripe 工作的 &lt;a href="https://jvns.ca/about/"&gt;Julia Evans&lt;/a&gt;，於今年 9 月 21 日發表在其部落格上的文章：&lt;a href="https://jvns.ca/blog/answer-questions-well/"&gt;How to answer questions in a helpful way - Julia Evans&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;Julia Evans 是我去年開始在 Feedly 上追蹤的一名美國女性程式設計師  &lt;/li&gt;
&lt;li&gt;忘記當初是因為哪篇文章追蹤的了，但我很佩服她的一點是，她學新東西的時候都會寫文章紀錄下來，並把東西講得非常詳細。雖然篇幅會非常長，但我每次看她的文章都覺得講得很清楚。  &lt;/li&gt;
&lt;li&gt;她還有&lt;a href="https://jvns.ca/zines/"&gt;一系列把程式技術相關的名詞畫成簡單的漫畫來講解&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;內容包括：Linux, Kubernetes, ...等等。  &lt;/li&gt;
&lt;li&gt;有些小孩甚至會看這些漫畫學習這些新技術，我覺得很酷。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可能很多人都有看過 &lt;a href="http://www.catb.org/%7Eesr/faqs/smart-questions.html"&gt;Eric Steven Raymond 的 How To Ask Questions The Smart Way&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;中文翻譯為《提問的智慧》  &lt;/li&gt;
&lt;li&gt;最常被人拿出來說的就是 RTFM (Read The Fucking Manual）  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way"&gt;這裡有繁體中文版，沒看過的人建議一定要看一下&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;這篇文章非常強調問問題的人應該做好完整的功課，並且在詢問問題上要做到哪些事情，不要讓人不想回答你或是浪費回答你的人的時間。  &lt;/li&gt;
&lt;li&gt;但其實在這篇文章最後面有一節的名稱叫作 &lt;a href="http://www.catb.org/~esr/faqs/smart-questions.html#idm46060473965552"&gt;How to Answer Questions in a Helpful Way （中譯為《回答的智慧》）&lt;/a&gt;，但篇幅不多。  &lt;ul&gt;
&lt;li&gt;沒記錯的話其實早一點的版本沒有，好像是後來才加入這章節的。  &lt;/li&gt;
&lt;li&gt;而 Julia Evans 的這篇文章可以算是大大補足了這個章節的內容，也讓問答的雙方是比較平等一點的。  &lt;/li&gt;
&lt;li&gt;畢竟有時候還是會遇到準備問題的人準備得很充實，但得到的解答卻是隨隨便便的敷衍的那種狀況。  &lt;/li&gt;
&lt;li&gt;我想一個良好的問答品質需要雙方共同努力是一定的，這樣才能更有效率得教學相長。  &lt;/li&gt;
&lt;li&gt;其實如果按照原文標題 "How to answer questions in a helpful way" 來翻譯的話，應該翻成《如何更有效得回答問題》或《如何更好得回答問題》。  &lt;/li&gt;
&lt;li&gt;但因為 ESR 那篇文章被翻為《提問的智慧》，且裡頭同名的章節被翻譯成《回答的智慧》，所以我覺得這篇直接翻成《回答的智慧》會讓這兩篇文章更有連結性。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;看完這篇文章的當下後想了一下，&lt;br /&gt;
發現自己之前回答同事的問題算是都有做到這篇文章提到的事情，&lt;br /&gt;
但我還有多做一件事：「告知對方下次可以怎樣問會更好。」&lt;br /&gt;
這篇也很適合三不五時回來看看並反省自己是否有做到。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;這篇是我的部落格第 1 篇翻譯文章，&lt;br /&gt;
也是第 300 篇發佈的文章。&lt;br /&gt;
如果覺得翻譯得不錯的話，&lt;br /&gt;
請不吝留言和幫我分享這篇文章，&lt;br /&gt;
如果覺得哪邊翻譯的不太好的話，&lt;br /&gt;
也麻煩留言跟我說，&lt;br /&gt;
有任何討論也都歡迎留言。  &lt;/p&gt;</summary><category term="Julia Evans"></category><category term="Programmer"></category><category term="Answer Questions"></category><category term="Collaboration"></category><category term="2018 iT 邦幫忙鐵人賽"></category></entry><entry><title>關於 4G 行動網路的一些筆記</title><link href="https://blog.m157q.tw/posts/2017/12/20/4g-mobile-network-tw/" rel="alternate"></link><published>2017-12-21T14:47:50+08:00</published><updated>2017-12-21T14:47:50+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2017-12-20:posts/2017/12/20/4g-mobile-network-tw/</id><summary type="html">&lt;p&gt;本文利用工人智慧技術同步發表於 &lt;a href="https://ithelp.ithome.com.tw/articles/10192595"&gt;[2018 iThome 鐵人賽] Day 1: 關於 4G 行動網路的一些筆記 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天&lt;/a&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;其實手機使用中華電信的 4G 行動網路已經將近快兩年了，&lt;br /&gt;
但其實一直以來就只是用而已，對它並沒有很瞭解。&lt;br /&gt;
最近因為：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中華電信在我目前的租屋處收訊不好，即便是使用了 4G 行動網路，速度還是很慢，更別說常常掉到 3G 行動網路。  &lt;/li&gt;
&lt;li&gt;一到人多的地方，中華電信的 4G 行動網路就卡死了，因為附近的使用者太多，導致頻寬過少，基地台負荷不了。  &lt;/li&gt;
&lt;li&gt;目前使用中華電信的 4G 行動上網吃到飽方案，一個月要將近 1400 元新台幣的費用，我覺得以這服務品質來說實在太過於不划算（當初是因為要當個孝子，讓媽免費拿平板才綁這兩年約。Orz）。算了一下，調降目前的資費再選擇其他電信商的 4G 吃到飽專案，隨便搭都比我現在的費用便宜。  &lt;/li&gt;
&lt;li&gt;iOS 開 Wi-Fi 熱點分享很雷(我是用 iPhone SE + iOS 10.3.1），有以下幾個我覺得很雷的點：  &lt;ul&gt;
&lt;li&gt;開熱點分享真的很耗電，常常都要接著充電，覺得很麻煩。  &lt;/li&gt;
&lt;li&gt;疑似是通訊晶片的問題，開熱點分享常常要開好幾次才找得到。  &lt;/li&gt;
&lt;li&gt;遇到附近有記憶過的無線網路也沒辦法開熱點分享，因為會直接連上該無線網路。在前公司遇到一些狀況要切換網路環境測試的時候很麻煩，還不如直接用 USB tethering。  &lt;/li&gt;
&lt;li&gt;開熱點分享的時候螢幕上永遠有一條藍色的 status bar 沒辦法關掉，iPhone SE 的螢幕就夠小了，更別說常常不小心點到，就跑到開關熱點的畫面，覺得很煩。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;iOS App Store 如果安裝或更新需要下載超過 150 MB 的話，就一定要你連上 Wi-Fi，真的不知道這到底是什麼鳥設計。  &lt;ul&gt;
&lt;li&gt;更新 iOS 版本也要連上 Wi-Fi，所以我幾乎沒更新過，還好最近 iOS 11 看來寫的不太好，可能也不需要急著更新。  &lt;/li&gt;
&lt;li&gt;當然是不能連自己的熱點分享，加上身為一個邊緣阿宅又不太敢連 Public Wi-Fi 的人，常常有些 App 不能更新或安裝，所以必須要有一個額外的 Wi-Fi 來源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;租屋處有使用 Chromecast 2 的需求，它如果連到手機分享出來的 Wi-Fi 熱點的話，分享熱點的手機就不能控制它。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因為以上種種原因，&lt;br /&gt;
加上所以打算多買一張 4G SIM 卡搭配 4G 行動網路分享器，&lt;br /&gt;
在看分享器商品規格的時候發現自己都看不太懂，&lt;br /&gt;
所以花了不少時間查 4G 行動網路相關的資料，&lt;br /&gt;
才發現有些裝置對台灣的電信商支援程度不一，&lt;br /&gt;
買錯的話很可能買來卻不能用，&lt;br /&gt;
或者只能發揮一半的效能，&lt;br /&gt;
想說就在這篇文章筆記一下。  &lt;/p&gt;
&lt;p&gt;（至於 4G 行動網路分享器的部份之後應該也會有一篇某牌設備的使用心得，但不會在這篇提及。因為目前使用上出了些問題，跟原廠回報問題後目前正在處理中。）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;名詞定義&lt;/h2&gt;
&lt;p&gt;首先來搞懂基本的名詞  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4G, LTE, WiMAX  &lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/zh-tw/4G"&gt;第四代行動通訊技術（英語：The fourth generation of mobile phone mobile communication technology standards，縮寫為 4G）&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;2008 年 3 月，在國際電信聯盟 - 無線電通訊部門（ITU-R）指定一組用於 4G 標準的要求，命名為 IMT-Advanced 規範，設定 4G 服務的峰值速度要求在高速行動的通訊（如在火車和汽車上使用）達到 100 Mbit/s，固定或低速行動的通訊（如行人和定點上網的用戶）達到 1 Gbit/s。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;簡單來說，可以想成 4G 只是對於網路速度最大值的門檻，如果行動網路速度的最大值有辦法達到上述條件，則可稱做 4G。（是最大值，不是最小值。）  &lt;/li&gt;
&lt;li&gt;這門檻其實滿高的，不信的話可以拿手機出來測一下網路速度看差多少。  &lt;/li&gt;
&lt;li&gt;最早出現「號稱 4G」的兩個通訊標準：  &lt;ul&gt;
&lt;li&gt;一個是我們現在在台灣最常看到的 &lt;a href="https://zh.wikipedia.org/zh-tw/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93"&gt;LTE&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;另外一個則是&lt;a href="https://zh.wikipedia.org/zh-tw/WiMAX#WiMAX%E5%85%A8%E9%9D%A2%E6%92%A4%E5%8F%B0"&gt;在台灣做不起來的 WiMAX&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;至於為什麼做不起來，詳情可以參考這篇文章：&lt;a href="https://hellolynn.hpd.io/2017/05/19/%E4%BD%A0%E6%9C%89%E8%81%BD%E9%81%8E%E5%8F%B0%E7%81%A3%E7%B4%8D%E7%A8%85%E4%BA%BA%E7%9A%84%E8%A1%80%E6%B7%9Awimax%E5%97%8E-4g%E7%AF%87/"&gt;你有聽過台灣納稅人的血淚WiMax嗎？中離王Intel與榮景不再的高通—4G 篇 – 寫點科普，請給指教。&lt;/a&gt; （私心推薦一下這個 Blog，內容大部份都滿完整且簡單易懂的，而且作者不是資通訊本科生還是一個人因為興趣而寫這些文章，真的覺得很厲害。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但其實這兩種通訊標準根本達不到 4G 的門檻  &lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;2010 年 12 月 6 日，ITU-R 的承認，這兩種技術，以及其他 3.9 技術，不符合 IMT-Advanced 的要求，仍可以被認為是「4G」，但前提是它們是先行者，以 IMT-Advanced 的標準版本和改善的效能和功能來看它只是相當於現在部署的 3G 網路的程度。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正符合 IMT-Advanced 的 4G 規範的其實是 &lt;a href="https://zh.wikipedia.org/zh-tw/4G#IMT-Advanced%E7%9A%844G%E6%A8%99%E6%BA%96"&gt;LTE-Advanced (LTE-A) 和 WirelessMAN-Advanced (又稱 WiMAX-Advanced 或 WiMAX 2)&lt;/a&gt;  &lt;ul&gt;
&lt;li&gt;基本上現在 4G 行動網路發展都以 LTE 為主流了，LTE-Advanced 因為可以透過軟體將 LTE 升級達到，現在台灣的電信商基本上都有支援了，不過能不能使用 LTE-Advanced 的載波聚合來達到真正的 4G 標準速度，就得看裝置了。（至於什麼是載波聚合？下面會提到。）  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;詳細一點可以參考：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.eprice.com.tw/mobile/talk/5035/4979930/1/"&gt;看的好亂啊？！帶你秒懂電信 4G 名詞，不再眼花花 - 手機新聞 | ePrice 比價王&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kocpc.com.tw/archives/68833"&gt;【電信服務】什麼是「真4G」 - 電腦王阿達&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;正片開始&lt;/h2&gt;
&lt;h3&gt;已經用 4G SIM 卡了嗎？你的網路速度很有可能可以再更快。&lt;/h3&gt;
&lt;p&gt;撇開收訊問題，&lt;br /&gt;
你知道同一張 SIM 卡使用都支援 4G 行動網路的不同裝置，&lt;br /&gt;
速度可能會差很多嗎？  &lt;/p&gt;
&lt;p&gt;這跟上面提到的載波聚合（Carrier Aggregation，簡稱 CA）技術有關，&lt;br /&gt;
簡單來說就是透過同時使用不同的 LTE 頻段來增加網路頻寬，&lt;br /&gt;
基本上台灣的電信商目前都至少擁有 3 個以上的 LTE 頻段（中華電信和遠傳有 4 個頻段）。&lt;br /&gt;
可以參考這張 Wikipedia 的截圖（頻段未來有可能會再變動，請以較新的資料為準。）  &lt;/p&gt;
&lt;p&gt;&lt;img alt="20171220-4g-lte-tw" src="/files/4g-mobile-network-tw/20171220-4g-lte-tw.jpg" /&gt;  &lt;/p&gt;
&lt;p&gt;2CA 就是支援兩個頻段（也有可能是同一個頻段，但兩個不連續的區塊組合），&lt;br /&gt;
3CA 則依此類推。&lt;br /&gt;
有沒有支援載波聚合必須看各個裝置，&lt;br /&gt;
如果使用的裝置沒支援的話同一時間只會使用一個頻段，&lt;br /&gt;
當頻寬被附近其他使用同個基地台的使用者佔滿的話，&lt;br /&gt;
網路速度就上不去。&lt;br /&gt;
但如果使用的裝置有支援載波聚合的話，&lt;br /&gt;
就會自動選擇頻寬較足夠的頻段。&lt;br /&gt;
所以購買使用 4G 行動網路的裝置之前，&lt;br /&gt;
除了確認該裝置有支援你要使用的電信商的頻段以外，&lt;br /&gt;
如果想要網路速度能夠快一點的話，&lt;br /&gt;
最好就選擇支援愈多頻段載波聚合的裝置，&lt;br /&gt;
當然價格也會比較貴一些。  &lt;/p&gt;
&lt;p&gt;詳細可以參考以下幾篇文章：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://axiang.cc/archives/22019"&gt;4G該怎麼選？4G+和CA又是什麼？告訴你七個辦4G前必看的問題！ | 阿祥的網路筆記本&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://pigapril.pixnet.net/blog/post/319935925-%E3%80%903c%E3%80%91%E7%B0%A1%E5%96%AE%E6%98%93%E6%87%82---%E4%BB%80%E9%BA%BC%E6%98%AF%22%E8%BC%89%E6%B3%A2%E8%81%9A%E5%90%88carrier-aggrega"&gt;【3C】簡單易懂 - 什麼是"載波聚合Carrier Aggregation", 到底有哪些手機支援!? @ 火星豬 :: 痞客邦 PIXNET ::&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://tel3c.tw/blog/post/222391175"&gt;為何明明買了支援CA手機卻飆不了速呢? 2CA/3CA/4CA支援頻段揭密 - 小丰子3C俱樂部&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;到底頻段是要看 MHz 還是看 Band？&lt;/h3&gt;
&lt;p&gt;在購買 LTE 相關裝置的時候，&lt;br /&gt;
常常會在商品介紹或規格中看到頻段是用 700 MHz, 900 MHz, 1800 MHz, 2100 MHz, 2600 MHz&lt;br /&gt;
或 B28, B8, B3, B1, B7, B38 來表示，&lt;br /&gt;
這邊提供兩張目前台灣電信商使用的頻段對照表，一個照 MHz 由小到大排序，一個照 Band 由小到大排序。  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;MHz&lt;/th&gt;
&lt;th&gt;Band&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;900&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2600&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2600&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Band&lt;/th&gt;
&lt;th&gt;MHz&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2100 (FDD-LTE)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1800 (FDD-LTE)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2600 (FDD-LTE)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;900  (FDD-LTE)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;700  (FDD-LTE)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;2600 (TD-LTE)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;眼尖的人可能會發現有 2 個 2600 MHz，&lt;br /&gt;
所以比較常看到都會用 B1, B3, B7, B8, B28, B38 來表示，&lt;br /&gt;
因為比較不會混淆。&lt;br /&gt;
至於如果是用 MHz 來表示的話，&lt;br /&gt;
可能就要注意一下 2600 MHz 的部份是否只有支援 FDD-LTE, TD-LTE 或兩者都有支援。&lt;br /&gt;
如果有到其他國家使用的需求的話，&lt;br /&gt;
則需要確認一下該國電信商使用的頻段。  &lt;/p&gt;
&lt;h3&gt;支援台灣全頻段？&lt;/h3&gt;
&lt;p&gt;常常會看到有些產品號稱支援台灣 LTE 全頻段，&lt;br /&gt;
到底是什麼意思？&lt;br /&gt;
以目前來說，&lt;br /&gt;
如果要「完整」支援台灣全頻段的話，&lt;br /&gt;
就是要支援上述所有提到的 B1, B3, B7, B8, B28, B38。&lt;br /&gt;
或 700, 900, 1800, 2100, 2600 (FDD-LTE), 2600 (TD-LTE)。&lt;br /&gt;
如果未來有新的頻段的話則會再更多。  &lt;/p&gt;
&lt;p&gt;為什麼說「完整」呢？&lt;br /&gt;
因為有些標榜支援台灣全頻段的產品，&lt;br /&gt;
其實只有支援 B1, B3, B7, B8，&lt;br /&gt;
這點在購買上要注意一下。  &lt;/p&gt;
&lt;h3&gt;不同的頻段有什麼差別嗎？&lt;/h3&gt;
&lt;p&gt;頻率不同，波長不同，涵蓋範圍不同，基地台所需數目不同，單一基地台服務使用者數目不同，網路塞車可能性不同。&lt;br /&gt;
可以用以下的對照表來呈現，以頻率最高的 700 MHz 和 2600 MHz 來比較。  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;頻率&lt;/th&gt;
&lt;th&gt;波長&lt;/th&gt;
&lt;th&gt;涵蓋範圍&lt;/th&gt;
&lt;th&gt;基地台所需數目&lt;/th&gt;
&lt;th&gt;單一基地台服務使用者數&lt;/th&gt;
&lt;th&gt;網路塞車可能性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;700 MHz&lt;/td&gt;
&lt;td&gt;較長&lt;/td&gt;
&lt;td&gt;較大&lt;/td&gt;
&lt;td&gt;較少&lt;/td&gt;
&lt;td&gt;較多&lt;/td&gt;
&lt;td&gt;較高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2600 MHz&lt;/td&gt;
&lt;td&gt;較短&lt;/td&gt;
&lt;td&gt;較小&lt;/td&gt;
&lt;td&gt;較多&lt;/td&gt;
&lt;td&gt;較少&lt;/td&gt;
&lt;td&gt;較低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;實際使用上會跟訊號強度以及電信商佈署的基地台密度有關。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;補充&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenSignalMap 這個 App 挺好用的，不僅可以查使用中的 SIM 卡電信商的基地台位置，也可以測行動網路和使用的 Wi-Fi 網路的速度。  &lt;/li&gt;
&lt;li&gt;VoLTE, FDD-LTE, TDD-LTE 這些有空會再補充，今天有點來不及寫完啦。(也可能不會補充？）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為沒有很懂，&lt;br /&gt;
所以可能會有錯誤的地方，&lt;br /&gt;
歡迎留言回覆告知討論交流，&lt;br /&gt;
感謝。  &lt;/p&gt;</summary><category term="4G"></category><category term="LTE"></category><category term="2018 iT 邦幫忙鐵人賽"></category><category term="Mobile Network"></category></entry></feed>