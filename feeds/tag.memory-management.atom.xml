<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Just for noting</title><link href="https://blog.m157q.tw/" rel="alternate"></link><link href="https://blog.m157q.tw/feeds/tag.memory-management.atom.xml" rel="self"></link><id>https://blog.m157q.tw/</id><updated>2013-11-26T03:25:00+08:00</updated><entry><title>OS Ch8 - Memory Management</title><link href="https://blog.m157q.tw/posts/2013/11/26/os-ch8-memory-management/" rel="alternate"></link><published>2013-11-26T03:25:00+08:00</published><updated>2013-11-26T03:25:00+08:00</updated><author><name>m157q</name></author><id>tag:blog.m157q.tw,2013-11-26:posts/2013/11/26/os-ch8-memory-management/</id><summary type="html">&lt;h2&gt;NCTUCS 2013-Fall Introduction to Operating System by Hank Wu&lt;/h2&gt;
&lt;h2&gt;Ch8 - Memory Management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;To provide a detailed description of various ways of organizing memory hardware  &lt;/li&gt;
&lt;li&gt;To discuss various memory-management techniques, including paging and segmentation  &lt;/li&gt;
&lt;li&gt;To provide a detailed description of the Intel Pentium, which supports both pure segmentation and segmentation with paging  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Program must be brought (from disk) into memory and placed within a process for it to be run  &lt;/li&gt;
&lt;li&gt;Main memory and registers are only storage CPU can access directly  &lt;/li&gt;
&lt;li&gt;Register access in one CPU clock (or less)  &lt;/li&gt;
&lt;li&gt;Main memory can take many cycles  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cache&lt;/strong&gt; sits between main memory and CPU registers  &lt;/li&gt;
&lt;li&gt;Protection of memory required to ensure correct operation  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Base and Limit Registers&lt;/h3&gt;
&lt;p&gt;A pair of &lt;strong&gt;base&lt;/strong&gt; and &lt;strong&gt;limit&lt;/strong&gt; registers define the logical address space&lt;br /&gt;
&lt;img alt="Screenshot 1" src="/files/os-ch8-memory-management/screenshot1.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;￼Binding of Instructions and Data to Memory&lt;/h3&gt;
&lt;p&gt;Address binding of instructions and data to memory addresses can happen at three different stages&lt;br /&gt;
+ Compile time&lt;br /&gt;
    + If memory location known a priori, absolute code can be generated&lt;br /&gt;
    + must recompile code if starting location changes&lt;br /&gt;
+ Load time&lt;br /&gt;
    + Must generate relocatable code if memory location is not known at compile time&lt;br /&gt;
+ Execution time&lt;br /&gt;
    + Binding delayed until run time if the process can be moved during its execution from one memory segment to another.&lt;br /&gt;
    + Need hardware support for address maps (e.g., base and limit registers)  &lt;/p&gt;
&lt;h3&gt;Multistep Processing of a User Program&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Screenshot 2" src="/files/os-ch8-memory-management/screenshot2.jpg" /&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在這中間的每個步驟都可以作 Address binding&lt;br /&gt;
windows 底下的 .dll 檔, IE Explorer 的 ActiveX 都是動態連結的例子  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;￼Logical vs. Physical Address Space&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Logical address – generated by the CPU; also referred to as virtual address  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Physical address – address seen by the memory unit  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The concept of a logical address space that is bound to a separate physical address space is central to proper memory management  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Logical and physical addresses are the same in &lt;strong&gt;compile-time&lt;/strong&gt; and &lt;strong&gt;load-time&lt;/strong&gt; address-binding schemes  &lt;/li&gt;
&lt;li&gt;Logical (virtual) and physical addresses differ in &lt;strong&gt;execution-time&lt;/strong&gt; address-binding scheme  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Memory-Management Unit (MMU)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hardware device that maps virtual to physical address  &lt;/li&gt;
&lt;li&gt;In MMU scheme, the value in the relocation register is added to every address generated by a user process at the time it is sent to memory  &lt;/li&gt;
&lt;li&gt;The user program deals with logical addresses; it never sees the real physical addresses  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;￼Dynamic relocation using a relocation register&lt;/h4&gt;
&lt;h2&gt;&lt;img alt="Screenshot 3" src="/files/os-ch8-memory-management/screenshot3.jpg" /&gt;&lt;/h2&gt;
&lt;h2&gt;Swapping&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2&gt;Contiguous Memory Allocation&lt;/h2&gt;
&lt;h3&gt;Fragmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;total memory space exists to satisfy a request, but it is not contiguous  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;allocated memory may be slightly larger than requested memory  &lt;/li&gt;
&lt;li&gt;this size difference is memory internal to a partition, but not being used  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reduce external fragmentation by &lt;strong&gt;compaction&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;Shuffle memory contents to place all free memory together in one large block  &lt;/li&gt;
&lt;li&gt;Compaction is possible only if relocation is dynamic, and is done at execution time  &lt;/li&gt;
&lt;li&gt;I/O problem  &lt;ul&gt;
&lt;li&gt;Latch job in memory while it is involved in I/O  &lt;/li&gt;
&lt;li&gt;Do I/O only into OS buffers  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Paging&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;目前最常見的是以 4k 為單位的 page&lt;br /&gt;
表格的內容是由 software 在維護的，硬體藉由查詢表格的內容得知記憶體的位置。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Logical address space of a process can be &lt;strong&gt;noncontiguous&lt;/strong&gt;; process is allocated physical memory whenever the latter is available  &lt;/li&gt;
&lt;li&gt;Divide physical memory into fixed-sized blocks called frames (size is power of 2, between 512 bytes and 8,192 bytes)  &lt;/li&gt;
&lt;li&gt;Divide logical memory into blocks of same size called pages  &lt;/li&gt;
&lt;li&gt;Keep track of all free frames  &lt;/li&gt;
&lt;li&gt;To run a program of size n pages, need to find n free frames and load program  &lt;/li&gt;
&lt;li&gt;Set up a page table to translate logical to physical addresses  &lt;/li&gt;
&lt;li&gt;Internal fragmentation  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;￼Paging Model of Logical and Physical Memory&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Physical Memory 可以不用是連續的&lt;br /&gt;
可透過 page table 對應到連續的 Logical Memeory&lt;br /&gt;
達到彈性化的 Memory Management  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Free Frames&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Page Table 是由 OS 在 Maintain 的  &lt;/li&gt;
&lt;li&gt;Free Frame 也是由 OS 在 Maintain 的，要 Allocate 新的記憶體空間必須透過 Free Frame 尋找 Available 的記憶體空間  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Implementation of Page Table&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Page-table base register (PTBR) points to the page table&lt;br /&gt;
  Page-table length register (PRLR) indicates size of the page table  &lt;/p&gt;
&lt;p&gt;X86 內的 CR3 就是 X86 的 PTBR&lt;br /&gt;
  X86 的 Page Table 長度是固定的，所以不需要 PRLR  &lt;/p&gt;
&lt;p&gt;Q:剛才提到 Page Table 是由 OS 在 Maintain，但這裡卻說 X86 的 Page Table 長度是固定的。那 Page Table 到底是由 OS 還是 CPU 架構決定？&lt;br /&gt;
  A: OS 的設計還是必須被侷限在 CPU 的架構底下。  &lt;/p&gt;
&lt;p&gt;Page Table 把資料存在 Physical Memory 裡面。  &lt;/p&gt;
&lt;p&gt;從這樣的機制看來，每次的記憶體讀寫都要花兩倍的時間&lt;br /&gt;
1. Logical Memory 和 Page Table 之間&lt;br /&gt;
2. Page Table 和 Physical Memory 之間&lt;br /&gt;
這樣看來 Performance 會非常差&lt;br /&gt;
但實際上有 Cache 的存在，所以會解決這個問題  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a special fast-lookup hardware cache called associative memory or &lt;strong&gt;translation look-aside buffers (TLBs)&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;Some TLBs store &lt;strong&gt;address-space identifiers (ASIDs)&lt;/strong&gt; in each TLB entry – &lt;strong&gt;uniquely identifies each process to provide address-space protection for that process&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Effective Access Time&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;EAT = 2 + \varepsilon + \alpha  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Memory Protection&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Valid-invalid bit&lt;/strong&gt; attached to each entry in the page table&lt;br /&gt;
+ Valid&lt;br /&gt;
    + in the process’ logical address space&lt;br /&gt;
    + legal page&lt;br /&gt;
+ Invalid&lt;br /&gt;
    + not in the process’ logical address space&lt;br /&gt;
    + illegal page  &lt;/p&gt;
&lt;h3&gt;Shared Pages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Shared code  &lt;/li&gt;
&lt;li&gt;Private code and data  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Structure of the Page Table&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Hierarchical Paging  &lt;/li&gt;
&lt;li&gt;Hashed Page Tables  &lt;/li&gt;
&lt;li&gt;Inverted Page Tables  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Hierarchical Page Tables&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Break up the logical address space into multiple page tables  &lt;/li&gt;
&lt;li&gt;A simple technique is a two-level page table  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Two-Level Page-Table Scheme&lt;/h4&gt;
&lt;p&gt;見 p.39 的圖&lt;br /&gt;
&lt;img alt="Screenshot 4" src="/files/os-ch8-memory-management/screenshot4.jpg" /&gt;  &lt;/p&gt;
&lt;h4&gt;Address-Translation Scheme&lt;/h4&gt;
&lt;p&gt;見 p.41 的圖&lt;br /&gt;
&lt;img alt="Screenshot 5" src="/files/os-ch8-memory-management/screenshot5.jpg" /&gt;  &lt;/p&gt;
&lt;h4&gt;Three-level Paging Scheme&lt;/h4&gt;
&lt;p&gt;見 p.42 的圖&lt;br /&gt;
&lt;img alt="Screenshot 6" src="/files/os-ch8-memory-management/screenshot6.jpg" /&gt;&lt;br /&gt;
outer page, inner page, offset  &lt;/p&gt;
&lt;h3&gt;Hashed Page Table&lt;/h3&gt;
&lt;p&gt;見 p.44 的圖&lt;br /&gt;
&lt;img alt="Screenshot 7" src="/files/os-ch8-memory-management/screenshot7.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 Collision 的問題得解決:利用資料結構學到的方法解決  &lt;/li&gt;
&lt;li&gt;時間複雜度不見得會是 O(1), depend on chain 的長度  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Inverted Page Table&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;優點  &lt;ul&gt;
&lt;li&gt;針對 External Fragmentation 做解決（也是為什麼要有 Page Table 的主要原因）  &lt;/li&gt;
&lt;li&gt;以 Memory Frame 為本位設計  &lt;/li&gt;
&lt;li&gt;每個 Frame 都有一個對應的 Page Table  &lt;/li&gt;
&lt;li&gt;不需要實作 Hash Function  &lt;/li&gt;
&lt;li&gt;直接到一維陣列裡面做線性的搜尋，比較簡單  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺點  &lt;ul&gt;
&lt;li&gt;搜尋很花時間  &lt;/li&gt;
&lt;li&gt;不能作多對一的 Mapping  &lt;/li&gt;
&lt;li&gt;無法實作 Shared Memory Page  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Segmentation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;透過前面的 Paging 可以得到一個很大的記憶體空間&lt;br /&gt;
Segmentation 就是在規劃這些 Address Space 分成不同的 Segment&lt;br /&gt;
每個 Segment 負責不同性質的工作&lt;br /&gt;
以提升記憶體管理的效率。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;程式碼區段是唯讀的，可以確保不會被更改，以及比較不容易被惡意攻擊者利用  &lt;/li&gt;
&lt;li&gt;讓 Stack 有專屬的暫存器  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Logical View of Segmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;和 Page Table 類似，但還是有不同處  &lt;ul&gt;
&lt;li&gt;相同處：Mapping 的方法相同  &lt;/li&gt;
&lt;li&gt;不同處：每個 Segment 的長度是可以變的  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 X86 上面，是先有 Segment 後才有 Page Table 的。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Segmentation Architecture&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Segment table: maps two-dimensional physical addresses  &lt;ul&gt;
&lt;li&gt;base: contains the starting physical address where the segments reside in memory  &lt;/li&gt;
&lt;li&gt;limit: specifies the length of the segment  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Segment-table base register (STBR): points to the segment table’s location in memory  &lt;/li&gt;
&lt;li&gt;Segment-table length register (STLR): indicates number of segments used by a program;  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;if Validation bit = zero, then this segment is illegal.&lt;br /&gt;
超過非法的 Segment 取用範圍 =&amp;gt; Segmentatioin Fault (segment number &amp;gt;= STLR)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Segmentation Hardware&lt;/h3&gt;
&lt;p&gt;見 p.52 的圖&lt;br /&gt;
&lt;img alt="Screenshot 8" src="/files/os-ch8-memory-management/screenshot8.jpg" /&gt;  &lt;/p&gt;
&lt;h3&gt;Example of Segmentation&lt;/h3&gt;
&lt;p&gt;見 p.53 的圖&lt;br /&gt;
&lt;img alt="Screenshot 9" src="/files/os-ch8-memory-management/screenshot9.jpg" /&gt;  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Example: The Intel Pentium&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Supports both segmentation and segmentation with paging  &lt;/li&gt;
&lt;li&gt;CPU generates logical address  &lt;ul&gt;
&lt;li&gt;Given to segmentation unit  &lt;/li&gt;
&lt;li&gt;Linear address given to paging unit  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Pentium Paging Architecture&lt;/h3&gt;
&lt;p&gt;見 p.57 的圖&lt;br /&gt;
&lt;img alt="Screenshot 10" src="/files/os-ch8-memory-management/screenshot10.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;越接近 Outer Table，則尺度是越大的  &lt;/li&gt;
&lt;li&gt;4KB page =&amp;gt; 2 layer  &lt;/li&gt;
&lt;li&gt;4MB page =&amp;gt; 直接由 page directory 產生，不需要是 2 layer  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Linear Address in Linux&lt;/h3&gt;
&lt;p&gt;global directory, middle directory, page table, offset  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用到 kernel code 才能用的 segment 的話，也會出現 Segmentation Fault  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Three-level Paging in Linux&lt;/h3&gt;
&lt;p&gt;見 p.59 的圖&lt;br /&gt;
&lt;img alt="Screenshot 11" src="/files/os-ch8-memory-management/screenshot11.jpg" /&gt;  &lt;/p&gt;</summary><category term="Operating System"></category><category term="Memory Management"></category></entry></feed>